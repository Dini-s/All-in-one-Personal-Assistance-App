
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Education
 * 
 */
export type Education = $Result.DefaultSelection<Prisma.$EducationPayload>
/**
 * Model Syllabus
 * 
 */
export type Syllabus = $Result.DefaultSelection<Prisma.$SyllabusPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model SyllabusSubject
 * 
 */
export type SyllabusSubject = $Result.DefaultSelection<Prisma.$SyllabusSubjectPayload>
/**
 * Model Complain
 * 
 */
export type Complain = $Result.DefaultSelection<Prisma.$ComplainPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Administrator
 * 
 */
export type Administrator = $Result.DefaultSelection<Prisma.$AdministratorPayload>
/**
 * Model ServiceProvider
 * 
 */
export type ServiceProvider = $Result.DefaultSelection<Prisma.$ServiceProviderPayload>
/**
 * Model Customer_Provider
 * 
 */
export type Customer_Provider = $Result.DefaultSelection<Prisma.$Customer_ProviderPayload>
/**
 * Model ServiceProvider_Reports
 * 
 */
export type ServiceProvider_Reports = $Result.DefaultSelection<Prisma.$ServiceProvider_ReportsPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model PaymentMethod
 * 
 */
export type PaymentMethod = $Result.DefaultSelection<Prisma.$PaymentMethodPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model FeedbackRating
 * 
 */
export type FeedbackRating = $Result.DefaultSelection<Prisma.$FeedbackRatingPayload>
/**
 * Model ProviderSalary
 * 
 */
export type ProviderSalary = $Result.DefaultSelection<Prisma.$ProviderSalaryPayload>
/**
 * Model InFlow
 * 
 */
export type InFlow = $Result.DefaultSelection<Prisma.$InFlowPayload>
/**
 * Model OutFlow
 * 
 */
export type OutFlow = $Result.DefaultSelection<Prisma.$OutFlowPayload>
/**
 * Model Revenue
 * 
 */
export type Revenue = $Result.DefaultSelection<Prisma.$RevenuePayload>
/**
 * Model Expenses
 * 
 */
export type Expenses = $Result.DefaultSelection<Prisma.$ExpensesPayload>
/**
 * Model Assests
 * 
 */
export type Assests = $Result.DefaultSelection<Prisma.$AssestsPayload>
/**
 * Model Liability
 * 
 */
export type Liability = $Result.DefaultSelection<Prisma.$LiabilityPayload>
/**
 * Model profitLoss
 * 
 */
export type profitLoss = $Result.DefaultSelection<Prisma.$profitLossPayload>
/**
 * Model savedPaymentMethod
 * 
 */
export type savedPaymentMethod = $Result.DefaultSelection<Prisma.$savedPaymentMethodPayload>
/**
 * Model RefundRequests
 * 
 */
export type RefundRequests = $Result.DefaultSelection<Prisma.$RefundRequestsPayload>
/**
 * Model deductionRate
 * 
 */
export type deductionRate = $Result.DefaultSelection<Prisma.$deductionRatePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const BookingStatus: {
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED',
  COMPLETED: 'COMPLETED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const refundStatus: {
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED',
  APPROVED: 'APPROVED'
};

export type refundStatus = (typeof refundStatus)[keyof typeof refundStatus]


export const complianStatus: {
  PENDING: 'PENDING',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type complianStatus = (typeof complianStatus)[keyof typeof complianStatus]

}

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type refundStatus = $Enums.refundStatus

export const refundStatus: typeof $Enums.refundStatus

export type complianStatus = $Enums.complianStatus

export const complianStatus: typeof $Enums.complianStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.education`: Exposes CRUD operations for the **Education** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Educations
    * const educations = await prisma.education.findMany()
    * ```
    */
  get education(): Prisma.EducationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syllabus`: Exposes CRUD operations for the **Syllabus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Syllabi
    * const syllabi = await prisma.syllabus.findMany()
    * ```
    */
  get syllabus(): Prisma.SyllabusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syllabusSubject`: Exposes CRUD operations for the **SyllabusSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyllabusSubjects
    * const syllabusSubjects = await prisma.syllabusSubject.findMany()
    * ```
    */
  get syllabusSubject(): Prisma.SyllabusSubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complain`: Exposes CRUD operations for the **Complain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complains
    * const complains = await prisma.complain.findMany()
    * ```
    */
  get complain(): Prisma.ComplainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.administrator`: Exposes CRUD operations for the **Administrator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Administrators
    * const administrators = await prisma.administrator.findMany()
    * ```
    */
  get administrator(): Prisma.AdministratorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceProvider`: Exposes CRUD operations for the **ServiceProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceProviders
    * const serviceProviders = await prisma.serviceProvider.findMany()
    * ```
    */
  get serviceProvider(): Prisma.ServiceProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer_Provider`: Exposes CRUD operations for the **Customer_Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customer_Providers
    * const customer_Providers = await prisma.customer_Provider.findMany()
    * ```
    */
  get customer_Provider(): Prisma.Customer_ProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceProvider_Reports`: Exposes CRUD operations for the **ServiceProvider_Reports** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceProvider_Reports
    * const serviceProvider_Reports = await prisma.serviceProvider_Reports.findMany()
    * ```
    */
  get serviceProvider_Reports(): Prisma.ServiceProvider_ReportsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentMethod`: Exposes CRUD operations for the **PaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentMethods
    * const paymentMethods = await prisma.paymentMethod.findMany()
    * ```
    */
  get paymentMethod(): Prisma.PaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedbackRating`: Exposes CRUD operations for the **FeedbackRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackRatings
    * const feedbackRatings = await prisma.feedbackRating.findMany()
    * ```
    */
  get feedbackRating(): Prisma.FeedbackRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providerSalary`: Exposes CRUD operations for the **ProviderSalary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderSalaries
    * const providerSalaries = await prisma.providerSalary.findMany()
    * ```
    */
  get providerSalary(): Prisma.ProviderSalaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inFlow`: Exposes CRUD operations for the **InFlow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InFlows
    * const inFlows = await prisma.inFlow.findMany()
    * ```
    */
  get inFlow(): Prisma.InFlowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outFlow`: Exposes CRUD operations for the **OutFlow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutFlows
    * const outFlows = await prisma.outFlow.findMany()
    * ```
    */
  get outFlow(): Prisma.OutFlowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.revenue`: Exposes CRUD operations for the **Revenue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Revenues
    * const revenues = await prisma.revenue.findMany()
    * ```
    */
  get revenue(): Prisma.RevenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenses`: Exposes CRUD operations for the **Expenses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expenses.findMany()
    * ```
    */
  get expenses(): Prisma.ExpensesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assests`: Exposes CRUD operations for the **Assests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assests
    * const assests = await prisma.assests.findMany()
    * ```
    */
  get assests(): Prisma.AssestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.liability`: Exposes CRUD operations for the **Liability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Liabilities
    * const liabilities = await prisma.liability.findMany()
    * ```
    */
  get liability(): Prisma.LiabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profitLoss`: Exposes CRUD operations for the **profitLoss** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfitLosses
    * const profitLosses = await prisma.profitLoss.findMany()
    * ```
    */
  get profitLoss(): Prisma.profitLossDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedPaymentMethod`: Exposes CRUD operations for the **savedPaymentMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedPaymentMethods
    * const savedPaymentMethods = await prisma.savedPaymentMethod.findMany()
    * ```
    */
  get savedPaymentMethod(): Prisma.savedPaymentMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refundRequests`: Exposes CRUD operations for the **RefundRequests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefundRequests
    * const refundRequests = await prisma.refundRequests.findMany()
    * ```
    */
  get refundRequests(): Prisma.RefundRequestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deductionRate`: Exposes CRUD operations for the **deductionRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeductionRates
    * const deductionRates = await prisma.deductionRate.findMany()
    * ```
    */
  get deductionRate(): Prisma.deductionRateDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.5.0
   * Query Engine version: 173f8d54f8d52e692c7e27e72a88314ec7aeff60
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    Category: 'Category',
    Education: 'Education',
    Syllabus: 'Syllabus',
    Subject: 'Subject',
    SyllabusSubject: 'SyllabusSubject',
    Complain: 'Complain',
    Service: 'Service',
    Administrator: 'Administrator',
    ServiceProvider: 'ServiceProvider',
    Customer_Provider: 'Customer_Provider',
    ServiceProvider_Reports: 'ServiceProvider_Reports',
    Booking: 'Booking',
    PaymentMethod: 'PaymentMethod',
    Payment: 'Payment',
    Schedule: 'Schedule',
    FeedbackRating: 'FeedbackRating',
    ProviderSalary: 'ProviderSalary',
    InFlow: 'InFlow',
    OutFlow: 'OutFlow',
    Revenue: 'Revenue',
    Expenses: 'Expenses',
    Assests: 'Assests',
    Liability: 'Liability',
    profitLoss: 'profitLoss',
    savedPaymentMethod: 'savedPaymentMethod',
    RefundRequests: 'RefundRequests',
    deductionRate: 'deductionRate'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "customer" | "category" | "education" | "syllabus" | "subject" | "syllabusSubject" | "complain" | "service" | "administrator" | "serviceProvider" | "customer_Provider" | "serviceProvider_Reports" | "booking" | "paymentMethod" | "payment" | "schedule" | "feedbackRating" | "providerSalary" | "inFlow" | "outFlow" | "revenue" | "expenses" | "assests" | "liability" | "profitLoss" | "savedPaymentMethod" | "refundRequests" | "deductionRate"
      txIsolationLevel: never
    }
    model: {
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CustomerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CustomerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CategoryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CategoryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Education: {
        payload: Prisma.$EducationPayload<ExtArgs>
        fields: Prisma.EducationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findFirst: {
            args: Prisma.EducationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          findMany: {
            args: Prisma.EducationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>[]
          }
          create: {
            args: Prisma.EducationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          createMany: {
            args: Prisma.EducationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EducationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          update: {
            args: Prisma.EducationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          deleteMany: {
            args: Prisma.EducationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EducationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPayload>
          }
          aggregate: {
            args: Prisma.EducationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducation>
          }
          groupBy: {
            args: Prisma.EducationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EducationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.EducationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.EducationCountArgs<ExtArgs>
            result: $Utils.Optional<EducationCountAggregateOutputType> | number
          }
        }
      }
      Syllabus: {
        payload: Prisma.$SyllabusPayload<ExtArgs>
        fields: Prisma.SyllabusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyllabusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyllabusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          findFirst: {
            args: Prisma.SyllabusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyllabusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          findMany: {
            args: Prisma.SyllabusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>[]
          }
          create: {
            args: Prisma.SyllabusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          createMany: {
            args: Prisma.SyllabusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SyllabusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          update: {
            args: Prisma.SyllabusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          deleteMany: {
            args: Prisma.SyllabusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyllabusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyllabusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusPayload>
          }
          aggregate: {
            args: Prisma.SyllabusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyllabus>
          }
          groupBy: {
            args: Prisma.SyllabusGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyllabusGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SyllabusFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SyllabusAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SyllabusCountArgs<ExtArgs>
            result: $Utils.Optional<SyllabusCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SubjectFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SubjectAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      SyllabusSubject: {
        payload: Prisma.$SyllabusSubjectPayload<ExtArgs>
        fields: Prisma.SyllabusSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyllabusSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyllabusSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusSubjectPayload>
          }
          findFirst: {
            args: Prisma.SyllabusSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyllabusSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusSubjectPayload>
          }
          findMany: {
            args: Prisma.SyllabusSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusSubjectPayload>[]
          }
          create: {
            args: Prisma.SyllabusSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusSubjectPayload>
          }
          createMany: {
            args: Prisma.SyllabusSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SyllabusSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusSubjectPayload>
          }
          update: {
            args: Prisma.SyllabusSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusSubjectPayload>
          }
          deleteMany: {
            args: Prisma.SyllabusSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyllabusSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SyllabusSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyllabusSubjectPayload>
          }
          aggregate: {
            args: Prisma.SyllabusSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyllabusSubject>
          }
          groupBy: {
            args: Prisma.SyllabusSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyllabusSubjectGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SyllabusSubjectFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SyllabusSubjectAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SyllabusSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SyllabusSubjectCountAggregateOutputType> | number
          }
        }
      }
      Complain: {
        payload: Prisma.$ComplainPayload<ExtArgs>
        fields: Prisma.ComplainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplainPayload>
          }
          findFirst: {
            args: Prisma.ComplainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplainPayload>
          }
          findMany: {
            args: Prisma.ComplainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplainPayload>[]
          }
          create: {
            args: Prisma.ComplainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplainPayload>
          }
          createMany: {
            args: Prisma.ComplainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComplainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplainPayload>
          }
          update: {
            args: Prisma.ComplainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplainPayload>
          }
          deleteMany: {
            args: Prisma.ComplainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplainPayload>
          }
          aggregate: {
            args: Prisma.ComplainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplain>
          }
          groupBy: {
            args: Prisma.ComplainGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplainGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ComplainFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ComplainAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ComplainCountArgs<ExtArgs>
            result: $Utils.Optional<ComplainCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Administrator: {
        payload: Prisma.$AdministratorPayload<ExtArgs>
        fields: Prisma.AdministratorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdministratorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdministratorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          findFirst: {
            args: Prisma.AdministratorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdministratorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          findMany: {
            args: Prisma.AdministratorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>[]
          }
          create: {
            args: Prisma.AdministratorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          createMany: {
            args: Prisma.AdministratorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdministratorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          update: {
            args: Prisma.AdministratorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          deleteMany: {
            args: Prisma.AdministratorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdministratorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdministratorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministratorPayload>
          }
          aggregate: {
            args: Prisma.AdministratorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdministrator>
          }
          groupBy: {
            args: Prisma.AdministratorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdministratorGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdministratorFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdministratorAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AdministratorCountArgs<ExtArgs>
            result: $Utils.Optional<AdministratorCountAggregateOutputType> | number
          }
        }
      }
      ServiceProvider: {
        payload: Prisma.$ServiceProviderPayload<ExtArgs>
        fields: Prisma.ServiceProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          findFirst: {
            args: Prisma.ServiceProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          findMany: {
            args: Prisma.ServiceProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>[]
          }
          create: {
            args: Prisma.ServiceProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          createMany: {
            args: Prisma.ServiceProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          update: {
            args: Prisma.ServiceProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          deleteMany: {
            args: Prisma.ServiceProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProviderPayload>
          }
          aggregate: {
            args: Prisma.ServiceProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceProvider>
          }
          groupBy: {
            args: Prisma.ServiceProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceProviderGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiceProviderFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiceProviderAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiceProviderCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceProviderCountAggregateOutputType> | number
          }
        }
      }
      Customer_Provider: {
        payload: Prisma.$Customer_ProviderPayload<ExtArgs>
        fields: Prisma.Customer_ProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Customer_ProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Customer_ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Customer_ProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Customer_ProviderPayload>
          }
          findFirst: {
            args: Prisma.Customer_ProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Customer_ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Customer_ProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Customer_ProviderPayload>
          }
          findMany: {
            args: Prisma.Customer_ProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Customer_ProviderPayload>[]
          }
          create: {
            args: Prisma.Customer_ProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Customer_ProviderPayload>
          }
          createMany: {
            args: Prisma.Customer_ProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Customer_ProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Customer_ProviderPayload>
          }
          update: {
            args: Prisma.Customer_ProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Customer_ProviderPayload>
          }
          deleteMany: {
            args: Prisma.Customer_ProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Customer_ProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Customer_ProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Customer_ProviderPayload>
          }
          aggregate: {
            args: Prisma.Customer_ProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer_Provider>
          }
          groupBy: {
            args: Prisma.Customer_ProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<Customer_ProviderGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Customer_ProviderFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Customer_ProviderAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Customer_ProviderCountArgs<ExtArgs>
            result: $Utils.Optional<Customer_ProviderCountAggregateOutputType> | number
          }
        }
      }
      ServiceProvider_Reports: {
        payload: Prisma.$ServiceProvider_ReportsPayload<ExtArgs>
        fields: Prisma.ServiceProvider_ReportsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceProvider_ReportsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProvider_ReportsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceProvider_ReportsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProvider_ReportsPayload>
          }
          findFirst: {
            args: Prisma.ServiceProvider_ReportsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProvider_ReportsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceProvider_ReportsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProvider_ReportsPayload>
          }
          findMany: {
            args: Prisma.ServiceProvider_ReportsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProvider_ReportsPayload>[]
          }
          create: {
            args: Prisma.ServiceProvider_ReportsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProvider_ReportsPayload>
          }
          createMany: {
            args: Prisma.ServiceProvider_ReportsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceProvider_ReportsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProvider_ReportsPayload>
          }
          update: {
            args: Prisma.ServiceProvider_ReportsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProvider_ReportsPayload>
          }
          deleteMany: {
            args: Prisma.ServiceProvider_ReportsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceProvider_ReportsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceProvider_ReportsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceProvider_ReportsPayload>
          }
          aggregate: {
            args: Prisma.ServiceProvider_ReportsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceProvider_Reports>
          }
          groupBy: {
            args: Prisma.ServiceProvider_ReportsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceProvider_ReportsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiceProvider_ReportsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiceProvider_ReportsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiceProvider_ReportsCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceProvider_ReportsCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BookingFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BookingAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      PaymentMethod: {
        payload: Prisma.$PaymentMethodPayload<ExtArgs>
        fields: Prisma.PaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          findMany: {
            args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
          }
          create: {
            args: Prisma.PaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          createMany: {
            args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          update: {
            args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentMethod>
          }
          groupBy: {
            args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PaymentMethodFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PaymentMethodAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PaymentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PaymentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ScheduleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ScheduleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      FeedbackRating: {
        payload: Prisma.$FeedbackRatingPayload<ExtArgs>
        fields: Prisma.FeedbackRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRatingPayload>
          }
          findFirst: {
            args: Prisma.FeedbackRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRatingPayload>
          }
          findMany: {
            args: Prisma.FeedbackRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRatingPayload>[]
          }
          create: {
            args: Prisma.FeedbackRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRatingPayload>
          }
          createMany: {
            args: Prisma.FeedbackRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeedbackRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRatingPayload>
          }
          update: {
            args: Prisma.FeedbackRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRatingPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackRatingPayload>
          }
          aggregate: {
            args: Prisma.FeedbackRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedbackRating>
          }
          groupBy: {
            args: Prisma.FeedbackRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackRatingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FeedbackRatingFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FeedbackRatingAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FeedbackRatingCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackRatingCountAggregateOutputType> | number
          }
        }
      }
      ProviderSalary: {
        payload: Prisma.$ProviderSalaryPayload<ExtArgs>
        fields: Prisma.ProviderSalaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderSalaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderSalaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderSalaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderSalaryPayload>
          }
          findFirst: {
            args: Prisma.ProviderSalaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderSalaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderSalaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderSalaryPayload>
          }
          findMany: {
            args: Prisma.ProviderSalaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderSalaryPayload>[]
          }
          create: {
            args: Prisma.ProviderSalaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderSalaryPayload>
          }
          createMany: {
            args: Prisma.ProviderSalaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProviderSalaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderSalaryPayload>
          }
          update: {
            args: Prisma.ProviderSalaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderSalaryPayload>
          }
          deleteMany: {
            args: Prisma.ProviderSalaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderSalaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProviderSalaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderSalaryPayload>
          }
          aggregate: {
            args: Prisma.ProviderSalaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviderSalary>
          }
          groupBy: {
            args: Prisma.ProviderSalaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderSalaryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProviderSalaryFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProviderSalaryAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProviderSalaryCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderSalaryCountAggregateOutputType> | number
          }
        }
      }
      InFlow: {
        payload: Prisma.$InFlowPayload<ExtArgs>
        fields: Prisma.InFlowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InFlowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InFlowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InFlowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InFlowPayload>
          }
          findFirst: {
            args: Prisma.InFlowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InFlowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InFlowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InFlowPayload>
          }
          findMany: {
            args: Prisma.InFlowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InFlowPayload>[]
          }
          create: {
            args: Prisma.InFlowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InFlowPayload>
          }
          createMany: {
            args: Prisma.InFlowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InFlowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InFlowPayload>
          }
          update: {
            args: Prisma.InFlowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InFlowPayload>
          }
          deleteMany: {
            args: Prisma.InFlowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InFlowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InFlowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InFlowPayload>
          }
          aggregate: {
            args: Prisma.InFlowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInFlow>
          }
          groupBy: {
            args: Prisma.InFlowGroupByArgs<ExtArgs>
            result: $Utils.Optional<InFlowGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InFlowFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InFlowAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InFlowCountArgs<ExtArgs>
            result: $Utils.Optional<InFlowCountAggregateOutputType> | number
          }
        }
      }
      OutFlow: {
        payload: Prisma.$OutFlowPayload<ExtArgs>
        fields: Prisma.OutFlowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutFlowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutFlowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutFlowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutFlowPayload>
          }
          findFirst: {
            args: Prisma.OutFlowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutFlowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutFlowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutFlowPayload>
          }
          findMany: {
            args: Prisma.OutFlowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutFlowPayload>[]
          }
          create: {
            args: Prisma.OutFlowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutFlowPayload>
          }
          createMany: {
            args: Prisma.OutFlowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OutFlowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutFlowPayload>
          }
          update: {
            args: Prisma.OutFlowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutFlowPayload>
          }
          deleteMany: {
            args: Prisma.OutFlowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutFlowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OutFlowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutFlowPayload>
          }
          aggregate: {
            args: Prisma.OutFlowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutFlow>
          }
          groupBy: {
            args: Prisma.OutFlowGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutFlowGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OutFlowFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.OutFlowAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.OutFlowCountArgs<ExtArgs>
            result: $Utils.Optional<OutFlowCountAggregateOutputType> | number
          }
        }
      }
      Revenue: {
        payload: Prisma.$RevenuePayload<ExtArgs>
        fields: Prisma.RevenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          findFirst: {
            args: Prisma.RevenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          findMany: {
            args: Prisma.RevenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>[]
          }
          create: {
            args: Prisma.RevenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          createMany: {
            args: Prisma.RevenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RevenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          update: {
            args: Prisma.RevenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          deleteMany: {
            args: Prisma.RevenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RevenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenuePayload>
          }
          aggregate: {
            args: Prisma.RevenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevenue>
          }
          groupBy: {
            args: Prisma.RevenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevenueGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RevenueFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RevenueAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RevenueCountArgs<ExtArgs>
            result: $Utils.Optional<RevenueCountAggregateOutputType> | number
          }
        }
      }
      Expenses: {
        payload: Prisma.$ExpensesPayload<ExtArgs>
        fields: Prisma.ExpensesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpensesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpensesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          findFirst: {
            args: Prisma.ExpensesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpensesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          findMany: {
            args: Prisma.ExpensesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>[]
          }
          create: {
            args: Prisma.ExpensesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          createMany: {
            args: Prisma.ExpensesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ExpensesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          update: {
            args: Prisma.ExpensesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          deleteMany: {
            args: Prisma.ExpensesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpensesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpensesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensesPayload>
          }
          aggregate: {
            args: Prisma.ExpensesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenses>
          }
          groupBy: {
            args: Prisma.ExpensesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpensesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ExpensesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ExpensesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ExpensesCountArgs<ExtArgs>
            result: $Utils.Optional<ExpensesCountAggregateOutputType> | number
          }
        }
      }
      Assests: {
        payload: Prisma.$AssestsPayload<ExtArgs>
        fields: Prisma.AssestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssestsPayload>
          }
          findFirst: {
            args: Prisma.AssestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssestsPayload>
          }
          findMany: {
            args: Prisma.AssestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssestsPayload>[]
          }
          create: {
            args: Prisma.AssestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssestsPayload>
          }
          createMany: {
            args: Prisma.AssestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AssestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssestsPayload>
          }
          update: {
            args: Prisma.AssestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssestsPayload>
          }
          deleteMany: {
            args: Prisma.AssestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssestsPayload>
          }
          aggregate: {
            args: Prisma.AssestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssests>
          }
          groupBy: {
            args: Prisma.AssestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssestsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AssestsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AssestsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AssestsCountArgs<ExtArgs>
            result: $Utils.Optional<AssestsCountAggregateOutputType> | number
          }
        }
      }
      Liability: {
        payload: Prisma.$LiabilityPayload<ExtArgs>
        fields: Prisma.LiabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LiabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LiabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          findFirst: {
            args: Prisma.LiabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LiabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          findMany: {
            args: Prisma.LiabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>[]
          }
          create: {
            args: Prisma.LiabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          createMany: {
            args: Prisma.LiabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LiabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          update: {
            args: Prisma.LiabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          deleteMany: {
            args: Prisma.LiabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LiabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LiabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LiabilityPayload>
          }
          aggregate: {
            args: Prisma.LiabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLiability>
          }
          groupBy: {
            args: Prisma.LiabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<LiabilityGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LiabilityFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LiabilityAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LiabilityCountArgs<ExtArgs>
            result: $Utils.Optional<LiabilityCountAggregateOutputType> | number
          }
        }
      }
      profitLoss: {
        payload: Prisma.$profitLossPayload<ExtArgs>
        fields: Prisma.profitLossFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profitLossFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profitLossPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profitLossFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profitLossPayload>
          }
          findFirst: {
            args: Prisma.profitLossFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profitLossPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profitLossFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profitLossPayload>
          }
          findMany: {
            args: Prisma.profitLossFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profitLossPayload>[]
          }
          create: {
            args: Prisma.profitLossCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profitLossPayload>
          }
          createMany: {
            args: Prisma.profitLossCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.profitLossDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profitLossPayload>
          }
          update: {
            args: Prisma.profitLossUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profitLossPayload>
          }
          deleteMany: {
            args: Prisma.profitLossDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.profitLossUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.profitLossUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profitLossPayload>
          }
          aggregate: {
            args: Prisma.ProfitLossAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfitLoss>
          }
          groupBy: {
            args: Prisma.profitLossGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfitLossGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.profitLossFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.profitLossAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.profitLossCountArgs<ExtArgs>
            result: $Utils.Optional<ProfitLossCountAggregateOutputType> | number
          }
        }
      }
      savedPaymentMethod: {
        payload: Prisma.$savedPaymentMethodPayload<ExtArgs>
        fields: Prisma.savedPaymentMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.savedPaymentMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedPaymentMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.savedPaymentMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedPaymentMethodPayload>
          }
          findFirst: {
            args: Prisma.savedPaymentMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedPaymentMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.savedPaymentMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedPaymentMethodPayload>
          }
          findMany: {
            args: Prisma.savedPaymentMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedPaymentMethodPayload>[]
          }
          create: {
            args: Prisma.savedPaymentMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedPaymentMethodPayload>
          }
          createMany: {
            args: Prisma.savedPaymentMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.savedPaymentMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedPaymentMethodPayload>
          }
          update: {
            args: Prisma.savedPaymentMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedPaymentMethodPayload>
          }
          deleteMany: {
            args: Prisma.savedPaymentMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.savedPaymentMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.savedPaymentMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedPaymentMethodPayload>
          }
          aggregate: {
            args: Prisma.SavedPaymentMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedPaymentMethod>
          }
          groupBy: {
            args: Prisma.savedPaymentMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedPaymentMethodGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.savedPaymentMethodFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.savedPaymentMethodAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.savedPaymentMethodCountArgs<ExtArgs>
            result: $Utils.Optional<SavedPaymentMethodCountAggregateOutputType> | number
          }
        }
      }
      RefundRequests: {
        payload: Prisma.$RefundRequestsPayload<ExtArgs>
        fields: Prisma.RefundRequestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundRequestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundRequestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
          }
          findFirst: {
            args: Prisma.RefundRequestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundRequestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
          }
          findMany: {
            args: Prisma.RefundRequestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestsPayload>[]
          }
          create: {
            args: Prisma.RefundRequestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
          }
          createMany: {
            args: Prisma.RefundRequestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RefundRequestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
          }
          update: {
            args: Prisma.RefundRequestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
          }
          deleteMany: {
            args: Prisma.RefundRequestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundRequestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefundRequestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundRequestsPayload>
          }
          aggregate: {
            args: Prisma.RefundRequestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefundRequests>
          }
          groupBy: {
            args: Prisma.RefundRequestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundRequestsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RefundRequestsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RefundRequestsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RefundRequestsCountArgs<ExtArgs>
            result: $Utils.Optional<RefundRequestsCountAggregateOutputType> | number
          }
        }
      }
      deductionRate: {
        payload: Prisma.$deductionRatePayload<ExtArgs>
        fields: Prisma.deductionRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.deductionRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.deductionRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionRatePayload>
          }
          findFirst: {
            args: Prisma.deductionRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.deductionRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionRatePayload>
          }
          findMany: {
            args: Prisma.deductionRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionRatePayload>[]
          }
          create: {
            args: Prisma.deductionRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionRatePayload>
          }
          createMany: {
            args: Prisma.deductionRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.deductionRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionRatePayload>
          }
          update: {
            args: Prisma.deductionRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionRatePayload>
          }
          deleteMany: {
            args: Prisma.deductionRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.deductionRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.deductionRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$deductionRatePayload>
          }
          aggregate: {
            args: Prisma.DeductionRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeductionRate>
          }
          groupBy: {
            args: Prisma.deductionRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeductionRateGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.deductionRateFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.deductionRateAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.deductionRateCountArgs<ExtArgs>
            result: $Utils.Optional<DeductionRateCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    customer?: CustomerOmit
    category?: CategoryOmit
    education?: EducationOmit
    syllabus?: SyllabusOmit
    subject?: SubjectOmit
    syllabusSubject?: SyllabusSubjectOmit
    complain?: ComplainOmit
    service?: ServiceOmit
    administrator?: AdministratorOmit
    serviceProvider?: ServiceProviderOmit
    customer_Provider?: Customer_ProviderOmit
    serviceProvider_Reports?: ServiceProvider_ReportsOmit
    booking?: BookingOmit
    paymentMethod?: PaymentMethodOmit
    payment?: PaymentOmit
    schedule?: ScheduleOmit
    feedbackRating?: FeedbackRatingOmit
    providerSalary?: ProviderSalaryOmit
    inFlow?: InFlowOmit
    outFlow?: OutFlowOmit
    revenue?: RevenueOmit
    expenses?: ExpensesOmit
    assests?: AssestsOmit
    liability?: LiabilityOmit
    profitLoss?: profitLossOmit
    savedPaymentMethod?: savedPaymentMethodOmit
    refundRequests?: RefundRequestsOmit
    deductionRate?: deductionRateOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    BookingID: number
    Complains: number
    ServiceProvider: number
    feedbackRating: number
    refundRequests: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BookingID?: boolean | CustomerCountOutputTypeCountBookingIDArgs
    Complains?: boolean | CustomerCountOutputTypeCountComplainsArgs
    ServiceProvider?: boolean | CustomerCountOutputTypeCountServiceProviderArgs
    feedbackRating?: boolean | CustomerCountOutputTypeCountFeedbackRatingArgs
    refundRequests?: boolean | CustomerCountOutputTypeCountRefundRequestsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountBookingIDArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountComplainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplainWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountServiceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Customer_ProviderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountFeedbackRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackRatingWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountRefundRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundRequestsWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    service: number
    education: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | CategoryCountOutputTypeCountServiceArgs
    education?: boolean | CategoryCountOutputTypeCountEducationArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
  }


  /**
   * Count Type EducationCountOutputType
   */

  export type EducationCountOutputType = {
    syllabus: number
  }

  export type EducationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabus?: boolean | EducationCountOutputTypeCountSyllabusArgs
  }

  // Custom InputTypes
  /**
   * EducationCountOutputType without action
   */
  export type EducationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationCountOutputType
     */
    select?: EducationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EducationCountOutputType without action
   */
  export type EducationCountOutputTypeCountSyllabusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusWhereInput
  }


  /**
   * Count Type SyllabusCountOutputType
   */

  export type SyllabusCountOutputType = {
    subjects: number
  }

  export type SyllabusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | SyllabusCountOutputTypeCountSubjectsArgs
  }

  // Custom InputTypes
  /**
   * SyllabusCountOutputType without action
   */
  export type SyllabusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusCountOutputType
     */
    select?: SyllabusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SyllabusCountOutputType without action
   */
  export type SyllabusCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusSubjectWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    syllabuses: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabuses?: boolean | SubjectCountOutputTypeCountSyllabusesArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountSyllabusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusSubjectWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    serviceProvider: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceCountOutputTypeCountServiceProviderArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServiceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceProviderWhereInput
  }


  /**
   * Count Type ServiceProviderCountOutputType
   */

  export type ServiceProviderCountOutputType = {
    bookings: number
    customer: number
  }

  export type ServiceProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceProviderCountOutputTypeCountBookingsArgs
    customer?: boolean | ServiceProviderCountOutputTypeCountCustomerArgs
  }

  // Custom InputTypes
  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProviderCountOutputType
     */
    select?: ServiceProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * ServiceProviderCountOutputType without action
   */
  export type ServiceProviderCountOutputTypeCountCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Customer_ProviderWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    payment: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | BookingCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type PaymentMethodCountOutputType
   */

  export type PaymentMethodCountOutputType = {
    payment: number
  }

  export type PaymentMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentMethodCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethodCountOutputType
     */
    select?: PaymentMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentMethodCountOutputType without action
   */
  export type PaymentMethodCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    FirstName: string | null
    LastName: string | null
    Gender: string | null
    Email: string | null
    Password: string | null
    MobileNumber: string | null
    NIC: string | null
    Address: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    FirstName: string | null
    LastName: string | null
    Gender: string | null
    Email: string | null
    Password: string | null
    MobileNumber: string | null
    NIC: string | null
    Address: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    FirstName: number
    LastName: number
    Gender: number
    Email: number
    Password: number
    MobileNumber: number
    NIC: number
    Address: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    FirstName?: true
    LastName?: true
    Gender?: true
    Email?: true
    Password?: true
    MobileNumber?: true
    NIC?: true
    Address?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    FirstName?: true
    LastName?: true
    Gender?: true
    Email?: true
    Password?: true
    MobileNumber?: true
    NIC?: true
    Address?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    FirstName?: true
    LastName?: true
    Gender?: true
    Email?: true
    Password?: true
    MobileNumber?: true
    NIC?: true
    Address?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    FirstName: string | null
    LastName: string | null
    Gender: string | null
    Email: string | null
    Password: string | null
    MobileNumber: string | null
    NIC: string | null
    Address: string | null
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    FirstName?: boolean
    LastName?: boolean
    Gender?: boolean
    Email?: boolean
    Password?: boolean
    MobileNumber?: boolean
    NIC?: boolean
    Address?: boolean
    BookingID?: boolean | Customer$BookingIDArgs<ExtArgs>
    Complains?: boolean | Customer$ComplainsArgs<ExtArgs>
    ServiceProvider?: boolean | Customer$ServiceProviderArgs<ExtArgs>
    feedbackRating?: boolean | Customer$feedbackRatingArgs<ExtArgs>
    refundRequests?: boolean | Customer$refundRequestsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type CustomerSelectScalar = {
    id?: boolean
    FirstName?: boolean
    LastName?: boolean
    Gender?: boolean
    Email?: boolean
    Password?: boolean
    MobileNumber?: boolean
    NIC?: boolean
    Address?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "FirstName" | "LastName" | "Gender" | "Email" | "Password" | "MobileNumber" | "NIC" | "Address", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BookingID?: boolean | Customer$BookingIDArgs<ExtArgs>
    Complains?: boolean | Customer$ComplainsArgs<ExtArgs>
    ServiceProvider?: boolean | Customer$ServiceProviderArgs<ExtArgs>
    feedbackRating?: boolean | Customer$feedbackRatingArgs<ExtArgs>
    refundRequests?: boolean | Customer$refundRequestsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      BookingID: Prisma.$BookingPayload<ExtArgs>[]
      Complains: Prisma.$ComplainPayload<ExtArgs>[]
      ServiceProvider: Prisma.$Customer_ProviderPayload<ExtArgs>[]
      feedbackRating: Prisma.$FeedbackRatingPayload<ExtArgs>[]
      refundRequests: Prisma.$RefundRequestsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      FirstName: string | null
      LastName: string | null
      Gender: string | null
      Email: string | null
      Password: string | null
      MobileNumber: string | null
      NIC: string | null
      Address: string | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * @param {CustomerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customer = await prisma.customer.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CustomerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Customer.
     * @param {CustomerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customer = await prisma.customer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CustomerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BookingID<T extends Customer$BookingIDArgs<ExtArgs> = {}>(args?: Subset<T, Customer$BookingIDArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Complains<T extends Customer$ComplainsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ComplainsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ServiceProvider<T extends Customer$ServiceProviderArgs<ExtArgs> = {}>(args?: Subset<T, Customer$ServiceProviderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbackRating<T extends Customer$feedbackRatingArgs<ExtArgs> = {}>(args?: Subset<T, Customer$feedbackRatingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refundRequests<T extends Customer$refundRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$refundRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly FirstName: FieldRef<"Customer", 'String'>
    readonly LastName: FieldRef<"Customer", 'String'>
    readonly Gender: FieldRef<"Customer", 'String'>
    readonly Email: FieldRef<"Customer", 'String'>
    readonly Password: FieldRef<"Customer", 'String'>
    readonly MobileNumber: FieldRef<"Customer", 'String'>
    readonly NIC: FieldRef<"Customer", 'String'>
    readonly Address: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data?: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer findRaw
   */
  export type CustomerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Customer aggregateRaw
   */
  export type CustomerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Customer.BookingID
   */
  export type Customer$BookingIDArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Customer.Complains
   */
  export type Customer$ComplainsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
    where?: ComplainWhereInput
    orderBy?: ComplainOrderByWithRelationInput | ComplainOrderByWithRelationInput[]
    cursor?: ComplainWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplainScalarFieldEnum | ComplainScalarFieldEnum[]
  }

  /**
   * Customer.ServiceProvider
   */
  export type Customer$ServiceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    where?: Customer_ProviderWhereInput
    orderBy?: Customer_ProviderOrderByWithRelationInput | Customer_ProviderOrderByWithRelationInput[]
    cursor?: Customer_ProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Customer_ProviderScalarFieldEnum | Customer_ProviderScalarFieldEnum[]
  }

  /**
   * Customer.feedbackRating
   */
  export type Customer$feedbackRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
    where?: FeedbackRatingWhereInput
    orderBy?: FeedbackRatingOrderByWithRelationInput | FeedbackRatingOrderByWithRelationInput[]
    cursor?: FeedbackRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackRatingScalarFieldEnum | FeedbackRatingScalarFieldEnum[]
  }

  /**
   * Customer.refundRequests
   */
  export type Customer$refundRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    where?: RefundRequestsWhereInput
    orderBy?: RefundRequestsOrderByWithRelationInput | RefundRequestsOrderByWithRelationInput[]
    cursor?: RefundRequestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundRequestsScalarFieldEnum | RefundRequestsScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    CategoryID: string | null
    Type: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    CategoryID: string | null
    Type: string | null
  }

  export type CategoryCountAggregateOutputType = {
    CategoryID: number
    Type: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    CategoryID?: true
    Type?: true
  }

  export type CategoryMaxAggregateInputType = {
    CategoryID?: true
    Type?: true
  }

  export type CategoryCountAggregateInputType = {
    CategoryID?: true
    Type?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    CategoryID: string
    Type: string | null
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CategoryID?: boolean
    Type?: boolean
    service?: boolean | Category$serviceArgs<ExtArgs>
    education?: boolean | Category$educationArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>



  export type CategorySelectScalar = {
    CategoryID?: boolean
    Type?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"CategoryID" | "Type", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | Category$serviceArgs<ExtArgs>
    education?: boolean | Category$educationArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>[]
      education: Prisma.$EducationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      CategoryID: string
      Type: string | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `CategoryID`
     * const categoryWithCategoryIDOnly = await prisma.category.findMany({ select: { CategoryID: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * @param {CategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category = await prisma.category.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CategoryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Category.
     * @param {CategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category = await prisma.category.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CategoryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends Category$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Category$serviceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    education<T extends Category$educationArgs<ExtArgs> = {}>(args?: Subset<T, Category$educationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly CategoryID: FieldRef<"Category", 'String'>
    readonly Type: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data?: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category findRaw
   */
  export type CategoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category aggregateRaw
   */
  export type CategoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Category.service
   */
  export type Category$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Category.education
   */
  export type Category$educationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    cursor?: EducationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Education
   */

  export type AggregateEducation = {
    _count: EducationCountAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  export type EducationMinAggregateOutputType = {
    EducationId: string | null
    deliveryMode: string | null
    categoryID: string | null
  }

  export type EducationMaxAggregateOutputType = {
    EducationId: string | null
    deliveryMode: string | null
    categoryID: string | null
  }

  export type EducationCountAggregateOutputType = {
    EducationId: number
    deliveryMode: number
    categoryID: number
    _all: number
  }


  export type EducationMinAggregateInputType = {
    EducationId?: true
    deliveryMode?: true
    categoryID?: true
  }

  export type EducationMaxAggregateInputType = {
    EducationId?: true
    deliveryMode?: true
    categoryID?: true
  }

  export type EducationCountAggregateInputType = {
    EducationId?: true
    deliveryMode?: true
    categoryID?: true
    _all?: true
  }

  export type EducationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Education to aggregate.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Educations
    **/
    _count?: true | EducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationMaxAggregateInputType
  }

  export type GetEducationAggregateType<T extends EducationAggregateArgs> = {
        [P in keyof T & keyof AggregateEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducation[P]>
      : GetScalarType<T[P], AggregateEducation[P]>
  }




  export type EducationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationWhereInput
    orderBy?: EducationOrderByWithAggregationInput | EducationOrderByWithAggregationInput[]
    by: EducationScalarFieldEnum[] | EducationScalarFieldEnum
    having?: EducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationCountAggregateInputType | true
    _min?: EducationMinAggregateInputType
    _max?: EducationMaxAggregateInputType
  }

  export type EducationGroupByOutputType = {
    EducationId: string
    deliveryMode: string | null
    categoryID: string
    _count: EducationCountAggregateOutputType | null
    _min: EducationMinAggregateOutputType | null
    _max: EducationMaxAggregateOutputType | null
  }

  type GetEducationGroupByPayload<T extends EducationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationGroupByOutputType[P]>
            : GetScalarType<T[P], EducationGroupByOutputType[P]>
        }
      >
    >


  export type EducationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    EducationId?: boolean
    deliveryMode?: boolean
    categoryID?: boolean
    syllabus?: boolean | Education$syllabusArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    _count?: boolean | EducationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["education"]>



  export type EducationSelectScalar = {
    EducationId?: boolean
    deliveryMode?: boolean
    categoryID?: boolean
  }

  export type EducationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"EducationId" | "deliveryMode" | "categoryID", ExtArgs["result"]["education"]>
  export type EducationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabus?: boolean | Education$syllabusArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    _count?: boolean | EducationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EducationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Education"
    objects: {
      syllabus: Prisma.$SyllabusPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      EducationId: string
      deliveryMode: string | null
      categoryID: string
    }, ExtArgs["result"]["education"]>
    composites: {}
  }

  type EducationGetPayload<S extends boolean | null | undefined | EducationDefaultArgs> = $Result.GetResult<Prisma.$EducationPayload, S>

  type EducationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationCountAggregateInputType | true
    }

  export interface EducationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Education'], meta: { name: 'Education' } }
    /**
     * Find zero or one Education that matches the filter.
     * @param {EducationFindUniqueArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationFindUniqueArgs>(args: SelectSubset<T, EducationFindUniqueArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Education that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationFindUniqueOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Education that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationFindFirstArgs>(args?: SelectSubset<T, EducationFindFirstArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Education that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindFirstOrThrowArgs} args - Arguments to find a Education
     * @example
     * // Get one Education
     * const education = await prisma.education.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Educations
     * const educations = await prisma.education.findMany()
     * 
     * // Get first 10 Educations
     * const educations = await prisma.education.findMany({ take: 10 })
     * 
     * // Only select the `EducationId`
     * const educationWithEducationIdOnly = await prisma.education.findMany({ select: { EducationId: true } })
     * 
     */
    findMany<T extends EducationFindManyArgs>(args?: SelectSubset<T, EducationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Education.
     * @param {EducationCreateArgs} args - Arguments to create a Education.
     * @example
     * // Create one Education
     * const Education = await prisma.education.create({
     *   data: {
     *     // ... data to create a Education
     *   }
     * })
     * 
     */
    create<T extends EducationCreateArgs>(args: SelectSubset<T, EducationCreateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Educations.
     * @param {EducationCreateManyArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const education = await prisma.education.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationCreateManyArgs>(args?: SelectSubset<T, EducationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Education.
     * @param {EducationDeleteArgs} args - Arguments to delete one Education.
     * @example
     * // Delete one Education
     * const Education = await prisma.education.delete({
     *   where: {
     *     // ... filter to delete one Education
     *   }
     * })
     * 
     */
    delete<T extends EducationDeleteArgs>(args: SelectSubset<T, EducationDeleteArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Education.
     * @param {EducationUpdateArgs} args - Arguments to update one Education.
     * @example
     * // Update one Education
     * const education = await prisma.education.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationUpdateArgs>(args: SelectSubset<T, EducationUpdateArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Educations.
     * @param {EducationDeleteManyArgs} args - Arguments to filter Educations to delete.
     * @example
     * // Delete a few Educations
     * const { count } = await prisma.education.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationDeleteManyArgs>(args?: SelectSubset<T, EducationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Educations
     * const education = await prisma.education.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationUpdateManyArgs>(args: SelectSubset<T, EducationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Education.
     * @param {EducationUpsertArgs} args - Arguments to update or create a Education.
     * @example
     * // Update or create a Education
     * const education = await prisma.education.upsert({
     *   create: {
     *     // ... data to create a Education
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Education we want to update
     *   }
     * })
     */
    upsert<T extends EducationUpsertArgs>(args: SelectSubset<T, EducationUpsertArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Educations that matches the filter.
     * @param {EducationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const education = await prisma.education.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: EducationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Education.
     * @param {EducationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const education = await prisma.education.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: EducationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationCountArgs} args - Arguments to filter Educations to count.
     * @example
     * // Count the number of Educations
     * const count = await prisma.education.count({
     *   where: {
     *     // ... the filter for the Educations we want to count
     *   }
     * })
    **/
    count<T extends EducationCountArgs>(
      args?: Subset<T, EducationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationAggregateArgs>(args: Subset<T, EducationAggregateArgs>): Prisma.PrismaPromise<GetEducationAggregateType<T>>

    /**
     * Group by Education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationGroupByArgs['orderBy'] }
        : { orderBy?: EducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Education model
   */
  readonly fields: EducationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Education.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    syllabus<T extends Education$syllabusArgs<ExtArgs> = {}>(args?: Subset<T, Education$syllabusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Education model
   */ 
  interface EducationFieldRefs {
    readonly EducationId: FieldRef<"Education", 'String'>
    readonly deliveryMode: FieldRef<"Education", 'String'>
    readonly categoryID: FieldRef<"Education", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Education findUnique
   */
  export type EducationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findUniqueOrThrow
   */
  export type EducationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education findFirst
   */
  export type EducationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findFirstOrThrow
   */
  export type EducationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Education to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Educations.
     */
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education findMany
   */
  export type EducationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter, which Educations to fetch.
     */
    where?: EducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Educations to fetch.
     */
    orderBy?: EducationOrderByWithRelationInput | EducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Educations.
     */
    cursor?: EducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Educations.
     */
    skip?: number
    distinct?: EducationScalarFieldEnum | EducationScalarFieldEnum[]
  }

  /**
   * Education create
   */
  export type EducationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to create a Education.
     */
    data: XOR<EducationCreateInput, EducationUncheckedCreateInput>
  }

  /**
   * Education createMany
   */
  export type EducationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Educations.
     */
    data: EducationCreateManyInput | EducationCreateManyInput[]
  }

  /**
   * Education update
   */
  export type EducationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The data needed to update a Education.
     */
    data: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
    /**
     * Choose, which Education to update.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education updateMany
   */
  export type EducationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Educations.
     */
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyInput>
    /**
     * Filter which Educations to update
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to update.
     */
    limit?: number
  }

  /**
   * Education upsert
   */
  export type EducationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * The filter to search for the Education to update in case it exists.
     */
    where: EducationWhereUniqueInput
    /**
     * In case the Education found by the `where` argument doesn't exist, create a new Education with this data.
     */
    create: XOR<EducationCreateInput, EducationUncheckedCreateInput>
    /**
     * In case the Education was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationUpdateInput, EducationUncheckedUpdateInput>
  }

  /**
   * Education delete
   */
  export type EducationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
    /**
     * Filter which Education to delete.
     */
    where: EducationWhereUniqueInput
  }

  /**
   * Education deleteMany
   */
  export type EducationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Educations to delete
     */
    where?: EducationWhereInput
    /**
     * Limit how many Educations to delete.
     */
    limit?: number
  }

  /**
   * Education findRaw
   */
  export type EducationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Education aggregateRaw
   */
  export type EducationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Education.syllabus
   */
  export type Education$syllabusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    where?: SyllabusWhereInput
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    cursor?: SyllabusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Education without action
   */
  export type EducationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Education
     */
    select?: EducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Education
     */
    omit?: EducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationInclude<ExtArgs> | null
  }


  /**
   * Model Syllabus
   */

  export type AggregateSyllabus = {
    _count: SyllabusCountAggregateOutputType | null
    _min: SyllabusMinAggregateOutputType | null
    _max: SyllabusMaxAggregateOutputType | null
  }

  export type SyllabusMinAggregateOutputType = {
    SyllabusID: string | null
    Title: string | null
    Description: string | null
    educationID: string | null
  }

  export type SyllabusMaxAggregateOutputType = {
    SyllabusID: string | null
    Title: string | null
    Description: string | null
    educationID: string | null
  }

  export type SyllabusCountAggregateOutputType = {
    SyllabusID: number
    Title: number
    Description: number
    educationID: number
    _all: number
  }


  export type SyllabusMinAggregateInputType = {
    SyllabusID?: true
    Title?: true
    Description?: true
    educationID?: true
  }

  export type SyllabusMaxAggregateInputType = {
    SyllabusID?: true
    Title?: true
    Description?: true
    educationID?: true
  }

  export type SyllabusCountAggregateInputType = {
    SyllabusID?: true
    Title?: true
    Description?: true
    educationID?: true
    _all?: true
  }

  export type SyllabusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Syllabus to aggregate.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Syllabi
    **/
    _count?: true | SyllabusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyllabusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyllabusMaxAggregateInputType
  }

  export type GetSyllabusAggregateType<T extends SyllabusAggregateArgs> = {
        [P in keyof T & keyof AggregateSyllabus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyllabus[P]>
      : GetScalarType<T[P], AggregateSyllabus[P]>
  }




  export type SyllabusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusWhereInput
    orderBy?: SyllabusOrderByWithAggregationInput | SyllabusOrderByWithAggregationInput[]
    by: SyllabusScalarFieldEnum[] | SyllabusScalarFieldEnum
    having?: SyllabusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyllabusCountAggregateInputType | true
    _min?: SyllabusMinAggregateInputType
    _max?: SyllabusMaxAggregateInputType
  }

  export type SyllabusGroupByOutputType = {
    SyllabusID: string
    Title: string | null
    Description: string | null
    educationID: string
    _count: SyllabusCountAggregateOutputType | null
    _min: SyllabusMinAggregateOutputType | null
    _max: SyllabusMaxAggregateOutputType | null
  }

  type GetSyllabusGroupByPayload<T extends SyllabusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyllabusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyllabusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyllabusGroupByOutputType[P]>
            : GetScalarType<T[P], SyllabusGroupByOutputType[P]>
        }
      >
    >


  export type SyllabusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SyllabusID?: boolean
    Title?: boolean
    Description?: boolean
    educationID?: boolean
    education?: boolean | EducationDefaultArgs<ExtArgs>
    subjects?: boolean | Syllabus$subjectsArgs<ExtArgs>
    _count?: boolean | SyllabusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabus"]>



  export type SyllabusSelectScalar = {
    SyllabusID?: boolean
    Title?: boolean
    Description?: boolean
    educationID?: boolean
  }

  export type SyllabusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SyllabusID" | "Title" | "Description" | "educationID", ExtArgs["result"]["syllabus"]>
  export type SyllabusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    education?: boolean | EducationDefaultArgs<ExtArgs>
    subjects?: boolean | Syllabus$subjectsArgs<ExtArgs>
    _count?: boolean | SyllabusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SyllabusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Syllabus"
    objects: {
      education: Prisma.$EducationPayload<ExtArgs>
      subjects: Prisma.$SyllabusSubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      SyllabusID: string
      Title: string | null
      Description: string | null
      educationID: string
    }, ExtArgs["result"]["syllabus"]>
    composites: {}
  }

  type SyllabusGetPayload<S extends boolean | null | undefined | SyllabusDefaultArgs> = $Result.GetResult<Prisma.$SyllabusPayload, S>

  type SyllabusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyllabusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyllabusCountAggregateInputType | true
    }

  export interface SyllabusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Syllabus'], meta: { name: 'Syllabus' } }
    /**
     * Find zero or one Syllabus that matches the filter.
     * @param {SyllabusFindUniqueArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyllabusFindUniqueArgs>(args: SelectSubset<T, SyllabusFindUniqueArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Syllabus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyllabusFindUniqueOrThrowArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyllabusFindUniqueOrThrowArgs>(args: SelectSubset<T, SyllabusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Syllabus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusFindFirstArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyllabusFindFirstArgs>(args?: SelectSubset<T, SyllabusFindFirstArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Syllabus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusFindFirstOrThrowArgs} args - Arguments to find a Syllabus
     * @example
     * // Get one Syllabus
     * const syllabus = await prisma.syllabus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyllabusFindFirstOrThrowArgs>(args?: SelectSubset<T, SyllabusFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Syllabi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Syllabi
     * const syllabi = await prisma.syllabus.findMany()
     * 
     * // Get first 10 Syllabi
     * const syllabi = await prisma.syllabus.findMany({ take: 10 })
     * 
     * // Only select the `SyllabusID`
     * const syllabusWithSyllabusIDOnly = await prisma.syllabus.findMany({ select: { SyllabusID: true } })
     * 
     */
    findMany<T extends SyllabusFindManyArgs>(args?: SelectSubset<T, SyllabusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Syllabus.
     * @param {SyllabusCreateArgs} args - Arguments to create a Syllabus.
     * @example
     * // Create one Syllabus
     * const Syllabus = await prisma.syllabus.create({
     *   data: {
     *     // ... data to create a Syllabus
     *   }
     * })
     * 
     */
    create<T extends SyllabusCreateArgs>(args: SelectSubset<T, SyllabusCreateArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Syllabi.
     * @param {SyllabusCreateManyArgs} args - Arguments to create many Syllabi.
     * @example
     * // Create many Syllabi
     * const syllabus = await prisma.syllabus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyllabusCreateManyArgs>(args?: SelectSubset<T, SyllabusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Syllabus.
     * @param {SyllabusDeleteArgs} args - Arguments to delete one Syllabus.
     * @example
     * // Delete one Syllabus
     * const Syllabus = await prisma.syllabus.delete({
     *   where: {
     *     // ... filter to delete one Syllabus
     *   }
     * })
     * 
     */
    delete<T extends SyllabusDeleteArgs>(args: SelectSubset<T, SyllabusDeleteArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Syllabus.
     * @param {SyllabusUpdateArgs} args - Arguments to update one Syllabus.
     * @example
     * // Update one Syllabus
     * const syllabus = await prisma.syllabus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyllabusUpdateArgs>(args: SelectSubset<T, SyllabusUpdateArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Syllabi.
     * @param {SyllabusDeleteManyArgs} args - Arguments to filter Syllabi to delete.
     * @example
     * // Delete a few Syllabi
     * const { count } = await prisma.syllabus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyllabusDeleteManyArgs>(args?: SelectSubset<T, SyllabusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Syllabi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Syllabi
     * const syllabus = await prisma.syllabus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyllabusUpdateManyArgs>(args: SelectSubset<T, SyllabusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Syllabus.
     * @param {SyllabusUpsertArgs} args - Arguments to update or create a Syllabus.
     * @example
     * // Update or create a Syllabus
     * const syllabus = await prisma.syllabus.upsert({
     *   create: {
     *     // ... data to create a Syllabus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Syllabus we want to update
     *   }
     * })
     */
    upsert<T extends SyllabusUpsertArgs>(args: SelectSubset<T, SyllabusUpsertArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Syllabi that matches the filter.
     * @param {SyllabusFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const syllabus = await prisma.syllabus.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SyllabusFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Syllabus.
     * @param {SyllabusAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const syllabus = await prisma.syllabus.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SyllabusAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Syllabi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusCountArgs} args - Arguments to filter Syllabi to count.
     * @example
     * // Count the number of Syllabi
     * const count = await prisma.syllabus.count({
     *   where: {
     *     // ... the filter for the Syllabi we want to count
     *   }
     * })
    **/
    count<T extends SyllabusCountArgs>(
      args?: Subset<T, SyllabusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyllabusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Syllabus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyllabusAggregateArgs>(args: Subset<T, SyllabusAggregateArgs>): Prisma.PrismaPromise<GetSyllabusAggregateType<T>>

    /**
     * Group by Syllabus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyllabusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyllabusGroupByArgs['orderBy'] }
        : { orderBy?: SyllabusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyllabusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyllabusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Syllabus model
   */
  readonly fields: SyllabusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Syllabus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyllabusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    education<T extends EducationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EducationDefaultArgs<ExtArgs>>): Prisma__EducationClient<$Result.GetResult<Prisma.$EducationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subjects<T extends Syllabus$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Syllabus$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Syllabus model
   */ 
  interface SyllabusFieldRefs {
    readonly SyllabusID: FieldRef<"Syllabus", 'String'>
    readonly Title: FieldRef<"Syllabus", 'String'>
    readonly Description: FieldRef<"Syllabus", 'String'>
    readonly educationID: FieldRef<"Syllabus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Syllabus findUnique
   */
  export type SyllabusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus findUniqueOrThrow
   */
  export type SyllabusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus findFirst
   */
  export type SyllabusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Syllabi.
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Syllabi.
     */
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Syllabus findFirstOrThrow
   */
  export type SyllabusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabus to fetch.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Syllabi.
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Syllabi.
     */
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Syllabus findMany
   */
  export type SyllabusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter, which Syllabi to fetch.
     */
    where?: SyllabusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Syllabi to fetch.
     */
    orderBy?: SyllabusOrderByWithRelationInput | SyllabusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Syllabi.
     */
    cursor?: SyllabusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Syllabi from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Syllabi.
     */
    skip?: number
    distinct?: SyllabusScalarFieldEnum | SyllabusScalarFieldEnum[]
  }

  /**
   * Syllabus create
   */
  export type SyllabusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * The data needed to create a Syllabus.
     */
    data: XOR<SyllabusCreateInput, SyllabusUncheckedCreateInput>
  }

  /**
   * Syllabus createMany
   */
  export type SyllabusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Syllabi.
     */
    data: SyllabusCreateManyInput | SyllabusCreateManyInput[]
  }

  /**
   * Syllabus update
   */
  export type SyllabusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * The data needed to update a Syllabus.
     */
    data: XOR<SyllabusUpdateInput, SyllabusUncheckedUpdateInput>
    /**
     * Choose, which Syllabus to update.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus updateMany
   */
  export type SyllabusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Syllabi.
     */
    data: XOR<SyllabusUpdateManyMutationInput, SyllabusUncheckedUpdateManyInput>
    /**
     * Filter which Syllabi to update
     */
    where?: SyllabusWhereInput
    /**
     * Limit how many Syllabi to update.
     */
    limit?: number
  }

  /**
   * Syllabus upsert
   */
  export type SyllabusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * The filter to search for the Syllabus to update in case it exists.
     */
    where: SyllabusWhereUniqueInput
    /**
     * In case the Syllabus found by the `where` argument doesn't exist, create a new Syllabus with this data.
     */
    create: XOR<SyllabusCreateInput, SyllabusUncheckedCreateInput>
    /**
     * In case the Syllabus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyllabusUpdateInput, SyllabusUncheckedUpdateInput>
  }

  /**
   * Syllabus delete
   */
  export type SyllabusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
    /**
     * Filter which Syllabus to delete.
     */
    where: SyllabusWhereUniqueInput
  }

  /**
   * Syllabus deleteMany
   */
  export type SyllabusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Syllabi to delete
     */
    where?: SyllabusWhereInput
    /**
     * Limit how many Syllabi to delete.
     */
    limit?: number
  }

  /**
   * Syllabus findRaw
   */
  export type SyllabusFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Syllabus aggregateRaw
   */
  export type SyllabusAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Syllabus.subjects
   */
  export type Syllabus$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    where?: SyllabusSubjectWhereInput
    orderBy?: SyllabusSubjectOrderByWithRelationInput | SyllabusSubjectOrderByWithRelationInput[]
    cursor?: SyllabusSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyllabusSubjectScalarFieldEnum | SyllabusSubjectScalarFieldEnum[]
  }

  /**
   * Syllabus without action
   */
  export type SyllabusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Syllabus
     */
    select?: SyllabusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Syllabus
     */
    omit?: SyllabusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectMinAggregateOutputType = {
    SubjectID: string | null
    Name: string | null
  }

  export type SubjectMaxAggregateOutputType = {
    SubjectID: string | null
    Name: string | null
  }

  export type SubjectCountAggregateOutputType = {
    SubjectID: number
    Name: number
    _all: number
  }


  export type SubjectMinAggregateInputType = {
    SubjectID?: true
    Name?: true
  }

  export type SubjectMaxAggregateInputType = {
    SubjectID?: true
    Name?: true
  }

  export type SubjectCountAggregateInputType = {
    SubjectID?: true
    Name?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    SubjectID: string
    Name: string
    _count: SubjectCountAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SubjectID?: boolean
    Name?: boolean
    syllabuses?: boolean | Subject$syllabusesArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>



  export type SubjectSelectScalar = {
    SubjectID?: boolean
    Name?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SubjectID" | "Name", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabuses?: boolean | Subject$syllabusesArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      syllabuses: Prisma.$SyllabusSubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      SubjectID: string
      Name: string
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `SubjectID`
     * const subjectWithSubjectIDOnly = await prisma.subject.findMany({ select: { SubjectID: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * @param {SubjectFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const subject = await prisma.subject.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SubjectFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Subject.
     * @param {SubjectAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const subject = await prisma.subject.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SubjectAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    syllabuses<T extends Subject$syllabusesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$syllabusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */ 
  interface SubjectFieldRefs {
    readonly SubjectID: FieldRef<"Subject", 'String'>
    readonly Name: FieldRef<"Subject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject findRaw
   */
  export type SubjectFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Subject aggregateRaw
   */
  export type SubjectAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Subject.syllabuses
   */
  export type Subject$syllabusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    where?: SyllabusSubjectWhereInput
    orderBy?: SyllabusSubjectOrderByWithRelationInput | SyllabusSubjectOrderByWithRelationInput[]
    cursor?: SyllabusSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyllabusSubjectScalarFieldEnum | SyllabusSubjectScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model SyllabusSubject
   */

  export type AggregateSyllabusSubject = {
    _count: SyllabusSubjectCountAggregateOutputType | null
    _min: SyllabusSubjectMinAggregateOutputType | null
    _max: SyllabusSubjectMaxAggregateOutputType | null
  }

  export type SyllabusSubjectMinAggregateOutputType = {
    id: string | null
    syllabusID: string | null
    subjectID: string | null
  }

  export type SyllabusSubjectMaxAggregateOutputType = {
    id: string | null
    syllabusID: string | null
    subjectID: string | null
  }

  export type SyllabusSubjectCountAggregateOutputType = {
    id: number
    syllabusID: number
    subjectID: number
    _all: number
  }


  export type SyllabusSubjectMinAggregateInputType = {
    id?: true
    syllabusID?: true
    subjectID?: true
  }

  export type SyllabusSubjectMaxAggregateInputType = {
    id?: true
    syllabusID?: true
    subjectID?: true
  }

  export type SyllabusSubjectCountAggregateInputType = {
    id?: true
    syllabusID?: true
    subjectID?: true
    _all?: true
  }

  export type SyllabusSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyllabusSubject to aggregate.
     */
    where?: SyllabusSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusSubjects to fetch.
     */
    orderBy?: SyllabusSubjectOrderByWithRelationInput | SyllabusSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyllabusSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyllabusSubjects
    **/
    _count?: true | SyllabusSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyllabusSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyllabusSubjectMaxAggregateInputType
  }

  export type GetSyllabusSubjectAggregateType<T extends SyllabusSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSyllabusSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyllabusSubject[P]>
      : GetScalarType<T[P], AggregateSyllabusSubject[P]>
  }




  export type SyllabusSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyllabusSubjectWhereInput
    orderBy?: SyllabusSubjectOrderByWithAggregationInput | SyllabusSubjectOrderByWithAggregationInput[]
    by: SyllabusSubjectScalarFieldEnum[] | SyllabusSubjectScalarFieldEnum
    having?: SyllabusSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyllabusSubjectCountAggregateInputType | true
    _min?: SyllabusSubjectMinAggregateInputType
    _max?: SyllabusSubjectMaxAggregateInputType
  }

  export type SyllabusSubjectGroupByOutputType = {
    id: string
    syllabusID: string
    subjectID: string
    _count: SyllabusSubjectCountAggregateOutputType | null
    _min: SyllabusSubjectMinAggregateOutputType | null
    _max: SyllabusSubjectMaxAggregateOutputType | null
  }

  type GetSyllabusSubjectGroupByPayload<T extends SyllabusSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyllabusSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyllabusSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyllabusSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SyllabusSubjectGroupByOutputType[P]>
        }
      >
    >


  export type SyllabusSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    syllabusID?: boolean
    subjectID?: boolean
    syllabus?: boolean | SyllabusDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syllabusSubject"]>



  export type SyllabusSubjectSelectScalar = {
    id?: boolean
    syllabusID?: boolean
    subjectID?: boolean
  }

  export type SyllabusSubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "syllabusID" | "subjectID", ExtArgs["result"]["syllabusSubject"]>
  export type SyllabusSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    syllabus?: boolean | SyllabusDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $SyllabusSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyllabusSubject"
    objects: {
      syllabus: Prisma.$SyllabusPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      syllabusID: string
      subjectID: string
    }, ExtArgs["result"]["syllabusSubject"]>
    composites: {}
  }

  type SyllabusSubjectGetPayload<S extends boolean | null | undefined | SyllabusSubjectDefaultArgs> = $Result.GetResult<Prisma.$SyllabusSubjectPayload, S>

  type SyllabusSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyllabusSubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyllabusSubjectCountAggregateInputType | true
    }

  export interface SyllabusSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyllabusSubject'], meta: { name: 'SyllabusSubject' } }
    /**
     * Find zero or one SyllabusSubject that matches the filter.
     * @param {SyllabusSubjectFindUniqueArgs} args - Arguments to find a SyllabusSubject
     * @example
     * // Get one SyllabusSubject
     * const syllabusSubject = await prisma.syllabusSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyllabusSubjectFindUniqueArgs>(args: SelectSubset<T, SyllabusSubjectFindUniqueArgs<ExtArgs>>): Prisma__SyllabusSubjectClient<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyllabusSubject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyllabusSubjectFindUniqueOrThrowArgs} args - Arguments to find a SyllabusSubject
     * @example
     * // Get one SyllabusSubject
     * const syllabusSubject = await prisma.syllabusSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyllabusSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SyllabusSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyllabusSubjectClient<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyllabusSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusSubjectFindFirstArgs} args - Arguments to find a SyllabusSubject
     * @example
     * // Get one SyllabusSubject
     * const syllabusSubject = await prisma.syllabusSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyllabusSubjectFindFirstArgs>(args?: SelectSubset<T, SyllabusSubjectFindFirstArgs<ExtArgs>>): Prisma__SyllabusSubjectClient<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyllabusSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusSubjectFindFirstOrThrowArgs} args - Arguments to find a SyllabusSubject
     * @example
     * // Get one SyllabusSubject
     * const syllabusSubject = await prisma.syllabusSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyllabusSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SyllabusSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyllabusSubjectClient<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyllabusSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyllabusSubjects
     * const syllabusSubjects = await prisma.syllabusSubject.findMany()
     * 
     * // Get first 10 SyllabusSubjects
     * const syllabusSubjects = await prisma.syllabusSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syllabusSubjectWithIdOnly = await prisma.syllabusSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyllabusSubjectFindManyArgs>(args?: SelectSubset<T, SyllabusSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyllabusSubject.
     * @param {SyllabusSubjectCreateArgs} args - Arguments to create a SyllabusSubject.
     * @example
     * // Create one SyllabusSubject
     * const SyllabusSubject = await prisma.syllabusSubject.create({
     *   data: {
     *     // ... data to create a SyllabusSubject
     *   }
     * })
     * 
     */
    create<T extends SyllabusSubjectCreateArgs>(args: SelectSubset<T, SyllabusSubjectCreateArgs<ExtArgs>>): Prisma__SyllabusSubjectClient<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyllabusSubjects.
     * @param {SyllabusSubjectCreateManyArgs} args - Arguments to create many SyllabusSubjects.
     * @example
     * // Create many SyllabusSubjects
     * const syllabusSubject = await prisma.syllabusSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyllabusSubjectCreateManyArgs>(args?: SelectSubset<T, SyllabusSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SyllabusSubject.
     * @param {SyllabusSubjectDeleteArgs} args - Arguments to delete one SyllabusSubject.
     * @example
     * // Delete one SyllabusSubject
     * const SyllabusSubject = await prisma.syllabusSubject.delete({
     *   where: {
     *     // ... filter to delete one SyllabusSubject
     *   }
     * })
     * 
     */
    delete<T extends SyllabusSubjectDeleteArgs>(args: SelectSubset<T, SyllabusSubjectDeleteArgs<ExtArgs>>): Prisma__SyllabusSubjectClient<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyllabusSubject.
     * @param {SyllabusSubjectUpdateArgs} args - Arguments to update one SyllabusSubject.
     * @example
     * // Update one SyllabusSubject
     * const syllabusSubject = await prisma.syllabusSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyllabusSubjectUpdateArgs>(args: SelectSubset<T, SyllabusSubjectUpdateArgs<ExtArgs>>): Prisma__SyllabusSubjectClient<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyllabusSubjects.
     * @param {SyllabusSubjectDeleteManyArgs} args - Arguments to filter SyllabusSubjects to delete.
     * @example
     * // Delete a few SyllabusSubjects
     * const { count } = await prisma.syllabusSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyllabusSubjectDeleteManyArgs>(args?: SelectSubset<T, SyllabusSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyllabusSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyllabusSubjects
     * const syllabusSubject = await prisma.syllabusSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyllabusSubjectUpdateManyArgs>(args: SelectSubset<T, SyllabusSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SyllabusSubject.
     * @param {SyllabusSubjectUpsertArgs} args - Arguments to update or create a SyllabusSubject.
     * @example
     * // Update or create a SyllabusSubject
     * const syllabusSubject = await prisma.syllabusSubject.upsert({
     *   create: {
     *     // ... data to create a SyllabusSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyllabusSubject we want to update
     *   }
     * })
     */
    upsert<T extends SyllabusSubjectUpsertArgs>(args: SelectSubset<T, SyllabusSubjectUpsertArgs<ExtArgs>>): Prisma__SyllabusSubjectClient<$Result.GetResult<Prisma.$SyllabusSubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyllabusSubjects that matches the filter.
     * @param {SyllabusSubjectFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const syllabusSubject = await prisma.syllabusSubject.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SyllabusSubjectFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SyllabusSubject.
     * @param {SyllabusSubjectAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const syllabusSubject = await prisma.syllabusSubject.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SyllabusSubjectAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SyllabusSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusSubjectCountArgs} args - Arguments to filter SyllabusSubjects to count.
     * @example
     * // Count the number of SyllabusSubjects
     * const count = await prisma.syllabusSubject.count({
     *   where: {
     *     // ... the filter for the SyllabusSubjects we want to count
     *   }
     * })
    **/
    count<T extends SyllabusSubjectCountArgs>(
      args?: Subset<T, SyllabusSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyllabusSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyllabusSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyllabusSubjectAggregateArgs>(args: Subset<T, SyllabusSubjectAggregateArgs>): Prisma.PrismaPromise<GetSyllabusSubjectAggregateType<T>>

    /**
     * Group by SyllabusSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyllabusSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyllabusSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyllabusSubjectGroupByArgs['orderBy'] }
        : { orderBy?: SyllabusSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyllabusSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyllabusSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyllabusSubject model
   */
  readonly fields: SyllabusSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyllabusSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyllabusSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    syllabus<T extends SyllabusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SyllabusDefaultArgs<ExtArgs>>): Prisma__SyllabusClient<$Result.GetResult<Prisma.$SyllabusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyllabusSubject model
   */ 
  interface SyllabusSubjectFieldRefs {
    readonly id: FieldRef<"SyllabusSubject", 'String'>
    readonly syllabusID: FieldRef<"SyllabusSubject", 'String'>
    readonly subjectID: FieldRef<"SyllabusSubject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyllabusSubject findUnique
   */
  export type SyllabusSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusSubject to fetch.
     */
    where: SyllabusSubjectWhereUniqueInput
  }

  /**
   * SyllabusSubject findUniqueOrThrow
   */
  export type SyllabusSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusSubject to fetch.
     */
    where: SyllabusSubjectWhereUniqueInput
  }

  /**
   * SyllabusSubject findFirst
   */
  export type SyllabusSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusSubject to fetch.
     */
    where?: SyllabusSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusSubjects to fetch.
     */
    orderBy?: SyllabusSubjectOrderByWithRelationInput | SyllabusSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyllabusSubjects.
     */
    cursor?: SyllabusSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyllabusSubjects.
     */
    distinct?: SyllabusSubjectScalarFieldEnum | SyllabusSubjectScalarFieldEnum[]
  }

  /**
   * SyllabusSubject findFirstOrThrow
   */
  export type SyllabusSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusSubject to fetch.
     */
    where?: SyllabusSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusSubjects to fetch.
     */
    orderBy?: SyllabusSubjectOrderByWithRelationInput | SyllabusSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyllabusSubjects.
     */
    cursor?: SyllabusSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyllabusSubjects.
     */
    distinct?: SyllabusSubjectScalarFieldEnum | SyllabusSubjectScalarFieldEnum[]
  }

  /**
   * SyllabusSubject findMany
   */
  export type SyllabusSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    /**
     * Filter, which SyllabusSubjects to fetch.
     */
    where?: SyllabusSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyllabusSubjects to fetch.
     */
    orderBy?: SyllabusSubjectOrderByWithRelationInput | SyllabusSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyllabusSubjects.
     */
    cursor?: SyllabusSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyllabusSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyllabusSubjects.
     */
    skip?: number
    distinct?: SyllabusSubjectScalarFieldEnum | SyllabusSubjectScalarFieldEnum[]
  }

  /**
   * SyllabusSubject create
   */
  export type SyllabusSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a SyllabusSubject.
     */
    data: XOR<SyllabusSubjectCreateInput, SyllabusSubjectUncheckedCreateInput>
  }

  /**
   * SyllabusSubject createMany
   */
  export type SyllabusSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyllabusSubjects.
     */
    data: SyllabusSubjectCreateManyInput | SyllabusSubjectCreateManyInput[]
  }

  /**
   * SyllabusSubject update
   */
  export type SyllabusSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a SyllabusSubject.
     */
    data: XOR<SyllabusSubjectUpdateInput, SyllabusSubjectUncheckedUpdateInput>
    /**
     * Choose, which SyllabusSubject to update.
     */
    where: SyllabusSubjectWhereUniqueInput
  }

  /**
   * SyllabusSubject updateMany
   */
  export type SyllabusSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyllabusSubjects.
     */
    data: XOR<SyllabusSubjectUpdateManyMutationInput, SyllabusSubjectUncheckedUpdateManyInput>
    /**
     * Filter which SyllabusSubjects to update
     */
    where?: SyllabusSubjectWhereInput
    /**
     * Limit how many SyllabusSubjects to update.
     */
    limit?: number
  }

  /**
   * SyllabusSubject upsert
   */
  export type SyllabusSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the SyllabusSubject to update in case it exists.
     */
    where: SyllabusSubjectWhereUniqueInput
    /**
     * In case the SyllabusSubject found by the `where` argument doesn't exist, create a new SyllabusSubject with this data.
     */
    create: XOR<SyllabusSubjectCreateInput, SyllabusSubjectUncheckedCreateInput>
    /**
     * In case the SyllabusSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyllabusSubjectUpdateInput, SyllabusSubjectUncheckedUpdateInput>
  }

  /**
   * SyllabusSubject delete
   */
  export type SyllabusSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
    /**
     * Filter which SyllabusSubject to delete.
     */
    where: SyllabusSubjectWhereUniqueInput
  }

  /**
   * SyllabusSubject deleteMany
   */
  export type SyllabusSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyllabusSubjects to delete
     */
    where?: SyllabusSubjectWhereInput
    /**
     * Limit how many SyllabusSubjects to delete.
     */
    limit?: number
  }

  /**
   * SyllabusSubject findRaw
   */
  export type SyllabusSubjectFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SyllabusSubject aggregateRaw
   */
  export type SyllabusSubjectAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SyllabusSubject without action
   */
  export type SyllabusSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyllabusSubject
     */
    select?: SyllabusSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyllabusSubject
     */
    omit?: SyllabusSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyllabusSubjectInclude<ExtArgs> | null
  }


  /**
   * Model Complain
   */

  export type AggregateComplain = {
    _count: ComplainCountAggregateOutputType | null
    _min: ComplainMinAggregateOutputType | null
    _max: ComplainMaxAggregateOutputType | null
  }

  export type ComplainMinAggregateOutputType = {
    complainId: string | null
    Reason: string | null
    Status: $Enums.complianStatus | null
    CustomerId: string | null
  }

  export type ComplainMaxAggregateOutputType = {
    complainId: string | null
    Reason: string | null
    Status: $Enums.complianStatus | null
    CustomerId: string | null
  }

  export type ComplainCountAggregateOutputType = {
    complainId: number
    Reason: number
    Status: number
    CustomerId: number
    _all: number
  }


  export type ComplainMinAggregateInputType = {
    complainId?: true
    Reason?: true
    Status?: true
    CustomerId?: true
  }

  export type ComplainMaxAggregateInputType = {
    complainId?: true
    Reason?: true
    Status?: true
    CustomerId?: true
  }

  export type ComplainCountAggregateInputType = {
    complainId?: true
    Reason?: true
    Status?: true
    CustomerId?: true
    _all?: true
  }

  export type ComplainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complain to aggregate.
     */
    where?: ComplainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complains to fetch.
     */
    orderBy?: ComplainOrderByWithRelationInput | ComplainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Complains
    **/
    _count?: true | ComplainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplainMaxAggregateInputType
  }

  export type GetComplainAggregateType<T extends ComplainAggregateArgs> = {
        [P in keyof T & keyof AggregateComplain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplain[P]>
      : GetScalarType<T[P], AggregateComplain[P]>
  }




  export type ComplainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplainWhereInput
    orderBy?: ComplainOrderByWithAggregationInput | ComplainOrderByWithAggregationInput[]
    by: ComplainScalarFieldEnum[] | ComplainScalarFieldEnum
    having?: ComplainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplainCountAggregateInputType | true
    _min?: ComplainMinAggregateInputType
    _max?: ComplainMaxAggregateInputType
  }

  export type ComplainGroupByOutputType = {
    complainId: string
    Reason: string | null
    Status: $Enums.complianStatus
    CustomerId: string
    _count: ComplainCountAggregateOutputType | null
    _min: ComplainMinAggregateOutputType | null
    _max: ComplainMaxAggregateOutputType | null
  }

  type GetComplainGroupByPayload<T extends ComplainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplainGroupByOutputType[P]>
            : GetScalarType<T[P], ComplainGroupByOutputType[P]>
        }
      >
    >


  export type ComplainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    complainId?: boolean
    Reason?: boolean
    Status?: boolean
    CustomerId?: boolean
    Customers?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complain"]>



  export type ComplainSelectScalar = {
    complainId?: boolean
    Reason?: boolean
    Status?: boolean
    CustomerId?: boolean
  }

  export type ComplainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"complainId" | "Reason" | "Status" | "CustomerId", ExtArgs["result"]["complain"]>
  export type ComplainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $ComplainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Complain"
    objects: {
      Customers: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      complainId: string
      Reason: string | null
      Status: $Enums.complianStatus
      CustomerId: string
    }, ExtArgs["result"]["complain"]>
    composites: {}
  }

  type ComplainGetPayload<S extends boolean | null | undefined | ComplainDefaultArgs> = $Result.GetResult<Prisma.$ComplainPayload, S>

  type ComplainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplainCountAggregateInputType | true
    }

  export interface ComplainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Complain'], meta: { name: 'Complain' } }
    /**
     * Find zero or one Complain that matches the filter.
     * @param {ComplainFindUniqueArgs} args - Arguments to find a Complain
     * @example
     * // Get one Complain
     * const complain = await prisma.complain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplainFindUniqueArgs>(args: SelectSubset<T, ComplainFindUniqueArgs<ExtArgs>>): Prisma__ComplainClient<$Result.GetResult<Prisma.$ComplainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplainFindUniqueOrThrowArgs} args - Arguments to find a Complain
     * @example
     * // Get one Complain
     * const complain = await prisma.complain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplainFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplainClient<$Result.GetResult<Prisma.$ComplainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplainFindFirstArgs} args - Arguments to find a Complain
     * @example
     * // Get one Complain
     * const complain = await prisma.complain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplainFindFirstArgs>(args?: SelectSubset<T, ComplainFindFirstArgs<ExtArgs>>): Prisma__ComplainClient<$Result.GetResult<Prisma.$ComplainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplainFindFirstOrThrowArgs} args - Arguments to find a Complain
     * @example
     * // Get one Complain
     * const complain = await prisma.complain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplainFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplainFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplainClient<$Result.GetResult<Prisma.$ComplainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complains
     * const complains = await prisma.complain.findMany()
     * 
     * // Get first 10 Complains
     * const complains = await prisma.complain.findMany({ take: 10 })
     * 
     * // Only select the `complainId`
     * const complainWithComplainIdOnly = await prisma.complain.findMany({ select: { complainId: true } })
     * 
     */
    findMany<T extends ComplainFindManyArgs>(args?: SelectSubset<T, ComplainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complain.
     * @param {ComplainCreateArgs} args - Arguments to create a Complain.
     * @example
     * // Create one Complain
     * const Complain = await prisma.complain.create({
     *   data: {
     *     // ... data to create a Complain
     *   }
     * })
     * 
     */
    create<T extends ComplainCreateArgs>(args: SelectSubset<T, ComplainCreateArgs<ExtArgs>>): Prisma__ComplainClient<$Result.GetResult<Prisma.$ComplainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complains.
     * @param {ComplainCreateManyArgs} args - Arguments to create many Complains.
     * @example
     * // Create many Complains
     * const complain = await prisma.complain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplainCreateManyArgs>(args?: SelectSubset<T, ComplainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Complain.
     * @param {ComplainDeleteArgs} args - Arguments to delete one Complain.
     * @example
     * // Delete one Complain
     * const Complain = await prisma.complain.delete({
     *   where: {
     *     // ... filter to delete one Complain
     *   }
     * })
     * 
     */
    delete<T extends ComplainDeleteArgs>(args: SelectSubset<T, ComplainDeleteArgs<ExtArgs>>): Prisma__ComplainClient<$Result.GetResult<Prisma.$ComplainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complain.
     * @param {ComplainUpdateArgs} args - Arguments to update one Complain.
     * @example
     * // Update one Complain
     * const complain = await prisma.complain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplainUpdateArgs>(args: SelectSubset<T, ComplainUpdateArgs<ExtArgs>>): Prisma__ComplainClient<$Result.GetResult<Prisma.$ComplainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complains.
     * @param {ComplainDeleteManyArgs} args - Arguments to filter Complains to delete.
     * @example
     * // Delete a few Complains
     * const { count } = await prisma.complain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplainDeleteManyArgs>(args?: SelectSubset<T, ComplainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complains
     * const complain = await prisma.complain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplainUpdateManyArgs>(args: SelectSubset<T, ComplainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complain.
     * @param {ComplainUpsertArgs} args - Arguments to update or create a Complain.
     * @example
     * // Update or create a Complain
     * const complain = await prisma.complain.upsert({
     *   create: {
     *     // ... data to create a Complain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complain we want to update
     *   }
     * })
     */
    upsert<T extends ComplainUpsertArgs>(args: SelectSubset<T, ComplainUpsertArgs<ExtArgs>>): Prisma__ComplainClient<$Result.GetResult<Prisma.$ComplainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complains that matches the filter.
     * @param {ComplainFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const complain = await prisma.complain.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ComplainFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Complain.
     * @param {ComplainAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const complain = await prisma.complain.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ComplainAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Complains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplainCountArgs} args - Arguments to filter Complains to count.
     * @example
     * // Count the number of Complains
     * const count = await prisma.complain.count({
     *   where: {
     *     // ... the filter for the Complains we want to count
     *   }
     * })
    **/
    count<T extends ComplainCountArgs>(
      args?: Subset<T, ComplainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplainAggregateArgs>(args: Subset<T, ComplainAggregateArgs>): Prisma.PrismaPromise<GetComplainAggregateType<T>>

    /**
     * Group by Complain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplainGroupByArgs['orderBy'] }
        : { orderBy?: ComplainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Complain model
   */
  readonly fields: ComplainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Customers<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Complain model
   */ 
  interface ComplainFieldRefs {
    readonly complainId: FieldRef<"Complain", 'String'>
    readonly Reason: FieldRef<"Complain", 'String'>
    readonly Status: FieldRef<"Complain", 'complianStatus'>
    readonly CustomerId: FieldRef<"Complain", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Complain findUnique
   */
  export type ComplainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
    /**
     * Filter, which Complain to fetch.
     */
    where: ComplainWhereUniqueInput
  }

  /**
   * Complain findUniqueOrThrow
   */
  export type ComplainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
    /**
     * Filter, which Complain to fetch.
     */
    where: ComplainWhereUniqueInput
  }

  /**
   * Complain findFirst
   */
  export type ComplainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
    /**
     * Filter, which Complain to fetch.
     */
    where?: ComplainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complains to fetch.
     */
    orderBy?: ComplainOrderByWithRelationInput | ComplainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complains.
     */
    cursor?: ComplainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complains.
     */
    distinct?: ComplainScalarFieldEnum | ComplainScalarFieldEnum[]
  }

  /**
   * Complain findFirstOrThrow
   */
  export type ComplainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
    /**
     * Filter, which Complain to fetch.
     */
    where?: ComplainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complains to fetch.
     */
    orderBy?: ComplainOrderByWithRelationInput | ComplainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complains.
     */
    cursor?: ComplainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complains.
     */
    distinct?: ComplainScalarFieldEnum | ComplainScalarFieldEnum[]
  }

  /**
   * Complain findMany
   */
  export type ComplainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
    /**
     * Filter, which Complains to fetch.
     */
    where?: ComplainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complains to fetch.
     */
    orderBy?: ComplainOrderByWithRelationInput | ComplainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Complains.
     */
    cursor?: ComplainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complains.
     */
    skip?: number
    distinct?: ComplainScalarFieldEnum | ComplainScalarFieldEnum[]
  }

  /**
   * Complain create
   */
  export type ComplainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
    /**
     * The data needed to create a Complain.
     */
    data: XOR<ComplainCreateInput, ComplainUncheckedCreateInput>
  }

  /**
   * Complain createMany
   */
  export type ComplainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Complains.
     */
    data: ComplainCreateManyInput | ComplainCreateManyInput[]
  }

  /**
   * Complain update
   */
  export type ComplainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
    /**
     * The data needed to update a Complain.
     */
    data: XOR<ComplainUpdateInput, ComplainUncheckedUpdateInput>
    /**
     * Choose, which Complain to update.
     */
    where: ComplainWhereUniqueInput
  }

  /**
   * Complain updateMany
   */
  export type ComplainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Complains.
     */
    data: XOR<ComplainUpdateManyMutationInput, ComplainUncheckedUpdateManyInput>
    /**
     * Filter which Complains to update
     */
    where?: ComplainWhereInput
    /**
     * Limit how many Complains to update.
     */
    limit?: number
  }

  /**
   * Complain upsert
   */
  export type ComplainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
    /**
     * The filter to search for the Complain to update in case it exists.
     */
    where: ComplainWhereUniqueInput
    /**
     * In case the Complain found by the `where` argument doesn't exist, create a new Complain with this data.
     */
    create: XOR<ComplainCreateInput, ComplainUncheckedCreateInput>
    /**
     * In case the Complain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplainUpdateInput, ComplainUncheckedUpdateInput>
  }

  /**
   * Complain delete
   */
  export type ComplainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
    /**
     * Filter which Complain to delete.
     */
    where: ComplainWhereUniqueInput
  }

  /**
   * Complain deleteMany
   */
  export type ComplainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complains to delete
     */
    where?: ComplainWhereInput
    /**
     * Limit how many Complains to delete.
     */
    limit?: number
  }

  /**
   * Complain findRaw
   */
  export type ComplainFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Complain aggregateRaw
   */
  export type ComplainAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Complain without action
   */
  export type ComplainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complain
     */
    select?: ComplainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complain
     */
    omit?: ComplainOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplainInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    CommisionRate: number | null
  }

  export type ServiceSumAggregateOutputType = {
    CommisionRate: number | null
  }

  export type ServiceMinAggregateOutputType = {
    ServiceID: string | null
    ServiceName: string | null
    Category: string | null
    CommisionRate: number | null
    Description: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    ServiceID: string | null
    ServiceName: string | null
    Category: string | null
    CommisionRate: number | null
    Description: string | null
  }

  export type ServiceCountAggregateOutputType = {
    ServiceID: number
    ServiceName: number
    Category: number
    CommisionRate: number
    Description: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    CommisionRate?: true
  }

  export type ServiceSumAggregateInputType = {
    CommisionRate?: true
  }

  export type ServiceMinAggregateInputType = {
    ServiceID?: true
    ServiceName?: true
    Category?: true
    CommisionRate?: true
    Description?: true
  }

  export type ServiceMaxAggregateInputType = {
    ServiceID?: true
    ServiceName?: true
    Category?: true
    CommisionRate?: true
    Description?: true
  }

  export type ServiceCountAggregateInputType = {
    ServiceID?: true
    ServiceName?: true
    Category?: true
    CommisionRate?: true
    Description?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    ServiceID: string
    ServiceName: string
    Category: string
    CommisionRate: number
    Description: string
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ServiceID?: boolean
    ServiceName?: boolean
    Category?: boolean
    CommisionRate?: boolean
    Description?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    serviceProvider?: boolean | Service$serviceProviderArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>



  export type ServiceSelectScalar = {
    ServiceID?: boolean
    ServiceName?: boolean
    Category?: boolean
    CommisionRate?: boolean
    Description?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ServiceID" | "ServiceName" | "Category" | "CommisionRate" | "Description", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    serviceProvider?: boolean | Service$serviceProviderArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ServiceID: string
      ServiceName: string
      Category: string
      CommisionRate: number
      Description: string
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `ServiceID`
     * const serviceWithServiceIDOnly = await prisma.service.findMany({ select: { ServiceID: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * @param {ServiceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const service = await prisma.service.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ServiceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Service.
     * @param {ServiceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const service = await prisma.service.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceProvider<T extends Service$serviceProviderArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceProviderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly ServiceID: FieldRef<"Service", 'String'>
    readonly ServiceName: FieldRef<"Service", 'String'>
    readonly Category: FieldRef<"Service", 'String'>
    readonly CommisionRate: FieldRef<"Service", 'Int'>
    readonly Description: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service findRaw
   */
  export type ServiceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Service aggregateRaw
   */
  export type ServiceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Service.serviceProvider
   */
  export type Service$serviceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    where?: ServiceProviderWhereInput
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    cursor?: ServiceProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Administrator
   */

  export type AggregateAdministrator = {
    _count: AdministratorCountAggregateOutputType | null
    _min: AdministratorMinAggregateOutputType | null
    _max: AdministratorMaxAggregateOutputType | null
  }

  export type AdministratorMinAggregateOutputType = {
    AdminID: string | null
    Name: string | null
    Email: string | null
    Password: string | null
    MobileNumber: string | null
  }

  export type AdministratorMaxAggregateOutputType = {
    AdminID: string | null
    Name: string | null
    Email: string | null
    Password: string | null
    MobileNumber: string | null
  }

  export type AdministratorCountAggregateOutputType = {
    AdminID: number
    Name: number
    Email: number
    Password: number
    MobileNumber: number
    _all: number
  }


  export type AdministratorMinAggregateInputType = {
    AdminID?: true
    Name?: true
    Email?: true
    Password?: true
    MobileNumber?: true
  }

  export type AdministratorMaxAggregateInputType = {
    AdminID?: true
    Name?: true
    Email?: true
    Password?: true
    MobileNumber?: true
  }

  export type AdministratorCountAggregateInputType = {
    AdminID?: true
    Name?: true
    Email?: true
    Password?: true
    MobileNumber?: true
    _all?: true
  }

  export type AdministratorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Administrator to aggregate.
     */
    where?: AdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administrators to fetch.
     */
    orderBy?: AdministratorOrderByWithRelationInput | AdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Administrators
    **/
    _count?: true | AdministratorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministratorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministratorMaxAggregateInputType
  }

  export type GetAdministratorAggregateType<T extends AdministratorAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministrator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministrator[P]>
      : GetScalarType<T[P], AggregateAdministrator[P]>
  }




  export type AdministratorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdministratorWhereInput
    orderBy?: AdministratorOrderByWithAggregationInput | AdministratorOrderByWithAggregationInput[]
    by: AdministratorScalarFieldEnum[] | AdministratorScalarFieldEnum
    having?: AdministratorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministratorCountAggregateInputType | true
    _min?: AdministratorMinAggregateInputType
    _max?: AdministratorMaxAggregateInputType
  }

  export type AdministratorGroupByOutputType = {
    AdminID: string
    Name: string | null
    Email: string | null
    Password: string | null
    MobileNumber: string | null
    _count: AdministratorCountAggregateOutputType | null
    _min: AdministratorMinAggregateOutputType | null
    _max: AdministratorMaxAggregateOutputType | null
  }

  type GetAdministratorGroupByPayload<T extends AdministratorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdministratorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdministratorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdministratorGroupByOutputType[P]>
            : GetScalarType<T[P], AdministratorGroupByOutputType[P]>
        }
      >
    >


  export type AdministratorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AdminID?: boolean
    Name?: boolean
    Email?: boolean
    Password?: boolean
    MobileNumber?: boolean
  }, ExtArgs["result"]["administrator"]>



  export type AdministratorSelectScalar = {
    AdminID?: boolean
    Name?: boolean
    Email?: boolean
    Password?: boolean
    MobileNumber?: boolean
  }

  export type AdministratorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"AdminID" | "Name" | "Email" | "Password" | "MobileNumber", ExtArgs["result"]["administrator"]>

  export type $AdministratorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Administrator"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      AdminID: string
      Name: string | null
      Email: string | null
      Password: string | null
      MobileNumber: string | null
    }, ExtArgs["result"]["administrator"]>
    composites: {}
  }

  type AdministratorGetPayload<S extends boolean | null | undefined | AdministratorDefaultArgs> = $Result.GetResult<Prisma.$AdministratorPayload, S>

  type AdministratorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdministratorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdministratorCountAggregateInputType | true
    }

  export interface AdministratorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Administrator'], meta: { name: 'Administrator' } }
    /**
     * Find zero or one Administrator that matches the filter.
     * @param {AdministratorFindUniqueArgs} args - Arguments to find a Administrator
     * @example
     * // Get one Administrator
     * const administrator = await prisma.administrator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdministratorFindUniqueArgs>(args: SelectSubset<T, AdministratorFindUniqueArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Administrator that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdministratorFindUniqueOrThrowArgs} args - Arguments to find a Administrator
     * @example
     * // Get one Administrator
     * const administrator = await prisma.administrator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdministratorFindUniqueOrThrowArgs>(args: SelectSubset<T, AdministratorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Administrator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorFindFirstArgs} args - Arguments to find a Administrator
     * @example
     * // Get one Administrator
     * const administrator = await prisma.administrator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdministratorFindFirstArgs>(args?: SelectSubset<T, AdministratorFindFirstArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Administrator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorFindFirstOrThrowArgs} args - Arguments to find a Administrator
     * @example
     * // Get one Administrator
     * const administrator = await prisma.administrator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdministratorFindFirstOrThrowArgs>(args?: SelectSubset<T, AdministratorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Administrators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Administrators
     * const administrators = await prisma.administrator.findMany()
     * 
     * // Get first 10 Administrators
     * const administrators = await prisma.administrator.findMany({ take: 10 })
     * 
     * // Only select the `AdminID`
     * const administratorWithAdminIDOnly = await prisma.administrator.findMany({ select: { AdminID: true } })
     * 
     */
    findMany<T extends AdministratorFindManyArgs>(args?: SelectSubset<T, AdministratorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Administrator.
     * @param {AdministratorCreateArgs} args - Arguments to create a Administrator.
     * @example
     * // Create one Administrator
     * const Administrator = await prisma.administrator.create({
     *   data: {
     *     // ... data to create a Administrator
     *   }
     * })
     * 
     */
    create<T extends AdministratorCreateArgs>(args: SelectSubset<T, AdministratorCreateArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Administrators.
     * @param {AdministratorCreateManyArgs} args - Arguments to create many Administrators.
     * @example
     * // Create many Administrators
     * const administrator = await prisma.administrator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdministratorCreateManyArgs>(args?: SelectSubset<T, AdministratorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Administrator.
     * @param {AdministratorDeleteArgs} args - Arguments to delete one Administrator.
     * @example
     * // Delete one Administrator
     * const Administrator = await prisma.administrator.delete({
     *   where: {
     *     // ... filter to delete one Administrator
     *   }
     * })
     * 
     */
    delete<T extends AdministratorDeleteArgs>(args: SelectSubset<T, AdministratorDeleteArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Administrator.
     * @param {AdministratorUpdateArgs} args - Arguments to update one Administrator.
     * @example
     * // Update one Administrator
     * const administrator = await prisma.administrator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdministratorUpdateArgs>(args: SelectSubset<T, AdministratorUpdateArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Administrators.
     * @param {AdministratorDeleteManyArgs} args - Arguments to filter Administrators to delete.
     * @example
     * // Delete a few Administrators
     * const { count } = await prisma.administrator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdministratorDeleteManyArgs>(args?: SelectSubset<T, AdministratorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Administrators
     * const administrator = await prisma.administrator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdministratorUpdateManyArgs>(args: SelectSubset<T, AdministratorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Administrator.
     * @param {AdministratorUpsertArgs} args - Arguments to update or create a Administrator.
     * @example
     * // Update or create a Administrator
     * const administrator = await prisma.administrator.upsert({
     *   create: {
     *     // ... data to create a Administrator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Administrator we want to update
     *   }
     * })
     */
    upsert<T extends AdministratorUpsertArgs>(args: SelectSubset<T, AdministratorUpsertArgs<ExtArgs>>): Prisma__AdministratorClient<$Result.GetResult<Prisma.$AdministratorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Administrators that matches the filter.
     * @param {AdministratorFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const administrator = await prisma.administrator.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AdministratorFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Administrator.
     * @param {AdministratorAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const administrator = await prisma.administrator.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AdministratorAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Administrators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorCountArgs} args - Arguments to filter Administrators to count.
     * @example
     * // Count the number of Administrators
     * const count = await prisma.administrator.count({
     *   where: {
     *     // ... the filter for the Administrators we want to count
     *   }
     * })
    **/
    count<T extends AdministratorCountArgs>(
      args?: Subset<T, AdministratorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministratorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Administrator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministratorAggregateArgs>(args: Subset<T, AdministratorAggregateArgs>): Prisma.PrismaPromise<GetAdministratorAggregateType<T>>

    /**
     * Group by Administrator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministratorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdministratorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdministratorGroupByArgs['orderBy'] }
        : { orderBy?: AdministratorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdministratorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministratorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Administrator model
   */
  readonly fields: AdministratorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Administrator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdministratorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Administrator model
   */ 
  interface AdministratorFieldRefs {
    readonly AdminID: FieldRef<"Administrator", 'String'>
    readonly Name: FieldRef<"Administrator", 'String'>
    readonly Email: FieldRef<"Administrator", 'String'>
    readonly Password: FieldRef<"Administrator", 'String'>
    readonly MobileNumber: FieldRef<"Administrator", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Administrator findUnique
   */
  export type AdministratorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Filter, which Administrator to fetch.
     */
    where: AdministratorWhereUniqueInput
  }

  /**
   * Administrator findUniqueOrThrow
   */
  export type AdministratorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Filter, which Administrator to fetch.
     */
    where: AdministratorWhereUniqueInput
  }

  /**
   * Administrator findFirst
   */
  export type AdministratorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Filter, which Administrator to fetch.
     */
    where?: AdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administrators to fetch.
     */
    orderBy?: AdministratorOrderByWithRelationInput | AdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Administrators.
     */
    cursor?: AdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Administrators.
     */
    distinct?: AdministratorScalarFieldEnum | AdministratorScalarFieldEnum[]
  }

  /**
   * Administrator findFirstOrThrow
   */
  export type AdministratorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Filter, which Administrator to fetch.
     */
    where?: AdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administrators to fetch.
     */
    orderBy?: AdministratorOrderByWithRelationInput | AdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Administrators.
     */
    cursor?: AdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administrators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Administrators.
     */
    distinct?: AdministratorScalarFieldEnum | AdministratorScalarFieldEnum[]
  }

  /**
   * Administrator findMany
   */
  export type AdministratorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Filter, which Administrators to fetch.
     */
    where?: AdministratorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Administrators to fetch.
     */
    orderBy?: AdministratorOrderByWithRelationInput | AdministratorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Administrators.
     */
    cursor?: AdministratorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Administrators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Administrators.
     */
    skip?: number
    distinct?: AdministratorScalarFieldEnum | AdministratorScalarFieldEnum[]
  }

  /**
   * Administrator create
   */
  export type AdministratorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * The data needed to create a Administrator.
     */
    data?: XOR<AdministratorCreateInput, AdministratorUncheckedCreateInput>
  }

  /**
   * Administrator createMany
   */
  export type AdministratorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Administrators.
     */
    data: AdministratorCreateManyInput | AdministratorCreateManyInput[]
  }

  /**
   * Administrator update
   */
  export type AdministratorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * The data needed to update a Administrator.
     */
    data: XOR<AdministratorUpdateInput, AdministratorUncheckedUpdateInput>
    /**
     * Choose, which Administrator to update.
     */
    where: AdministratorWhereUniqueInput
  }

  /**
   * Administrator updateMany
   */
  export type AdministratorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Administrators.
     */
    data: XOR<AdministratorUpdateManyMutationInput, AdministratorUncheckedUpdateManyInput>
    /**
     * Filter which Administrators to update
     */
    where?: AdministratorWhereInput
    /**
     * Limit how many Administrators to update.
     */
    limit?: number
  }

  /**
   * Administrator upsert
   */
  export type AdministratorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * The filter to search for the Administrator to update in case it exists.
     */
    where: AdministratorWhereUniqueInput
    /**
     * In case the Administrator found by the `where` argument doesn't exist, create a new Administrator with this data.
     */
    create: XOR<AdministratorCreateInput, AdministratorUncheckedCreateInput>
    /**
     * In case the Administrator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdministratorUpdateInput, AdministratorUncheckedUpdateInput>
  }

  /**
   * Administrator delete
   */
  export type AdministratorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
    /**
     * Filter which Administrator to delete.
     */
    where: AdministratorWhereUniqueInput
  }

  /**
   * Administrator deleteMany
   */
  export type AdministratorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Administrators to delete
     */
    where?: AdministratorWhereInput
    /**
     * Limit how many Administrators to delete.
     */
    limit?: number
  }

  /**
   * Administrator findRaw
   */
  export type AdministratorFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Administrator aggregateRaw
   */
  export type AdministratorAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Administrator without action
   */
  export type AdministratorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Administrator
     */
    select?: AdministratorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Administrator
     */
    omit?: AdministratorOmit<ExtArgs> | null
  }


  /**
   * Model ServiceProvider
   */

  export type AggregateServiceProvider = {
    _count: ServiceProviderCountAggregateOutputType | null
    _min: ServiceProviderMinAggregateOutputType | null
    _max: ServiceProviderMaxAggregateOutputType | null
  }

  export type ServiceProviderMinAggregateOutputType = {
    ProviderID: string | null
    FirstName: string | null
    LastName: string | null
    MobileNumber: string | null
    NIC: string | null
    Address: string | null
    email: string | null
    password: string | null
    Availability: boolean | null
    ServiceType: string | null
  }

  export type ServiceProviderMaxAggregateOutputType = {
    ProviderID: string | null
    FirstName: string | null
    LastName: string | null
    MobileNumber: string | null
    NIC: string | null
    Address: string | null
    email: string | null
    password: string | null
    Availability: boolean | null
    ServiceType: string | null
  }

  export type ServiceProviderCountAggregateOutputType = {
    ProviderID: number
    FirstName: number
    LastName: number
    MobileNumber: number
    NIC: number
    Address: number
    email: number
    password: number
    Availability: number
    ServiceType: number
    _all: number
  }


  export type ServiceProviderMinAggregateInputType = {
    ProviderID?: true
    FirstName?: true
    LastName?: true
    MobileNumber?: true
    NIC?: true
    Address?: true
    email?: true
    password?: true
    Availability?: true
    ServiceType?: true
  }

  export type ServiceProviderMaxAggregateInputType = {
    ProviderID?: true
    FirstName?: true
    LastName?: true
    MobileNumber?: true
    NIC?: true
    Address?: true
    email?: true
    password?: true
    Availability?: true
    ServiceType?: true
  }

  export type ServiceProviderCountAggregateInputType = {
    ProviderID?: true
    FirstName?: true
    LastName?: true
    MobileNumber?: true
    NIC?: true
    Address?: true
    email?: true
    password?: true
    Availability?: true
    ServiceType?: true
    _all?: true
  }

  export type ServiceProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceProvider to aggregate.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceProviders
    **/
    _count?: true | ServiceProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceProviderMaxAggregateInputType
  }

  export type GetServiceProviderAggregateType<T extends ServiceProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceProvider[P]>
      : GetScalarType<T[P], AggregateServiceProvider[P]>
  }




  export type ServiceProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceProviderWhereInput
    orderBy?: ServiceProviderOrderByWithAggregationInput | ServiceProviderOrderByWithAggregationInput[]
    by: ServiceProviderScalarFieldEnum[] | ServiceProviderScalarFieldEnum
    having?: ServiceProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceProviderCountAggregateInputType | true
    _min?: ServiceProviderMinAggregateInputType
    _max?: ServiceProviderMaxAggregateInputType
  }

  export type ServiceProviderGroupByOutputType = {
    ProviderID: string
    FirstName: string | null
    LastName: string | null
    MobileNumber: string | null
    NIC: string | null
    Address: string | null
    email: string | null
    password: string
    Availability: boolean
    ServiceType: string
    _count: ServiceProviderCountAggregateOutputType | null
    _min: ServiceProviderMinAggregateOutputType | null
    _max: ServiceProviderMaxAggregateOutputType | null
  }

  type GetServiceProviderGroupByPayload<T extends ServiceProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceProviderGroupByOutputType[P]>
        }
      >
    >


  export type ServiceProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ProviderID?: boolean
    FirstName?: boolean
    LastName?: boolean
    MobileNumber?: boolean
    NIC?: boolean
    Address?: boolean
    email?: boolean
    password?: boolean
    Availability?: boolean
    ServiceType?: boolean
    bookings?: boolean | ServiceProvider$bookingsArgs<ExtArgs>
    serviceProvider_Reports?: boolean | ServiceProvider$serviceProvider_ReportsArgs<ExtArgs>
    schedule?: boolean | ServiceProvider$scheduleArgs<ExtArgs>
    customer?: boolean | ServiceProvider$customerArgs<ExtArgs>
    providerSalary?: boolean | ServiceProvider$providerSalaryArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    _count?: boolean | ServiceProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceProvider"]>



  export type ServiceProviderSelectScalar = {
    ProviderID?: boolean
    FirstName?: boolean
    LastName?: boolean
    MobileNumber?: boolean
    NIC?: boolean
    Address?: boolean
    email?: boolean
    password?: boolean
    Availability?: boolean
    ServiceType?: boolean
  }

  export type ServiceProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ProviderID" | "FirstName" | "LastName" | "MobileNumber" | "NIC" | "Address" | "email" | "password" | "Availability" | "ServiceType", ExtArgs["result"]["serviceProvider"]>
  export type ServiceProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ServiceProvider$bookingsArgs<ExtArgs>
    serviceProvider_Reports?: boolean | ServiceProvider$serviceProvider_ReportsArgs<ExtArgs>
    schedule?: boolean | ServiceProvider$scheduleArgs<ExtArgs>
    customer?: boolean | ServiceProvider$customerArgs<ExtArgs>
    providerSalary?: boolean | ServiceProvider$providerSalaryArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    _count?: boolean | ServiceProviderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServiceProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceProvider"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      serviceProvider_Reports: Prisma.$ServiceProvider_ReportsPayload<ExtArgs> | null
      schedule: Prisma.$SchedulePayload<ExtArgs> | null
      customer: Prisma.$Customer_ProviderPayload<ExtArgs>[]
      providerSalary: Prisma.$ProviderSalaryPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ProviderID: string
      FirstName: string | null
      LastName: string | null
      MobileNumber: string | null
      NIC: string | null
      Address: string | null
      email: string | null
      password: string
      Availability: boolean
      ServiceType: string
    }, ExtArgs["result"]["serviceProvider"]>
    composites: {}
  }

  type ServiceProviderGetPayload<S extends boolean | null | undefined | ServiceProviderDefaultArgs> = $Result.GetResult<Prisma.$ServiceProviderPayload, S>

  type ServiceProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceProviderCountAggregateInputType | true
    }

  export interface ServiceProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceProvider'], meta: { name: 'ServiceProvider' } }
    /**
     * Find zero or one ServiceProvider that matches the filter.
     * @param {ServiceProviderFindUniqueArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceProviderFindUniqueArgs>(args: SelectSubset<T, ServiceProviderFindUniqueArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceProvider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceProviderFindUniqueOrThrowArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderFindFirstArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceProviderFindFirstArgs>(args?: SelectSubset<T, ServiceProviderFindFirstArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderFindFirstOrThrowArgs} args - Arguments to find a ServiceProvider
     * @example
     * // Get one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceProviders
     * const serviceProviders = await prisma.serviceProvider.findMany()
     * 
     * // Get first 10 ServiceProviders
     * const serviceProviders = await prisma.serviceProvider.findMany({ take: 10 })
     * 
     * // Only select the `ProviderID`
     * const serviceProviderWithProviderIDOnly = await prisma.serviceProvider.findMany({ select: { ProviderID: true } })
     * 
     */
    findMany<T extends ServiceProviderFindManyArgs>(args?: SelectSubset<T, ServiceProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceProvider.
     * @param {ServiceProviderCreateArgs} args - Arguments to create a ServiceProvider.
     * @example
     * // Create one ServiceProvider
     * const ServiceProvider = await prisma.serviceProvider.create({
     *   data: {
     *     // ... data to create a ServiceProvider
     *   }
     * })
     * 
     */
    create<T extends ServiceProviderCreateArgs>(args: SelectSubset<T, ServiceProviderCreateArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceProviders.
     * @param {ServiceProviderCreateManyArgs} args - Arguments to create many ServiceProviders.
     * @example
     * // Create many ServiceProviders
     * const serviceProvider = await prisma.serviceProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceProviderCreateManyArgs>(args?: SelectSubset<T, ServiceProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceProvider.
     * @param {ServiceProviderDeleteArgs} args - Arguments to delete one ServiceProvider.
     * @example
     * // Delete one ServiceProvider
     * const ServiceProvider = await prisma.serviceProvider.delete({
     *   where: {
     *     // ... filter to delete one ServiceProvider
     *   }
     * })
     * 
     */
    delete<T extends ServiceProviderDeleteArgs>(args: SelectSubset<T, ServiceProviderDeleteArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceProvider.
     * @param {ServiceProviderUpdateArgs} args - Arguments to update one ServiceProvider.
     * @example
     * // Update one ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceProviderUpdateArgs>(args: SelectSubset<T, ServiceProviderUpdateArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceProviders.
     * @param {ServiceProviderDeleteManyArgs} args - Arguments to filter ServiceProviders to delete.
     * @example
     * // Delete a few ServiceProviders
     * const { count } = await prisma.serviceProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceProviderDeleteManyArgs>(args?: SelectSubset<T, ServiceProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceProviders
     * const serviceProvider = await prisma.serviceProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceProviderUpdateManyArgs>(args: SelectSubset<T, ServiceProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceProvider.
     * @param {ServiceProviderUpsertArgs} args - Arguments to update or create a ServiceProvider.
     * @example
     * // Update or create a ServiceProvider
     * const serviceProvider = await prisma.serviceProvider.upsert({
     *   create: {
     *     // ... data to create a ServiceProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceProvider we want to update
     *   }
     * })
     */
    upsert<T extends ServiceProviderUpsertArgs>(args: SelectSubset<T, ServiceProviderUpsertArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceProviders that matches the filter.
     * @param {ServiceProviderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const serviceProvider = await prisma.serviceProvider.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ServiceProviderFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ServiceProvider.
     * @param {ServiceProviderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const serviceProvider = await prisma.serviceProvider.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiceProviderAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ServiceProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderCountArgs} args - Arguments to filter ServiceProviders to count.
     * @example
     * // Count the number of ServiceProviders
     * const count = await prisma.serviceProvider.count({
     *   where: {
     *     // ... the filter for the ServiceProviders we want to count
     *   }
     * })
    **/
    count<T extends ServiceProviderCountArgs>(
      args?: Subset<T, ServiceProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceProviderAggregateArgs>(args: Subset<T, ServiceProviderAggregateArgs>): Prisma.PrismaPromise<GetServiceProviderAggregateType<T>>

    /**
     * Group by ServiceProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceProviderGroupByArgs['orderBy'] }
        : { orderBy?: ServiceProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceProvider model
   */
  readonly fields: ServiceProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends ServiceProvider$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceProvider_Reports<T extends ServiceProvider$serviceProvider_ReportsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$serviceProvider_ReportsArgs<ExtArgs>>): Prisma__ServiceProvider_ReportsClient<$Result.GetResult<Prisma.$ServiceProvider_ReportsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schedule<T extends ServiceProvider$scheduleArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$scheduleArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends ServiceProvider$customerArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$customerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    providerSalary<T extends ServiceProvider$providerSalaryArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProvider$providerSalaryArgs<ExtArgs>>): Prisma__ProviderSalaryClient<$Result.GetResult<Prisma.$ProviderSalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceProvider model
   */ 
  interface ServiceProviderFieldRefs {
    readonly ProviderID: FieldRef<"ServiceProvider", 'String'>
    readonly FirstName: FieldRef<"ServiceProvider", 'String'>
    readonly LastName: FieldRef<"ServiceProvider", 'String'>
    readonly MobileNumber: FieldRef<"ServiceProvider", 'String'>
    readonly NIC: FieldRef<"ServiceProvider", 'String'>
    readonly Address: FieldRef<"ServiceProvider", 'String'>
    readonly email: FieldRef<"ServiceProvider", 'String'>
    readonly password: FieldRef<"ServiceProvider", 'String'>
    readonly Availability: FieldRef<"ServiceProvider", 'Boolean'>
    readonly ServiceType: FieldRef<"ServiceProvider", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceProvider findUnique
   */
  export type ServiceProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider findUniqueOrThrow
   */
  export type ServiceProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider findFirst
   */
  export type ServiceProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceProviders.
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceProviders.
     */
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * ServiceProvider findFirstOrThrow
   */
  export type ServiceProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider to fetch.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceProviders.
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceProviders.
     */
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * ServiceProvider findMany
   */
  export type ServiceProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProviders to fetch.
     */
    where?: ServiceProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProviders to fetch.
     */
    orderBy?: ServiceProviderOrderByWithRelationInput | ServiceProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceProviders.
     */
    cursor?: ServiceProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProviders.
     */
    skip?: number
    distinct?: ServiceProviderScalarFieldEnum | ServiceProviderScalarFieldEnum[]
  }

  /**
   * ServiceProvider create
   */
  export type ServiceProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceProvider.
     */
    data: XOR<ServiceProviderCreateInput, ServiceProviderUncheckedCreateInput>
  }

  /**
   * ServiceProvider createMany
   */
  export type ServiceProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceProviders.
     */
    data: ServiceProviderCreateManyInput | ServiceProviderCreateManyInput[]
  }

  /**
   * ServiceProvider update
   */
  export type ServiceProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceProvider.
     */
    data: XOR<ServiceProviderUpdateInput, ServiceProviderUncheckedUpdateInput>
    /**
     * Choose, which ServiceProvider to update.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider updateMany
   */
  export type ServiceProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceProviders.
     */
    data: XOR<ServiceProviderUpdateManyMutationInput, ServiceProviderUncheckedUpdateManyInput>
    /**
     * Filter which ServiceProviders to update
     */
    where?: ServiceProviderWhereInput
    /**
     * Limit how many ServiceProviders to update.
     */
    limit?: number
  }

  /**
   * ServiceProvider upsert
   */
  export type ServiceProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceProvider to update in case it exists.
     */
    where: ServiceProviderWhereUniqueInput
    /**
     * In case the ServiceProvider found by the `where` argument doesn't exist, create a new ServiceProvider with this data.
     */
    create: XOR<ServiceProviderCreateInput, ServiceProviderUncheckedCreateInput>
    /**
     * In case the ServiceProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceProviderUpdateInput, ServiceProviderUncheckedUpdateInput>
  }

  /**
   * ServiceProvider delete
   */
  export type ServiceProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
    /**
     * Filter which ServiceProvider to delete.
     */
    where: ServiceProviderWhereUniqueInput
  }

  /**
   * ServiceProvider deleteMany
   */
  export type ServiceProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceProviders to delete
     */
    where?: ServiceProviderWhereInput
    /**
     * Limit how many ServiceProviders to delete.
     */
    limit?: number
  }

  /**
   * ServiceProvider findRaw
   */
  export type ServiceProviderFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceProvider aggregateRaw
   */
  export type ServiceProviderAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceProvider.bookings
   */
  export type ServiceProvider$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * ServiceProvider.serviceProvider_Reports
   */
  export type ServiceProvider$serviceProvider_ReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
    where?: ServiceProvider_ReportsWhereInput
  }

  /**
   * ServiceProvider.schedule
   */
  export type ServiceProvider$scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
  }

  /**
   * ServiceProvider.customer
   */
  export type ServiceProvider$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    where?: Customer_ProviderWhereInput
    orderBy?: Customer_ProviderOrderByWithRelationInput | Customer_ProviderOrderByWithRelationInput[]
    cursor?: Customer_ProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Customer_ProviderScalarFieldEnum | Customer_ProviderScalarFieldEnum[]
  }

  /**
   * ServiceProvider.providerSalary
   */
  export type ServiceProvider$providerSalaryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
    where?: ProviderSalaryWhereInput
  }

  /**
   * ServiceProvider without action
   */
  export type ServiceProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider
     */
    select?: ServiceProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider
     */
    omit?: ServiceProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProviderInclude<ExtArgs> | null
  }


  /**
   * Model Customer_Provider
   */

  export type AggregateCustomer_Provider = {
    _count: Customer_ProviderCountAggregateOutputType | null
    _min: Customer_ProviderMinAggregateOutputType | null
    _max: Customer_ProviderMaxAggregateOutputType | null
  }

  export type Customer_ProviderMinAggregateOutputType = {
    id: string | null
    customer: string | null
    provider: string | null
  }

  export type Customer_ProviderMaxAggregateOutputType = {
    id: string | null
    customer: string | null
    provider: string | null
  }

  export type Customer_ProviderCountAggregateOutputType = {
    id: number
    customer: number
    provider: number
    _all: number
  }


  export type Customer_ProviderMinAggregateInputType = {
    id?: true
    customer?: true
    provider?: true
  }

  export type Customer_ProviderMaxAggregateInputType = {
    id?: true
    customer?: true
    provider?: true
  }

  export type Customer_ProviderCountAggregateInputType = {
    id?: true
    customer?: true
    provider?: true
    _all?: true
  }

  export type Customer_ProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer_Provider to aggregate.
     */
    where?: Customer_ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customer_Providers to fetch.
     */
    orderBy?: Customer_ProviderOrderByWithRelationInput | Customer_ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Customer_ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customer_Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customer_Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customer_Providers
    **/
    _count?: true | Customer_ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Customer_ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Customer_ProviderMaxAggregateInputType
  }

  export type GetCustomer_ProviderAggregateType<T extends Customer_ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer_Provider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer_Provider[P]>
      : GetScalarType<T[P], AggregateCustomer_Provider[P]>
  }




  export type Customer_ProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Customer_ProviderWhereInput
    orderBy?: Customer_ProviderOrderByWithAggregationInput | Customer_ProviderOrderByWithAggregationInput[]
    by: Customer_ProviderScalarFieldEnum[] | Customer_ProviderScalarFieldEnum
    having?: Customer_ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Customer_ProviderCountAggregateInputType | true
    _min?: Customer_ProviderMinAggregateInputType
    _max?: Customer_ProviderMaxAggregateInputType
  }

  export type Customer_ProviderGroupByOutputType = {
    id: string
    customer: string
    provider: string
    _count: Customer_ProviderCountAggregateOutputType | null
    _min: Customer_ProviderMinAggregateOutputType | null
    _max: Customer_ProviderMaxAggregateOutputType | null
  }

  type GetCustomer_ProviderGroupByPayload<T extends Customer_ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Customer_ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Customer_ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Customer_ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], Customer_ProviderGroupByOutputType[P]>
        }
      >
    >


  export type Customer_ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customer?: boolean
    provider?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer_Provider"]>



  export type Customer_ProviderSelectScalar = {
    id?: boolean
    customer?: boolean
    provider?: boolean
  }

  export type Customer_ProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customer" | "provider", ExtArgs["result"]["customer_Provider"]>
  export type Customer_ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    customers?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $Customer_ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer_Provider"
    objects: {
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
      customers: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customer: string
      provider: string
    }, ExtArgs["result"]["customer_Provider"]>
    composites: {}
  }

  type Customer_ProviderGetPayload<S extends boolean | null | undefined | Customer_ProviderDefaultArgs> = $Result.GetResult<Prisma.$Customer_ProviderPayload, S>

  type Customer_ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<Customer_ProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Customer_ProviderCountAggregateInputType | true
    }

  export interface Customer_ProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer_Provider'], meta: { name: 'Customer_Provider' } }
    /**
     * Find zero or one Customer_Provider that matches the filter.
     * @param {Customer_ProviderFindUniqueArgs} args - Arguments to find a Customer_Provider
     * @example
     * // Get one Customer_Provider
     * const customer_Provider = await prisma.customer_Provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Customer_ProviderFindUniqueArgs>(args: SelectSubset<T, Customer_ProviderFindUniqueArgs<ExtArgs>>): Prisma__Customer_ProviderClient<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer_Provider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {Customer_ProviderFindUniqueOrThrowArgs} args - Arguments to find a Customer_Provider
     * @example
     * // Get one Customer_Provider
     * const customer_Provider = await prisma.customer_Provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Customer_ProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, Customer_ProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Customer_ProviderClient<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_ProviderFindFirstArgs} args - Arguments to find a Customer_Provider
     * @example
     * // Get one Customer_Provider
     * const customer_Provider = await prisma.customer_Provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Customer_ProviderFindFirstArgs>(args?: SelectSubset<T, Customer_ProviderFindFirstArgs<ExtArgs>>): Prisma__Customer_ProviderClient<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer_Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_ProviderFindFirstOrThrowArgs} args - Arguments to find a Customer_Provider
     * @example
     * // Get one Customer_Provider
     * const customer_Provider = await prisma.customer_Provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Customer_ProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, Customer_ProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__Customer_ProviderClient<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customer_Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_ProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customer_Providers
     * const customer_Providers = await prisma.customer_Provider.findMany()
     * 
     * // Get first 10 Customer_Providers
     * const customer_Providers = await prisma.customer_Provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customer_ProviderWithIdOnly = await prisma.customer_Provider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Customer_ProviderFindManyArgs>(args?: SelectSubset<T, Customer_ProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer_Provider.
     * @param {Customer_ProviderCreateArgs} args - Arguments to create a Customer_Provider.
     * @example
     * // Create one Customer_Provider
     * const Customer_Provider = await prisma.customer_Provider.create({
     *   data: {
     *     // ... data to create a Customer_Provider
     *   }
     * })
     * 
     */
    create<T extends Customer_ProviderCreateArgs>(args: SelectSubset<T, Customer_ProviderCreateArgs<ExtArgs>>): Prisma__Customer_ProviderClient<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customer_Providers.
     * @param {Customer_ProviderCreateManyArgs} args - Arguments to create many Customer_Providers.
     * @example
     * // Create many Customer_Providers
     * const customer_Provider = await prisma.customer_Provider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Customer_ProviderCreateManyArgs>(args?: SelectSubset<T, Customer_ProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer_Provider.
     * @param {Customer_ProviderDeleteArgs} args - Arguments to delete one Customer_Provider.
     * @example
     * // Delete one Customer_Provider
     * const Customer_Provider = await prisma.customer_Provider.delete({
     *   where: {
     *     // ... filter to delete one Customer_Provider
     *   }
     * })
     * 
     */
    delete<T extends Customer_ProviderDeleteArgs>(args: SelectSubset<T, Customer_ProviderDeleteArgs<ExtArgs>>): Prisma__Customer_ProviderClient<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer_Provider.
     * @param {Customer_ProviderUpdateArgs} args - Arguments to update one Customer_Provider.
     * @example
     * // Update one Customer_Provider
     * const customer_Provider = await prisma.customer_Provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Customer_ProviderUpdateArgs>(args: SelectSubset<T, Customer_ProviderUpdateArgs<ExtArgs>>): Prisma__Customer_ProviderClient<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customer_Providers.
     * @param {Customer_ProviderDeleteManyArgs} args - Arguments to filter Customer_Providers to delete.
     * @example
     * // Delete a few Customer_Providers
     * const { count } = await prisma.customer_Provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Customer_ProviderDeleteManyArgs>(args?: SelectSubset<T, Customer_ProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customer_Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customer_Providers
     * const customer_Provider = await prisma.customer_Provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Customer_ProviderUpdateManyArgs>(args: SelectSubset<T, Customer_ProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer_Provider.
     * @param {Customer_ProviderUpsertArgs} args - Arguments to update or create a Customer_Provider.
     * @example
     * // Update or create a Customer_Provider
     * const customer_Provider = await prisma.customer_Provider.upsert({
     *   create: {
     *     // ... data to create a Customer_Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer_Provider we want to update
     *   }
     * })
     */
    upsert<T extends Customer_ProviderUpsertArgs>(args: SelectSubset<T, Customer_ProviderUpsertArgs<ExtArgs>>): Prisma__Customer_ProviderClient<$Result.GetResult<Prisma.$Customer_ProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customer_Providers that matches the filter.
     * @param {Customer_ProviderFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customer_Provider = await prisma.customer_Provider.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: Customer_ProviderFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Customer_Provider.
     * @param {Customer_ProviderAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customer_Provider = await prisma.customer_Provider.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Customer_ProviderAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Customer_Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_ProviderCountArgs} args - Arguments to filter Customer_Providers to count.
     * @example
     * // Count the number of Customer_Providers
     * const count = await prisma.customer_Provider.count({
     *   where: {
     *     // ... the filter for the Customer_Providers we want to count
     *   }
     * })
    **/
    count<T extends Customer_ProviderCountArgs>(
      args?: Subset<T, Customer_ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Customer_ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer_Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Customer_ProviderAggregateArgs>(args: Subset<T, Customer_ProviderAggregateArgs>): Prisma.PrismaPromise<GetCustomer_ProviderAggregateType<T>>

    /**
     * Group by Customer_Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Customer_ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Customer_ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Customer_ProviderGroupByArgs['orderBy'] }
        : { orderBy?: Customer_ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Customer_ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomer_ProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer_Provider model
   */
  readonly fields: Customer_ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer_Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Customer_ProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customers<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer_Provider model
   */ 
  interface Customer_ProviderFieldRefs {
    readonly id: FieldRef<"Customer_Provider", 'String'>
    readonly customer: FieldRef<"Customer_Provider", 'String'>
    readonly provider: FieldRef<"Customer_Provider", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer_Provider findUnique
   */
  export type Customer_ProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Customer_Provider to fetch.
     */
    where: Customer_ProviderWhereUniqueInput
  }

  /**
   * Customer_Provider findUniqueOrThrow
   */
  export type Customer_ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Customer_Provider to fetch.
     */
    where: Customer_ProviderWhereUniqueInput
  }

  /**
   * Customer_Provider findFirst
   */
  export type Customer_ProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Customer_Provider to fetch.
     */
    where?: Customer_ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customer_Providers to fetch.
     */
    orderBy?: Customer_ProviderOrderByWithRelationInput | Customer_ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customer_Providers.
     */
    cursor?: Customer_ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customer_Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customer_Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customer_Providers.
     */
    distinct?: Customer_ProviderScalarFieldEnum | Customer_ProviderScalarFieldEnum[]
  }

  /**
   * Customer_Provider findFirstOrThrow
   */
  export type Customer_ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Customer_Provider to fetch.
     */
    where?: Customer_ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customer_Providers to fetch.
     */
    orderBy?: Customer_ProviderOrderByWithRelationInput | Customer_ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customer_Providers.
     */
    cursor?: Customer_ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customer_Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customer_Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customer_Providers.
     */
    distinct?: Customer_ProviderScalarFieldEnum | Customer_ProviderScalarFieldEnum[]
  }

  /**
   * Customer_Provider findMany
   */
  export type Customer_ProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Customer_Providers to fetch.
     */
    where?: Customer_ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customer_Providers to fetch.
     */
    orderBy?: Customer_ProviderOrderByWithRelationInput | Customer_ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customer_Providers.
     */
    cursor?: Customer_ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customer_Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customer_Providers.
     */
    skip?: number
    distinct?: Customer_ProviderScalarFieldEnum | Customer_ProviderScalarFieldEnum[]
  }

  /**
   * Customer_Provider create
   */
  export type Customer_ProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer_Provider.
     */
    data: XOR<Customer_ProviderCreateInput, Customer_ProviderUncheckedCreateInput>
  }

  /**
   * Customer_Provider createMany
   */
  export type Customer_ProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customer_Providers.
     */
    data: Customer_ProviderCreateManyInput | Customer_ProviderCreateManyInput[]
  }

  /**
   * Customer_Provider update
   */
  export type Customer_ProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer_Provider.
     */
    data: XOR<Customer_ProviderUpdateInput, Customer_ProviderUncheckedUpdateInput>
    /**
     * Choose, which Customer_Provider to update.
     */
    where: Customer_ProviderWhereUniqueInput
  }

  /**
   * Customer_Provider updateMany
   */
  export type Customer_ProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customer_Providers.
     */
    data: XOR<Customer_ProviderUpdateManyMutationInput, Customer_ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Customer_Providers to update
     */
    where?: Customer_ProviderWhereInput
    /**
     * Limit how many Customer_Providers to update.
     */
    limit?: number
  }

  /**
   * Customer_Provider upsert
   */
  export type Customer_ProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer_Provider to update in case it exists.
     */
    where: Customer_ProviderWhereUniqueInput
    /**
     * In case the Customer_Provider found by the `where` argument doesn't exist, create a new Customer_Provider with this data.
     */
    create: XOR<Customer_ProviderCreateInput, Customer_ProviderUncheckedCreateInput>
    /**
     * In case the Customer_Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Customer_ProviderUpdateInput, Customer_ProviderUncheckedUpdateInput>
  }

  /**
   * Customer_Provider delete
   */
  export type Customer_ProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
    /**
     * Filter which Customer_Provider to delete.
     */
    where: Customer_ProviderWhereUniqueInput
  }

  /**
   * Customer_Provider deleteMany
   */
  export type Customer_ProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer_Providers to delete
     */
    where?: Customer_ProviderWhereInput
    /**
     * Limit how many Customer_Providers to delete.
     */
    limit?: number
  }

  /**
   * Customer_Provider findRaw
   */
  export type Customer_ProviderFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Customer_Provider aggregateRaw
   */
  export type Customer_ProviderAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Customer_Provider without action
   */
  export type Customer_ProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer_Provider
     */
    select?: Customer_ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer_Provider
     */
    omit?: Customer_ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Customer_ProviderInclude<ExtArgs> | null
  }


  /**
   * Model ServiceProvider_Reports
   */

  export type AggregateServiceProvider_Reports = {
    _count: ServiceProvider_ReportsCountAggregateOutputType | null
    _min: ServiceProvider_ReportsMinAggregateOutputType | null
    _max: ServiceProvider_ReportsMaxAggregateOutputType | null
  }

  export type ServiceProvider_ReportsMinAggregateOutputType = {
    ReportID: string | null
    Provider: string | null
    BirthCertificate: string | null
    PoliceReport: string | null
    NIC_Copy: string | null
  }

  export type ServiceProvider_ReportsMaxAggregateOutputType = {
    ReportID: string | null
    Provider: string | null
    BirthCertificate: string | null
    PoliceReport: string | null
    NIC_Copy: string | null
  }

  export type ServiceProvider_ReportsCountAggregateOutputType = {
    ReportID: number
    Provider: number
    BirthCertificate: number
    PoliceReport: number
    NIC_Copy: number
    _all: number
  }


  export type ServiceProvider_ReportsMinAggregateInputType = {
    ReportID?: true
    Provider?: true
    BirthCertificate?: true
    PoliceReport?: true
    NIC_Copy?: true
  }

  export type ServiceProvider_ReportsMaxAggregateInputType = {
    ReportID?: true
    Provider?: true
    BirthCertificate?: true
    PoliceReport?: true
    NIC_Copy?: true
  }

  export type ServiceProvider_ReportsCountAggregateInputType = {
    ReportID?: true
    Provider?: true
    BirthCertificate?: true
    PoliceReport?: true
    NIC_Copy?: true
    _all?: true
  }

  export type ServiceProvider_ReportsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceProvider_Reports to aggregate.
     */
    where?: ServiceProvider_ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProvider_Reports to fetch.
     */
    orderBy?: ServiceProvider_ReportsOrderByWithRelationInput | ServiceProvider_ReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceProvider_ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProvider_Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProvider_Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceProvider_Reports
    **/
    _count?: true | ServiceProvider_ReportsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceProvider_ReportsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceProvider_ReportsMaxAggregateInputType
  }

  export type GetServiceProvider_ReportsAggregateType<T extends ServiceProvider_ReportsAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceProvider_Reports]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceProvider_Reports[P]>
      : GetScalarType<T[P], AggregateServiceProvider_Reports[P]>
  }




  export type ServiceProvider_ReportsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceProvider_ReportsWhereInput
    orderBy?: ServiceProvider_ReportsOrderByWithAggregationInput | ServiceProvider_ReportsOrderByWithAggregationInput[]
    by: ServiceProvider_ReportsScalarFieldEnum[] | ServiceProvider_ReportsScalarFieldEnum
    having?: ServiceProvider_ReportsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceProvider_ReportsCountAggregateInputType | true
    _min?: ServiceProvider_ReportsMinAggregateInputType
    _max?: ServiceProvider_ReportsMaxAggregateInputType
  }

  export type ServiceProvider_ReportsGroupByOutputType = {
    ReportID: string
    Provider: string
    BirthCertificate: string | null
    PoliceReport: string | null
    NIC_Copy: string | null
    _count: ServiceProvider_ReportsCountAggregateOutputType | null
    _min: ServiceProvider_ReportsMinAggregateOutputType | null
    _max: ServiceProvider_ReportsMaxAggregateOutputType | null
  }

  type GetServiceProvider_ReportsGroupByPayload<T extends ServiceProvider_ReportsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceProvider_ReportsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceProvider_ReportsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceProvider_ReportsGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceProvider_ReportsGroupByOutputType[P]>
        }
      >
    >


  export type ServiceProvider_ReportsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ReportID?: boolean
    Provider?: boolean
    BirthCertificate?: boolean
    PoliceReport?: boolean
    NIC_Copy?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceProvider_Reports"]>



  export type ServiceProvider_ReportsSelectScalar = {
    ReportID?: boolean
    Provider?: boolean
    BirthCertificate?: boolean
    PoliceReport?: boolean
    NIC_Copy?: boolean
  }

  export type ServiceProvider_ReportsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ReportID" | "Provider" | "BirthCertificate" | "PoliceReport" | "NIC_Copy", ExtArgs["result"]["serviceProvider_Reports"]>
  export type ServiceProvider_ReportsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }

  export type $ServiceProvider_ReportsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceProvider_Reports"
    objects: {
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ReportID: string
      Provider: string
      BirthCertificate: string | null
      PoliceReport: string | null
      NIC_Copy: string | null
    }, ExtArgs["result"]["serviceProvider_Reports"]>
    composites: {}
  }

  type ServiceProvider_ReportsGetPayload<S extends boolean | null | undefined | ServiceProvider_ReportsDefaultArgs> = $Result.GetResult<Prisma.$ServiceProvider_ReportsPayload, S>

  type ServiceProvider_ReportsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceProvider_ReportsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceProvider_ReportsCountAggregateInputType | true
    }

  export interface ServiceProvider_ReportsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceProvider_Reports'], meta: { name: 'ServiceProvider_Reports' } }
    /**
     * Find zero or one ServiceProvider_Reports that matches the filter.
     * @param {ServiceProvider_ReportsFindUniqueArgs} args - Arguments to find a ServiceProvider_Reports
     * @example
     * // Get one ServiceProvider_Reports
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceProvider_ReportsFindUniqueArgs>(args: SelectSubset<T, ServiceProvider_ReportsFindUniqueArgs<ExtArgs>>): Prisma__ServiceProvider_ReportsClient<$Result.GetResult<Prisma.$ServiceProvider_ReportsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceProvider_Reports that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceProvider_ReportsFindUniqueOrThrowArgs} args - Arguments to find a ServiceProvider_Reports
     * @example
     * // Get one ServiceProvider_Reports
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceProvider_ReportsFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceProvider_ReportsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceProvider_ReportsClient<$Result.GetResult<Prisma.$ServiceProvider_ReportsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceProvider_Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProvider_ReportsFindFirstArgs} args - Arguments to find a ServiceProvider_Reports
     * @example
     * // Get one ServiceProvider_Reports
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceProvider_ReportsFindFirstArgs>(args?: SelectSubset<T, ServiceProvider_ReportsFindFirstArgs<ExtArgs>>): Prisma__ServiceProvider_ReportsClient<$Result.GetResult<Prisma.$ServiceProvider_ReportsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceProvider_Reports that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProvider_ReportsFindFirstOrThrowArgs} args - Arguments to find a ServiceProvider_Reports
     * @example
     * // Get one ServiceProvider_Reports
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceProvider_ReportsFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceProvider_ReportsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceProvider_ReportsClient<$Result.GetResult<Prisma.$ServiceProvider_ReportsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceProvider_Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProvider_ReportsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceProvider_Reports
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.findMany()
     * 
     * // Get first 10 ServiceProvider_Reports
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.findMany({ take: 10 })
     * 
     * // Only select the `ReportID`
     * const serviceProvider_ReportsWithReportIDOnly = await prisma.serviceProvider_Reports.findMany({ select: { ReportID: true } })
     * 
     */
    findMany<T extends ServiceProvider_ReportsFindManyArgs>(args?: SelectSubset<T, ServiceProvider_ReportsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceProvider_ReportsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceProvider_Reports.
     * @param {ServiceProvider_ReportsCreateArgs} args - Arguments to create a ServiceProvider_Reports.
     * @example
     * // Create one ServiceProvider_Reports
     * const ServiceProvider_Reports = await prisma.serviceProvider_Reports.create({
     *   data: {
     *     // ... data to create a ServiceProvider_Reports
     *   }
     * })
     * 
     */
    create<T extends ServiceProvider_ReportsCreateArgs>(args: SelectSubset<T, ServiceProvider_ReportsCreateArgs<ExtArgs>>): Prisma__ServiceProvider_ReportsClient<$Result.GetResult<Prisma.$ServiceProvider_ReportsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceProvider_Reports.
     * @param {ServiceProvider_ReportsCreateManyArgs} args - Arguments to create many ServiceProvider_Reports.
     * @example
     * // Create many ServiceProvider_Reports
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceProvider_ReportsCreateManyArgs>(args?: SelectSubset<T, ServiceProvider_ReportsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceProvider_Reports.
     * @param {ServiceProvider_ReportsDeleteArgs} args - Arguments to delete one ServiceProvider_Reports.
     * @example
     * // Delete one ServiceProvider_Reports
     * const ServiceProvider_Reports = await prisma.serviceProvider_Reports.delete({
     *   where: {
     *     // ... filter to delete one ServiceProvider_Reports
     *   }
     * })
     * 
     */
    delete<T extends ServiceProvider_ReportsDeleteArgs>(args: SelectSubset<T, ServiceProvider_ReportsDeleteArgs<ExtArgs>>): Prisma__ServiceProvider_ReportsClient<$Result.GetResult<Prisma.$ServiceProvider_ReportsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceProvider_Reports.
     * @param {ServiceProvider_ReportsUpdateArgs} args - Arguments to update one ServiceProvider_Reports.
     * @example
     * // Update one ServiceProvider_Reports
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceProvider_ReportsUpdateArgs>(args: SelectSubset<T, ServiceProvider_ReportsUpdateArgs<ExtArgs>>): Prisma__ServiceProvider_ReportsClient<$Result.GetResult<Prisma.$ServiceProvider_ReportsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceProvider_Reports.
     * @param {ServiceProvider_ReportsDeleteManyArgs} args - Arguments to filter ServiceProvider_Reports to delete.
     * @example
     * // Delete a few ServiceProvider_Reports
     * const { count } = await prisma.serviceProvider_Reports.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceProvider_ReportsDeleteManyArgs>(args?: SelectSubset<T, ServiceProvider_ReportsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceProvider_Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProvider_ReportsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceProvider_Reports
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceProvider_ReportsUpdateManyArgs>(args: SelectSubset<T, ServiceProvider_ReportsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceProvider_Reports.
     * @param {ServiceProvider_ReportsUpsertArgs} args - Arguments to update or create a ServiceProvider_Reports.
     * @example
     * // Update or create a ServiceProvider_Reports
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.upsert({
     *   create: {
     *     // ... data to create a ServiceProvider_Reports
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceProvider_Reports we want to update
     *   }
     * })
     */
    upsert<T extends ServiceProvider_ReportsUpsertArgs>(args: SelectSubset<T, ServiceProvider_ReportsUpsertArgs<ExtArgs>>): Prisma__ServiceProvider_ReportsClient<$Result.GetResult<Prisma.$ServiceProvider_ReportsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceProvider_Reports that matches the filter.
     * @param {ServiceProvider_ReportsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ServiceProvider_ReportsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ServiceProvider_Reports.
     * @param {ServiceProvider_ReportsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const serviceProvider_Reports = await prisma.serviceProvider_Reports.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiceProvider_ReportsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ServiceProvider_Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProvider_ReportsCountArgs} args - Arguments to filter ServiceProvider_Reports to count.
     * @example
     * // Count the number of ServiceProvider_Reports
     * const count = await prisma.serviceProvider_Reports.count({
     *   where: {
     *     // ... the filter for the ServiceProvider_Reports we want to count
     *   }
     * })
    **/
    count<T extends ServiceProvider_ReportsCountArgs>(
      args?: Subset<T, ServiceProvider_ReportsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceProvider_ReportsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceProvider_Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProvider_ReportsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceProvider_ReportsAggregateArgs>(args: Subset<T, ServiceProvider_ReportsAggregateArgs>): Prisma.PrismaPromise<GetServiceProvider_ReportsAggregateType<T>>

    /**
     * Group by ServiceProvider_Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceProvider_ReportsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceProvider_ReportsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceProvider_ReportsGroupByArgs['orderBy'] }
        : { orderBy?: ServiceProvider_ReportsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceProvider_ReportsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceProvider_ReportsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceProvider_Reports model
   */
  readonly fields: ServiceProvider_ReportsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceProvider_Reports.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceProvider_ReportsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceProvider_Reports model
   */ 
  interface ServiceProvider_ReportsFieldRefs {
    readonly ReportID: FieldRef<"ServiceProvider_Reports", 'String'>
    readonly Provider: FieldRef<"ServiceProvider_Reports", 'String'>
    readonly BirthCertificate: FieldRef<"ServiceProvider_Reports", 'String'>
    readonly PoliceReport: FieldRef<"ServiceProvider_Reports", 'String'>
    readonly NIC_Copy: FieldRef<"ServiceProvider_Reports", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceProvider_Reports findUnique
   */
  export type ServiceProvider_ReportsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider_Reports to fetch.
     */
    where: ServiceProvider_ReportsWhereUniqueInput
  }

  /**
   * ServiceProvider_Reports findUniqueOrThrow
   */
  export type ServiceProvider_ReportsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider_Reports to fetch.
     */
    where: ServiceProvider_ReportsWhereUniqueInput
  }

  /**
   * ServiceProvider_Reports findFirst
   */
  export type ServiceProvider_ReportsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider_Reports to fetch.
     */
    where?: ServiceProvider_ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProvider_Reports to fetch.
     */
    orderBy?: ServiceProvider_ReportsOrderByWithRelationInput | ServiceProvider_ReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceProvider_Reports.
     */
    cursor?: ServiceProvider_ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProvider_Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProvider_Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceProvider_Reports.
     */
    distinct?: ServiceProvider_ReportsScalarFieldEnum | ServiceProvider_ReportsScalarFieldEnum[]
  }

  /**
   * ServiceProvider_Reports findFirstOrThrow
   */
  export type ServiceProvider_ReportsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider_Reports to fetch.
     */
    where?: ServiceProvider_ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProvider_Reports to fetch.
     */
    orderBy?: ServiceProvider_ReportsOrderByWithRelationInput | ServiceProvider_ReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceProvider_Reports.
     */
    cursor?: ServiceProvider_ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProvider_Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProvider_Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceProvider_Reports.
     */
    distinct?: ServiceProvider_ReportsScalarFieldEnum | ServiceProvider_ReportsScalarFieldEnum[]
  }

  /**
   * ServiceProvider_Reports findMany
   */
  export type ServiceProvider_ReportsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
    /**
     * Filter, which ServiceProvider_Reports to fetch.
     */
    where?: ServiceProvider_ReportsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceProvider_Reports to fetch.
     */
    orderBy?: ServiceProvider_ReportsOrderByWithRelationInput | ServiceProvider_ReportsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceProvider_Reports.
     */
    cursor?: ServiceProvider_ReportsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceProvider_Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceProvider_Reports.
     */
    skip?: number
    distinct?: ServiceProvider_ReportsScalarFieldEnum | ServiceProvider_ReportsScalarFieldEnum[]
  }

  /**
   * ServiceProvider_Reports create
   */
  export type ServiceProvider_ReportsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceProvider_Reports.
     */
    data: XOR<ServiceProvider_ReportsCreateInput, ServiceProvider_ReportsUncheckedCreateInput>
  }

  /**
   * ServiceProvider_Reports createMany
   */
  export type ServiceProvider_ReportsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceProvider_Reports.
     */
    data: ServiceProvider_ReportsCreateManyInput | ServiceProvider_ReportsCreateManyInput[]
  }

  /**
   * ServiceProvider_Reports update
   */
  export type ServiceProvider_ReportsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceProvider_Reports.
     */
    data: XOR<ServiceProvider_ReportsUpdateInput, ServiceProvider_ReportsUncheckedUpdateInput>
    /**
     * Choose, which ServiceProvider_Reports to update.
     */
    where: ServiceProvider_ReportsWhereUniqueInput
  }

  /**
   * ServiceProvider_Reports updateMany
   */
  export type ServiceProvider_ReportsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceProvider_Reports.
     */
    data: XOR<ServiceProvider_ReportsUpdateManyMutationInput, ServiceProvider_ReportsUncheckedUpdateManyInput>
    /**
     * Filter which ServiceProvider_Reports to update
     */
    where?: ServiceProvider_ReportsWhereInput
    /**
     * Limit how many ServiceProvider_Reports to update.
     */
    limit?: number
  }

  /**
   * ServiceProvider_Reports upsert
   */
  export type ServiceProvider_ReportsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceProvider_Reports to update in case it exists.
     */
    where: ServiceProvider_ReportsWhereUniqueInput
    /**
     * In case the ServiceProvider_Reports found by the `where` argument doesn't exist, create a new ServiceProvider_Reports with this data.
     */
    create: XOR<ServiceProvider_ReportsCreateInput, ServiceProvider_ReportsUncheckedCreateInput>
    /**
     * In case the ServiceProvider_Reports was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceProvider_ReportsUpdateInput, ServiceProvider_ReportsUncheckedUpdateInput>
  }

  /**
   * ServiceProvider_Reports delete
   */
  export type ServiceProvider_ReportsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
    /**
     * Filter which ServiceProvider_Reports to delete.
     */
    where: ServiceProvider_ReportsWhereUniqueInput
  }

  /**
   * ServiceProvider_Reports deleteMany
   */
  export type ServiceProvider_ReportsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceProvider_Reports to delete
     */
    where?: ServiceProvider_ReportsWhereInput
    /**
     * Limit how many ServiceProvider_Reports to delete.
     */
    limit?: number
  }

  /**
   * ServiceProvider_Reports findRaw
   */
  export type ServiceProvider_ReportsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceProvider_Reports aggregateRaw
   */
  export type ServiceProvider_ReportsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceProvider_Reports without action
   */
  export type ServiceProvider_ReportsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceProvider_Reports
     */
    select?: ServiceProvider_ReportsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceProvider_Reports
     */
    omit?: ServiceProvider_ReportsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceProvider_ReportsInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    MonthlyPayment: number | null
  }

  export type BookingSumAggregateOutputType = {
    MonthlyPayment: number | null
  }

  export type BookingMinAggregateOutputType = {
    BookingID: string | null
    AgreementDuration: string | null
    Booking_Service: string | null
    Provider: string | null
    MonthlyPayment: number | null
    BookingDate: Date | null
    Status: $Enums.BookingStatus | null
    CustomerID: string | null
  }

  export type BookingMaxAggregateOutputType = {
    BookingID: string | null
    AgreementDuration: string | null
    Booking_Service: string | null
    Provider: string | null
    MonthlyPayment: number | null
    BookingDate: Date | null
    Status: $Enums.BookingStatus | null
    CustomerID: string | null
  }

  export type BookingCountAggregateOutputType = {
    BookingID: number
    AgreementDuration: number
    Booking_Service: number
    Provider: number
    MonthlyPayment: number
    BookingDate: number
    Status: number
    CustomerID: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    MonthlyPayment?: true
  }

  export type BookingSumAggregateInputType = {
    MonthlyPayment?: true
  }

  export type BookingMinAggregateInputType = {
    BookingID?: true
    AgreementDuration?: true
    Booking_Service?: true
    Provider?: true
    MonthlyPayment?: true
    BookingDate?: true
    Status?: true
    CustomerID?: true
  }

  export type BookingMaxAggregateInputType = {
    BookingID?: true
    AgreementDuration?: true
    Booking_Service?: true
    Provider?: true
    MonthlyPayment?: true
    BookingDate?: true
    Status?: true
    CustomerID?: true
  }

  export type BookingCountAggregateInputType = {
    BookingID?: true
    AgreementDuration?: true
    Booking_Service?: true
    Provider?: true
    MonthlyPayment?: true
    BookingDate?: true
    Status?: true
    CustomerID?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    BookingID: string
    AgreementDuration: string | null
    Booking_Service: string | null
    Provider: string
    MonthlyPayment: number | null
    BookingDate: Date
    Status: $Enums.BookingStatus
    CustomerID: string
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BookingID?: boolean
    AgreementDuration?: boolean
    Booking_Service?: boolean
    Provider?: boolean
    MonthlyPayment?: boolean
    BookingDate?: boolean
    Status?: boolean
    CustomerID?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    payment?: boolean | Booking$paymentArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>



  export type BookingSelectScalar = {
    BookingID?: boolean
    AgreementDuration?: boolean
    Booking_Service?: boolean
    Provider?: boolean
    MonthlyPayment?: boolean
    BookingDate?: boolean
    Status?: boolean
    CustomerID?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"BookingID" | "AgreementDuration" | "Booking_Service" | "Provider" | "MonthlyPayment" | "BookingDate" | "Status" | "CustomerID", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
    payment?: boolean | Booking$paymentArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      BookingID: string
      AgreementDuration: string | null
      Booking_Service: string | null
      Provider: string
      MonthlyPayment: number | null
      BookingDate: Date
      Status: $Enums.BookingStatus
      CustomerID: string
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `BookingID`
     * const bookingWithBookingIDOnly = await prisma.booking.findMany({ select: { BookingID: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * @param {BookingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const booking = await prisma.booking.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BookingFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Booking.
     * @param {BookingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const booking = await prisma.booking.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BookingAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends Booking$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly BookingID: FieldRef<"Booking", 'String'>
    readonly AgreementDuration: FieldRef<"Booking", 'String'>
    readonly Booking_Service: FieldRef<"Booking", 'String'>
    readonly Provider: FieldRef<"Booking", 'String'>
    readonly MonthlyPayment: FieldRef<"Booking", 'Float'>
    readonly BookingDate: FieldRef<"Booking", 'DateTime'>
    readonly Status: FieldRef<"Booking", 'BookingStatus'>
    readonly CustomerID: FieldRef<"Booking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking findRaw
   */
  export type BookingFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Booking aggregateRaw
   */
  export type BookingAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Booking.payment
   */
  export type Booking$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model PaymentMethod
   */

  export type AggregatePaymentMethod = {
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  export type PaymentMethodMinAggregateOutputType = {
    MethodId: string | null
    PaymentType: string | null
    Description: string | null
  }

  export type PaymentMethodMaxAggregateOutputType = {
    MethodId: string | null
    PaymentType: string | null
    Description: string | null
  }

  export type PaymentMethodCountAggregateOutputType = {
    MethodId: number
    PaymentType: number
    Description: number
    _all: number
  }


  export type PaymentMethodMinAggregateInputType = {
    MethodId?: true
    PaymentType?: true
    Description?: true
  }

  export type PaymentMethodMaxAggregateInputType = {
    MethodId?: true
    PaymentType?: true
    Description?: true
  }

  export type PaymentMethodCountAggregateInputType = {
    MethodId?: true
    PaymentType?: true
    Description?: true
    _all?: true
  }

  export type PaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethod to aggregate.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentMethods
    **/
    _count?: true | PaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type GetPaymentMethodAggregateType<T extends PaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentMethod[P]>
      : GetScalarType<T[P], AggregatePaymentMethod[P]>
  }




  export type PaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentMethodWhereInput
    orderBy?: PaymentMethodOrderByWithAggregationInput | PaymentMethodOrderByWithAggregationInput[]
    by: PaymentMethodScalarFieldEnum[] | PaymentMethodScalarFieldEnum
    having?: PaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentMethodCountAggregateInputType | true
    _min?: PaymentMethodMinAggregateInputType
    _max?: PaymentMethodMaxAggregateInputType
  }

  export type PaymentMethodGroupByOutputType = {
    MethodId: string
    PaymentType: string | null
    Description: string | null
    _count: PaymentMethodCountAggregateOutputType | null
    _min: PaymentMethodMinAggregateOutputType | null
    _max: PaymentMethodMaxAggregateOutputType | null
  }

  type GetPaymentMethodGroupByPayload<T extends PaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type PaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MethodId?: boolean
    PaymentType?: boolean
    Description?: boolean
    payment?: boolean | PaymentMethod$paymentArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentMethod"]>



  export type PaymentMethodSelectScalar = {
    MethodId?: boolean
    PaymentType?: boolean
    Description?: boolean
  }

  export type PaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"MethodId" | "PaymentType" | "Description", ExtArgs["result"]["paymentMethod"]>
  export type PaymentMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentMethod$paymentArgs<ExtArgs>
    _count?: boolean | PaymentMethodCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentMethod"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      MethodId: string
      PaymentType: string | null
      Description: string | null
    }, ExtArgs["result"]["paymentMethod"]>
    composites: {}
  }

  type PaymentMethodGetPayload<S extends boolean | null | undefined | PaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$PaymentMethodPayload, S>

  type PaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentMethodCountAggregateInputType | true
    }

  export interface PaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentMethod'], meta: { name: 'PaymentMethod' } }
    /**
     * Find zero or one PaymentMethod that matches the filter.
     * @param {PaymentMethodFindUniqueArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentMethodFindUniqueArgs>(args: SelectSubset<T, PaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentMethodFindFirstArgs>(args?: SelectSubset<T, PaymentMethodFindFirstArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindFirstOrThrowArgs} args - Arguments to find a PaymentMethod
     * @example
     * // Get one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany()
     * 
     * // Get first 10 PaymentMethods
     * const paymentMethods = await prisma.paymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `MethodId`
     * const paymentMethodWithMethodIdOnly = await prisma.paymentMethod.findMany({ select: { MethodId: true } })
     * 
     */
    findMany<T extends PaymentMethodFindManyArgs>(args?: SelectSubset<T, PaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentMethod.
     * @param {PaymentMethodCreateArgs} args - Arguments to create a PaymentMethod.
     * @example
     * // Create one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.create({
     *   data: {
     *     // ... data to create a PaymentMethod
     *   }
     * })
     * 
     */
    create<T extends PaymentMethodCreateArgs>(args: SelectSubset<T, PaymentMethodCreateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentMethods.
     * @param {PaymentMethodCreateManyArgs} args - Arguments to create many PaymentMethods.
     * @example
     * // Create many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentMethodCreateManyArgs>(args?: SelectSubset<T, PaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PaymentMethod.
     * @param {PaymentMethodDeleteArgs} args - Arguments to delete one PaymentMethod.
     * @example
     * // Delete one PaymentMethod
     * const PaymentMethod = await prisma.paymentMethod.delete({
     *   where: {
     *     // ... filter to delete one PaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends PaymentMethodDeleteArgs>(args: SelectSubset<T, PaymentMethodDeleteArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentMethod.
     * @param {PaymentMethodUpdateArgs} args - Arguments to update one PaymentMethod.
     * @example
     * // Update one PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentMethodUpdateArgs>(args: SelectSubset<T, PaymentMethodUpdateArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentMethods.
     * @param {PaymentMethodDeleteManyArgs} args - Arguments to filter PaymentMethods to delete.
     * @example
     * // Delete a few PaymentMethods
     * const { count } = await prisma.paymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentMethodDeleteManyArgs>(args?: SelectSubset<T, PaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentMethods
     * const paymentMethod = await prisma.paymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentMethodUpdateManyArgs>(args: SelectSubset<T, PaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentMethod.
     * @param {PaymentMethodUpsertArgs} args - Arguments to update or create a PaymentMethod.
     * @example
     * // Update or create a PaymentMethod
     * const paymentMethod = await prisma.paymentMethod.upsert({
     *   create: {
     *     // ... data to create a PaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends PaymentMethodUpsertArgs>(args: SelectSubset<T, PaymentMethodUpsertArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentMethods that matches the filter.
     * @param {PaymentMethodFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const paymentMethod = await prisma.paymentMethod.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PaymentMethodFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a PaymentMethod.
     * @param {PaymentMethodAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const paymentMethod = await prisma.paymentMethod.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PaymentMethodAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of PaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodCountArgs} args - Arguments to filter PaymentMethods to count.
     * @example
     * // Count the number of PaymentMethods
     * const count = await prisma.paymentMethod.count({
     *   where: {
     *     // ... the filter for the PaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends PaymentMethodCountArgs>(
      args?: Subset<T, PaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentMethodAggregateArgs>(args: Subset<T, PaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetPaymentMethodAggregateType<T>>

    /**
     * Group by PaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: PaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentMethod model
   */
  readonly fields: PaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentMethod$paymentArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethod$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentMethod model
   */ 
  interface PaymentMethodFieldRefs {
    readonly MethodId: FieldRef<"PaymentMethod", 'String'>
    readonly PaymentType: FieldRef<"PaymentMethod", 'String'>
    readonly Description: FieldRef<"PaymentMethod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentMethod findUnique
   */
  export type PaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findUniqueOrThrow
   */
  export type PaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod findFirst
   */
  export type PaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findFirstOrThrow
   */
  export type PaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethod to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentMethods.
     */
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod findMany
   */
  export type PaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter, which PaymentMethods to fetch.
     */
    where?: PaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentMethods to fetch.
     */
    orderBy?: PaymentMethodOrderByWithRelationInput | PaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentMethods.
     */
    cursor?: PaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentMethods.
     */
    skip?: number
    distinct?: PaymentMethodScalarFieldEnum | PaymentMethodScalarFieldEnum[]
  }

  /**
   * PaymentMethod create
   */
  export type PaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentMethod.
     */
    data?: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
  }

  /**
   * PaymentMethod createMany
   */
  export type PaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentMethods.
     */
    data: PaymentMethodCreateManyInput | PaymentMethodCreateManyInput[]
  }

  /**
   * PaymentMethod update
   */
  export type PaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentMethod.
     */
    data: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which PaymentMethod to update.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod updateMany
   */
  export type PaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentMethods.
     */
    data: XOR<PaymentMethodUpdateManyMutationInput, PaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which PaymentMethods to update
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to update.
     */
    limit?: number
  }

  /**
   * PaymentMethod upsert
   */
  export type PaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentMethod to update in case it exists.
     */
    where: PaymentMethodWhereUniqueInput
    /**
     * In case the PaymentMethod found by the `where` argument doesn't exist, create a new PaymentMethod with this data.
     */
    create: XOR<PaymentMethodCreateInput, PaymentMethodUncheckedCreateInput>
    /**
     * In case the PaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentMethodUpdateInput, PaymentMethodUncheckedUpdateInput>
  }

  /**
   * PaymentMethod delete
   */
  export type PaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
    /**
     * Filter which PaymentMethod to delete.
     */
    where: PaymentMethodWhereUniqueInput
  }

  /**
   * PaymentMethod deleteMany
   */
  export type PaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentMethods to delete
     */
    where?: PaymentMethodWhereInput
    /**
     * Limit how many PaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * PaymentMethod findRaw
   */
  export type PaymentMethodFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PaymentMethod aggregateRaw
   */
  export type PaymentMethodAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * PaymentMethod.payment
   */
  export type PaymentMethod$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * PaymentMethod without action
   */
  export type PaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentMethod
     */
    select?: PaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentMethod
     */
    omit?: PaymentMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentMethodInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    Amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    Amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    paymentID: string | null
    PaymentDate: Date | null
    Amount: number | null
    PaymentMethod: string | null
    BookingId: string | null
    Status: $Enums.PaymentStatus | null
  }

  export type PaymentMaxAggregateOutputType = {
    paymentID: string | null
    PaymentDate: Date | null
    Amount: number | null
    PaymentMethod: string | null
    BookingId: string | null
    Status: $Enums.PaymentStatus | null
  }

  export type PaymentCountAggregateOutputType = {
    paymentID: number
    PaymentDate: number
    Amount: number
    PaymentMethod: number
    BookingId: number
    Status: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    Amount?: true
  }

  export type PaymentSumAggregateInputType = {
    Amount?: true
  }

  export type PaymentMinAggregateInputType = {
    paymentID?: true
    PaymentDate?: true
    Amount?: true
    PaymentMethod?: true
    BookingId?: true
    Status?: true
  }

  export type PaymentMaxAggregateInputType = {
    paymentID?: true
    PaymentDate?: true
    Amount?: true
    PaymentMethod?: true
    BookingId?: true
    Status?: true
  }

  export type PaymentCountAggregateInputType = {
    paymentID?: true
    PaymentDate?: true
    Amount?: true
    PaymentMethod?: true
    BookingId?: true
    Status?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    paymentID: string
    PaymentDate: Date
    Amount: number | null
    PaymentMethod: string
    BookingId: string
    Status: $Enums.PaymentStatus
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    paymentID?: boolean
    PaymentDate?: boolean
    Amount?: boolean
    PaymentMethod?: boolean
    BookingId?: boolean
    Status?: boolean
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    refundRequests?: boolean | Payment$refundRequestsArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    paymentID?: boolean
    PaymentDate?: boolean
    Amount?: boolean
    PaymentMethod?: boolean
    BookingId?: boolean
    Status?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"paymentID" | "PaymentDate" | "Amount" | "PaymentMethod" | "BookingId" | "Status", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paymentMethod?: boolean | PaymentMethodDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    refundRequests?: boolean | Payment$refundRequestsArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      paymentMethod: Prisma.$PaymentMethodPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>
      refundRequests: Prisma.$RefundRequestsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      paymentID: string
      PaymentDate: Date
      Amount: number | null
      PaymentMethod: string
      BookingId: string
      Status: $Enums.PaymentStatus
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `paymentID`
     * const paymentWithPaymentIDOnly = await prisma.payment.findMany({ select: { paymentID: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * @param {PaymentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const payment = await prisma.payment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PaymentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Payment.
     * @param {PaymentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const payment = await prisma.payment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PaymentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paymentMethod<T extends PaymentMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentMethodDefaultArgs<ExtArgs>>): Prisma__PaymentMethodClient<$Result.GetResult<Prisma.$PaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    refundRequests<T extends Payment$refundRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$refundRequestsArgs<ExtArgs>>): Prisma__RefundRequestsClient<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly paymentID: FieldRef<"Payment", 'String'>
    readonly PaymentDate: FieldRef<"Payment", 'DateTime'>
    readonly Amount: FieldRef<"Payment", 'Float'>
    readonly PaymentMethod: FieldRef<"Payment", 'String'>
    readonly BookingId: FieldRef<"Payment", 'String'>
    readonly Status: FieldRef<"Payment", 'PaymentStatus'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment findRaw
   */
  export type PaymentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Payment aggregateRaw
   */
  export type PaymentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Payment.refundRequests
   */
  export type Payment$refundRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    where?: RefundRequestsWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleMinAggregateOutputType = {
    scheduleId: string | null
    scheduleDate: Date | null
    AgreementTime: string | null
    startDate: string | null
    provider: string | null
  }

  export type ScheduleMaxAggregateOutputType = {
    scheduleId: string | null
    scheduleDate: Date | null
    AgreementTime: string | null
    startDate: string | null
    provider: string | null
  }

  export type ScheduleCountAggregateOutputType = {
    scheduleId: number
    scheduleDate: number
    AgreementTime: number
    startDate: number
    provider: number
    _all: number
  }


  export type ScheduleMinAggregateInputType = {
    scheduleId?: true
    scheduleDate?: true
    AgreementTime?: true
    startDate?: true
    provider?: true
  }

  export type ScheduleMaxAggregateInputType = {
    scheduleId?: true
    scheduleDate?: true
    AgreementTime?: true
    startDate?: true
    provider?: true
  }

  export type ScheduleCountAggregateInputType = {
    scheduleId?: true
    scheduleDate?: true
    AgreementTime?: true
    startDate?: true
    provider?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    scheduleId: string
    scheduleDate: Date
    AgreementTime: string | null
    startDate: string | null
    provider: string
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scheduleId?: boolean
    scheduleDate?: boolean
    AgreementTime?: boolean
    startDate?: boolean
    provider?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>



  export type ScheduleSelectScalar = {
    scheduleId?: boolean
    scheduleDate?: boolean
    AgreementTime?: boolean
    startDate?: boolean
    provider?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"scheduleId" | "scheduleDate" | "AgreementTime" | "startDate" | "provider", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      scheduleId: string
      scheduleDate: Date
      AgreementTime: string | null
      startDate: string | null
      provider: string
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `scheduleId`
     * const scheduleWithScheduleIdOnly = await prisma.schedule.findMany({ select: { scheduleId: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * @param {ScheduleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const schedule = await prisma.schedule.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ScheduleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Schedule.
     * @param {ScheduleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const schedule = await prisma.schedule.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ScheduleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */ 
  interface ScheduleFieldRefs {
    readonly scheduleId: FieldRef<"Schedule", 'String'>
    readonly scheduleDate: FieldRef<"Schedule", 'DateTime'>
    readonly AgreementTime: FieldRef<"Schedule", 'String'>
    readonly startDate: FieldRef<"Schedule", 'String'>
    readonly provider: FieldRef<"Schedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule findRaw
   */
  export type ScheduleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Schedule aggregateRaw
   */
  export type ScheduleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model FeedbackRating
   */

  export type AggregateFeedbackRating = {
    _count: FeedbackRatingCountAggregateOutputType | null
    _avg: FeedbackRatingAvgAggregateOutputType | null
    _sum: FeedbackRatingSumAggregateOutputType | null
    _min: FeedbackRatingMinAggregateOutputType | null
    _max: FeedbackRatingMaxAggregateOutputType | null
  }

  export type FeedbackRatingAvgAggregateOutputType = {
    Rating: number | null
  }

  export type FeedbackRatingSumAggregateOutputType = {
    Rating: number | null
  }

  export type FeedbackRatingMinAggregateOutputType = {
    feedbackID: string | null
    feedback: string | null
    Rating: number | null
    RatingCustomer: string | null
  }

  export type FeedbackRatingMaxAggregateOutputType = {
    feedbackID: string | null
    feedback: string | null
    Rating: number | null
    RatingCustomer: string | null
  }

  export type FeedbackRatingCountAggregateOutputType = {
    feedbackID: number
    feedback: number
    Rating: number
    RatingCustomer: number
    _all: number
  }


  export type FeedbackRatingAvgAggregateInputType = {
    Rating?: true
  }

  export type FeedbackRatingSumAggregateInputType = {
    Rating?: true
  }

  export type FeedbackRatingMinAggregateInputType = {
    feedbackID?: true
    feedback?: true
    Rating?: true
    RatingCustomer?: true
  }

  export type FeedbackRatingMaxAggregateInputType = {
    feedbackID?: true
    feedback?: true
    Rating?: true
    RatingCustomer?: true
  }

  export type FeedbackRatingCountAggregateInputType = {
    feedbackID?: true
    feedback?: true
    Rating?: true
    RatingCustomer?: true
    _all?: true
  }

  export type FeedbackRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackRating to aggregate.
     */
    where?: FeedbackRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackRatings to fetch.
     */
    orderBy?: FeedbackRatingOrderByWithRelationInput | FeedbackRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedbackRatings
    **/
    _count?: true | FeedbackRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackRatingMaxAggregateInputType
  }

  export type GetFeedbackRatingAggregateType<T extends FeedbackRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackRating[P]>
      : GetScalarType<T[P], AggregateFeedbackRating[P]>
  }




  export type FeedbackRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackRatingWhereInput
    orderBy?: FeedbackRatingOrderByWithAggregationInput | FeedbackRatingOrderByWithAggregationInput[]
    by: FeedbackRatingScalarFieldEnum[] | FeedbackRatingScalarFieldEnum
    having?: FeedbackRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackRatingCountAggregateInputType | true
    _avg?: FeedbackRatingAvgAggregateInputType
    _sum?: FeedbackRatingSumAggregateInputType
    _min?: FeedbackRatingMinAggregateInputType
    _max?: FeedbackRatingMaxAggregateInputType
  }

  export type FeedbackRatingGroupByOutputType = {
    feedbackID: string
    feedback: string | null
    Rating: number | null
    RatingCustomer: string
    _count: FeedbackRatingCountAggregateOutputType | null
    _avg: FeedbackRatingAvgAggregateOutputType | null
    _sum: FeedbackRatingSumAggregateOutputType | null
    _min: FeedbackRatingMinAggregateOutputType | null
    _max: FeedbackRatingMaxAggregateOutputType | null
  }

  type GetFeedbackRatingGroupByPayload<T extends FeedbackRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackRatingGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackRatingGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    feedbackID?: boolean
    feedback?: boolean
    Rating?: boolean
    RatingCustomer?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackRating"]>



  export type FeedbackRatingSelectScalar = {
    feedbackID?: boolean
    feedback?: boolean
    Rating?: boolean
    RatingCustomer?: boolean
  }

  export type FeedbackRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"feedbackID" | "feedback" | "Rating" | "RatingCustomer", ExtArgs["result"]["feedbackRating"]>
  export type FeedbackRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $FeedbackRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedbackRating"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      feedbackID: string
      feedback: string | null
      Rating: number | null
      RatingCustomer: string
    }, ExtArgs["result"]["feedbackRating"]>
    composites: {}
  }

  type FeedbackRatingGetPayload<S extends boolean | null | undefined | FeedbackRatingDefaultArgs> = $Result.GetResult<Prisma.$FeedbackRatingPayload, S>

  type FeedbackRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeedbackRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbackRatingCountAggregateInputType | true
    }

  export interface FeedbackRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedbackRating'], meta: { name: 'FeedbackRating' } }
    /**
     * Find zero or one FeedbackRating that matches the filter.
     * @param {FeedbackRatingFindUniqueArgs} args - Arguments to find a FeedbackRating
     * @example
     * // Get one FeedbackRating
     * const feedbackRating = await prisma.feedbackRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackRatingFindUniqueArgs>(args: SelectSubset<T, FeedbackRatingFindUniqueArgs<ExtArgs>>): Prisma__FeedbackRatingClient<$Result.GetResult<Prisma.$FeedbackRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeedbackRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeedbackRatingFindUniqueOrThrowArgs} args - Arguments to find a FeedbackRating
     * @example
     * // Get one FeedbackRating
     * const feedbackRating = await prisma.feedbackRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackRatingClient<$Result.GetResult<Prisma.$FeedbackRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedbackRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRatingFindFirstArgs} args - Arguments to find a FeedbackRating
     * @example
     * // Get one FeedbackRating
     * const feedbackRating = await prisma.feedbackRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackRatingFindFirstArgs>(args?: SelectSubset<T, FeedbackRatingFindFirstArgs<ExtArgs>>): Prisma__FeedbackRatingClient<$Result.GetResult<Prisma.$FeedbackRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeedbackRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRatingFindFirstOrThrowArgs} args - Arguments to find a FeedbackRating
     * @example
     * // Get one FeedbackRating
     * const feedbackRating = await prisma.feedbackRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackRatingClient<$Result.GetResult<Prisma.$FeedbackRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeedbackRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackRatings
     * const feedbackRatings = await prisma.feedbackRating.findMany()
     * 
     * // Get first 10 FeedbackRatings
     * const feedbackRatings = await prisma.feedbackRating.findMany({ take: 10 })
     * 
     * // Only select the `feedbackID`
     * const feedbackRatingWithFeedbackIDOnly = await prisma.feedbackRating.findMany({ select: { feedbackID: true } })
     * 
     */
    findMany<T extends FeedbackRatingFindManyArgs>(args?: SelectSubset<T, FeedbackRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeedbackRating.
     * @param {FeedbackRatingCreateArgs} args - Arguments to create a FeedbackRating.
     * @example
     * // Create one FeedbackRating
     * const FeedbackRating = await prisma.feedbackRating.create({
     *   data: {
     *     // ... data to create a FeedbackRating
     *   }
     * })
     * 
     */
    create<T extends FeedbackRatingCreateArgs>(args: SelectSubset<T, FeedbackRatingCreateArgs<ExtArgs>>): Prisma__FeedbackRatingClient<$Result.GetResult<Prisma.$FeedbackRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeedbackRatings.
     * @param {FeedbackRatingCreateManyArgs} args - Arguments to create many FeedbackRatings.
     * @example
     * // Create many FeedbackRatings
     * const feedbackRating = await prisma.feedbackRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackRatingCreateManyArgs>(args?: SelectSubset<T, FeedbackRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeedbackRating.
     * @param {FeedbackRatingDeleteArgs} args - Arguments to delete one FeedbackRating.
     * @example
     * // Delete one FeedbackRating
     * const FeedbackRating = await prisma.feedbackRating.delete({
     *   where: {
     *     // ... filter to delete one FeedbackRating
     *   }
     * })
     * 
     */
    delete<T extends FeedbackRatingDeleteArgs>(args: SelectSubset<T, FeedbackRatingDeleteArgs<ExtArgs>>): Prisma__FeedbackRatingClient<$Result.GetResult<Prisma.$FeedbackRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeedbackRating.
     * @param {FeedbackRatingUpdateArgs} args - Arguments to update one FeedbackRating.
     * @example
     * // Update one FeedbackRating
     * const feedbackRating = await prisma.feedbackRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackRatingUpdateArgs>(args: SelectSubset<T, FeedbackRatingUpdateArgs<ExtArgs>>): Prisma__FeedbackRatingClient<$Result.GetResult<Prisma.$FeedbackRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeedbackRatings.
     * @param {FeedbackRatingDeleteManyArgs} args - Arguments to filter FeedbackRatings to delete.
     * @example
     * // Delete a few FeedbackRatings
     * const { count } = await prisma.feedbackRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackRatingDeleteManyArgs>(args?: SelectSubset<T, FeedbackRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackRatings
     * const feedbackRating = await prisma.feedbackRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackRatingUpdateManyArgs>(args: SelectSubset<T, FeedbackRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedbackRating.
     * @param {FeedbackRatingUpsertArgs} args - Arguments to update or create a FeedbackRating.
     * @example
     * // Update or create a FeedbackRating
     * const feedbackRating = await prisma.feedbackRating.upsert({
     *   create: {
     *     // ... data to create a FeedbackRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackRating we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackRatingUpsertArgs>(args: SelectSubset<T, FeedbackRatingUpsertArgs<ExtArgs>>): Prisma__FeedbackRatingClient<$Result.GetResult<Prisma.$FeedbackRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeedbackRatings that matches the filter.
     * @param {FeedbackRatingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const feedbackRating = await prisma.feedbackRating.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FeedbackRatingFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FeedbackRating.
     * @param {FeedbackRatingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const feedbackRating = await prisma.feedbackRating.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FeedbackRatingAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FeedbackRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRatingCountArgs} args - Arguments to filter FeedbackRatings to count.
     * @example
     * // Count the number of FeedbackRatings
     * const count = await prisma.feedbackRating.count({
     *   where: {
     *     // ... the filter for the FeedbackRatings we want to count
     *   }
     * })
    **/
    count<T extends FeedbackRatingCountArgs>(
      args?: Subset<T, FeedbackRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackRatingAggregateArgs>(args: Subset<T, FeedbackRatingAggregateArgs>): Prisma.PrismaPromise<GetFeedbackRatingAggregateType<T>>

    /**
     * Group by FeedbackRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackRatingGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedbackRating model
   */
  readonly fields: FeedbackRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedbackRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedbackRating model
   */ 
  interface FeedbackRatingFieldRefs {
    readonly feedbackID: FieldRef<"FeedbackRating", 'String'>
    readonly feedback: FieldRef<"FeedbackRating", 'String'>
    readonly Rating: FieldRef<"FeedbackRating", 'Int'>
    readonly RatingCustomer: FieldRef<"FeedbackRating", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FeedbackRating findUnique
   */
  export type FeedbackRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackRating to fetch.
     */
    where: FeedbackRatingWhereUniqueInput
  }

  /**
   * FeedbackRating findUniqueOrThrow
   */
  export type FeedbackRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackRating to fetch.
     */
    where: FeedbackRatingWhereUniqueInput
  }

  /**
   * FeedbackRating findFirst
   */
  export type FeedbackRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackRating to fetch.
     */
    where?: FeedbackRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackRatings to fetch.
     */
    orderBy?: FeedbackRatingOrderByWithRelationInput | FeedbackRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackRatings.
     */
    cursor?: FeedbackRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackRatings.
     */
    distinct?: FeedbackRatingScalarFieldEnum | FeedbackRatingScalarFieldEnum[]
  }

  /**
   * FeedbackRating findFirstOrThrow
   */
  export type FeedbackRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackRating to fetch.
     */
    where?: FeedbackRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackRatings to fetch.
     */
    orderBy?: FeedbackRatingOrderByWithRelationInput | FeedbackRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackRatings.
     */
    cursor?: FeedbackRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackRatings.
     */
    distinct?: FeedbackRatingScalarFieldEnum | FeedbackRatingScalarFieldEnum[]
  }

  /**
   * FeedbackRating findMany
   */
  export type FeedbackRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackRatings to fetch.
     */
    where?: FeedbackRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackRatings to fetch.
     */
    orderBy?: FeedbackRatingOrderByWithRelationInput | FeedbackRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedbackRatings.
     */
    cursor?: FeedbackRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackRatings.
     */
    skip?: number
    distinct?: FeedbackRatingScalarFieldEnum | FeedbackRatingScalarFieldEnum[]
  }

  /**
   * FeedbackRating create
   */
  export type FeedbackRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedbackRating.
     */
    data: XOR<FeedbackRatingCreateInput, FeedbackRatingUncheckedCreateInput>
  }

  /**
   * FeedbackRating createMany
   */
  export type FeedbackRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedbackRatings.
     */
    data: FeedbackRatingCreateManyInput | FeedbackRatingCreateManyInput[]
  }

  /**
   * FeedbackRating update
   */
  export type FeedbackRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedbackRating.
     */
    data: XOR<FeedbackRatingUpdateInput, FeedbackRatingUncheckedUpdateInput>
    /**
     * Choose, which FeedbackRating to update.
     */
    where: FeedbackRatingWhereUniqueInput
  }

  /**
   * FeedbackRating updateMany
   */
  export type FeedbackRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedbackRatings.
     */
    data: XOR<FeedbackRatingUpdateManyMutationInput, FeedbackRatingUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackRatings to update
     */
    where?: FeedbackRatingWhereInput
    /**
     * Limit how many FeedbackRatings to update.
     */
    limit?: number
  }

  /**
   * FeedbackRating upsert
   */
  export type FeedbackRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedbackRating to update in case it exists.
     */
    where: FeedbackRatingWhereUniqueInput
    /**
     * In case the FeedbackRating found by the `where` argument doesn't exist, create a new FeedbackRating with this data.
     */
    create: XOR<FeedbackRatingCreateInput, FeedbackRatingUncheckedCreateInput>
    /**
     * In case the FeedbackRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackRatingUpdateInput, FeedbackRatingUncheckedUpdateInput>
  }

  /**
   * FeedbackRating delete
   */
  export type FeedbackRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
    /**
     * Filter which FeedbackRating to delete.
     */
    where: FeedbackRatingWhereUniqueInput
  }

  /**
   * FeedbackRating deleteMany
   */
  export type FeedbackRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackRatings to delete
     */
    where?: FeedbackRatingWhereInput
    /**
     * Limit how many FeedbackRatings to delete.
     */
    limit?: number
  }

  /**
   * FeedbackRating findRaw
   */
  export type FeedbackRatingFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FeedbackRating aggregateRaw
   */
  export type FeedbackRatingAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FeedbackRating without action
   */
  export type FeedbackRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackRating
     */
    select?: FeedbackRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeedbackRating
     */
    omit?: FeedbackRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackRatingInclude<ExtArgs> | null
  }


  /**
   * Model ProviderSalary
   */

  export type AggregateProviderSalary = {
    _count: ProviderSalaryCountAggregateOutputType | null
    _avg: ProviderSalaryAvgAggregateOutputType | null
    _sum: ProviderSalarySumAggregateOutputType | null
    _min: ProviderSalaryMinAggregateOutputType | null
    _max: ProviderSalaryMaxAggregateOutputType | null
  }

  export type ProviderSalaryAvgAggregateOutputType = {
    EPF: number | null
    ETF: number | null
    totSalary: number | null
  }

  export type ProviderSalarySumAggregateOutputType = {
    EPF: number | null
    ETF: number | null
    totSalary: number | null
  }

  export type ProviderSalaryMinAggregateOutputType = {
    id: string | null
    provider: string | null
    EPF: number | null
    ETF: number | null
    totSalary: number | null
  }

  export type ProviderSalaryMaxAggregateOutputType = {
    id: string | null
    provider: string | null
    EPF: number | null
    ETF: number | null
    totSalary: number | null
  }

  export type ProviderSalaryCountAggregateOutputType = {
    id: number
    provider: number
    EPF: number
    ETF: number
    totSalary: number
    _all: number
  }


  export type ProviderSalaryAvgAggregateInputType = {
    EPF?: true
    ETF?: true
    totSalary?: true
  }

  export type ProviderSalarySumAggregateInputType = {
    EPF?: true
    ETF?: true
    totSalary?: true
  }

  export type ProviderSalaryMinAggregateInputType = {
    id?: true
    provider?: true
    EPF?: true
    ETF?: true
    totSalary?: true
  }

  export type ProviderSalaryMaxAggregateInputType = {
    id?: true
    provider?: true
    EPF?: true
    ETF?: true
    totSalary?: true
  }

  export type ProviderSalaryCountAggregateInputType = {
    id?: true
    provider?: true
    EPF?: true
    ETF?: true
    totSalary?: true
    _all?: true
  }

  export type ProviderSalaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderSalary to aggregate.
     */
    where?: ProviderSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderSalaries to fetch.
     */
    orderBy?: ProviderSalaryOrderByWithRelationInput | ProviderSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderSalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderSalaries
    **/
    _count?: true | ProviderSalaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProviderSalaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProviderSalarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderSalaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderSalaryMaxAggregateInputType
  }

  export type GetProviderSalaryAggregateType<T extends ProviderSalaryAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderSalary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderSalary[P]>
      : GetScalarType<T[P], AggregateProviderSalary[P]>
  }




  export type ProviderSalaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderSalaryWhereInput
    orderBy?: ProviderSalaryOrderByWithAggregationInput | ProviderSalaryOrderByWithAggregationInput[]
    by: ProviderSalaryScalarFieldEnum[] | ProviderSalaryScalarFieldEnum
    having?: ProviderSalaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderSalaryCountAggregateInputType | true
    _avg?: ProviderSalaryAvgAggregateInputType
    _sum?: ProviderSalarySumAggregateInputType
    _min?: ProviderSalaryMinAggregateInputType
    _max?: ProviderSalaryMaxAggregateInputType
  }

  export type ProviderSalaryGroupByOutputType = {
    id: string
    provider: string
    EPF: number | null
    ETF: number | null
    totSalary: number | null
    _count: ProviderSalaryCountAggregateOutputType | null
    _avg: ProviderSalaryAvgAggregateOutputType | null
    _sum: ProviderSalarySumAggregateOutputType | null
    _min: ProviderSalaryMinAggregateOutputType | null
    _max: ProviderSalaryMaxAggregateOutputType | null
  }

  type GetProviderSalaryGroupByPayload<T extends ProviderSalaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderSalaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderSalaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderSalaryGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderSalaryGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSalarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    EPF?: boolean
    ETF?: boolean
    totSalary?: boolean
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerSalary"]>



  export type ProviderSalarySelectScalar = {
    id?: boolean
    provider?: boolean
    EPF?: boolean
    ETF?: boolean
    totSalary?: boolean
  }

  export type ProviderSalaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider" | "EPF" | "ETF" | "totSalary", ExtArgs["result"]["providerSalary"]>
  export type ProviderSalaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceProvider?: boolean | ServiceProviderDefaultArgs<ExtArgs>
  }

  export type $ProviderSalaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderSalary"
    objects: {
      serviceProvider: Prisma.$ServiceProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: string
      EPF: number | null
      ETF: number | null
      totSalary: number | null
    }, ExtArgs["result"]["providerSalary"]>
    composites: {}
  }

  type ProviderSalaryGetPayload<S extends boolean | null | undefined | ProviderSalaryDefaultArgs> = $Result.GetResult<Prisma.$ProviderSalaryPayload, S>

  type ProviderSalaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderSalaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderSalaryCountAggregateInputType | true
    }

  export interface ProviderSalaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderSalary'], meta: { name: 'ProviderSalary' } }
    /**
     * Find zero or one ProviderSalary that matches the filter.
     * @param {ProviderSalaryFindUniqueArgs} args - Arguments to find a ProviderSalary
     * @example
     * // Get one ProviderSalary
     * const providerSalary = await prisma.providerSalary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderSalaryFindUniqueArgs>(args: SelectSubset<T, ProviderSalaryFindUniqueArgs<ExtArgs>>): Prisma__ProviderSalaryClient<$Result.GetResult<Prisma.$ProviderSalaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProviderSalary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderSalaryFindUniqueOrThrowArgs} args - Arguments to find a ProviderSalary
     * @example
     * // Get one ProviderSalary
     * const providerSalary = await prisma.providerSalary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderSalaryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderSalaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderSalaryClient<$Result.GetResult<Prisma.$ProviderSalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderSalary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderSalaryFindFirstArgs} args - Arguments to find a ProviderSalary
     * @example
     * // Get one ProviderSalary
     * const providerSalary = await prisma.providerSalary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderSalaryFindFirstArgs>(args?: SelectSubset<T, ProviderSalaryFindFirstArgs<ExtArgs>>): Prisma__ProviderSalaryClient<$Result.GetResult<Prisma.$ProviderSalaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderSalary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderSalaryFindFirstOrThrowArgs} args - Arguments to find a ProviderSalary
     * @example
     * // Get one ProviderSalary
     * const providerSalary = await prisma.providerSalary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderSalaryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderSalaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderSalaryClient<$Result.GetResult<Prisma.$ProviderSalaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProviderSalaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderSalaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderSalaries
     * const providerSalaries = await prisma.providerSalary.findMany()
     * 
     * // Get first 10 ProviderSalaries
     * const providerSalaries = await prisma.providerSalary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerSalaryWithIdOnly = await prisma.providerSalary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderSalaryFindManyArgs>(args?: SelectSubset<T, ProviderSalaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderSalaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProviderSalary.
     * @param {ProviderSalaryCreateArgs} args - Arguments to create a ProviderSalary.
     * @example
     * // Create one ProviderSalary
     * const ProviderSalary = await prisma.providerSalary.create({
     *   data: {
     *     // ... data to create a ProviderSalary
     *   }
     * })
     * 
     */
    create<T extends ProviderSalaryCreateArgs>(args: SelectSubset<T, ProviderSalaryCreateArgs<ExtArgs>>): Prisma__ProviderSalaryClient<$Result.GetResult<Prisma.$ProviderSalaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProviderSalaries.
     * @param {ProviderSalaryCreateManyArgs} args - Arguments to create many ProviderSalaries.
     * @example
     * // Create many ProviderSalaries
     * const providerSalary = await prisma.providerSalary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderSalaryCreateManyArgs>(args?: SelectSubset<T, ProviderSalaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProviderSalary.
     * @param {ProviderSalaryDeleteArgs} args - Arguments to delete one ProviderSalary.
     * @example
     * // Delete one ProviderSalary
     * const ProviderSalary = await prisma.providerSalary.delete({
     *   where: {
     *     // ... filter to delete one ProviderSalary
     *   }
     * })
     * 
     */
    delete<T extends ProviderSalaryDeleteArgs>(args: SelectSubset<T, ProviderSalaryDeleteArgs<ExtArgs>>): Prisma__ProviderSalaryClient<$Result.GetResult<Prisma.$ProviderSalaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProviderSalary.
     * @param {ProviderSalaryUpdateArgs} args - Arguments to update one ProviderSalary.
     * @example
     * // Update one ProviderSalary
     * const providerSalary = await prisma.providerSalary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderSalaryUpdateArgs>(args: SelectSubset<T, ProviderSalaryUpdateArgs<ExtArgs>>): Prisma__ProviderSalaryClient<$Result.GetResult<Prisma.$ProviderSalaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProviderSalaries.
     * @param {ProviderSalaryDeleteManyArgs} args - Arguments to filter ProviderSalaries to delete.
     * @example
     * // Delete a few ProviderSalaries
     * const { count } = await prisma.providerSalary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderSalaryDeleteManyArgs>(args?: SelectSubset<T, ProviderSalaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderSalaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderSalaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderSalaries
     * const providerSalary = await prisma.providerSalary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderSalaryUpdateManyArgs>(args: SelectSubset<T, ProviderSalaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProviderSalary.
     * @param {ProviderSalaryUpsertArgs} args - Arguments to update or create a ProviderSalary.
     * @example
     * // Update or create a ProviderSalary
     * const providerSalary = await prisma.providerSalary.upsert({
     *   create: {
     *     // ... data to create a ProviderSalary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderSalary we want to update
     *   }
     * })
     */
    upsert<T extends ProviderSalaryUpsertArgs>(args: SelectSubset<T, ProviderSalaryUpsertArgs<ExtArgs>>): Prisma__ProviderSalaryClient<$Result.GetResult<Prisma.$ProviderSalaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProviderSalaries that matches the filter.
     * @param {ProviderSalaryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const providerSalary = await prisma.providerSalary.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ProviderSalaryFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProviderSalary.
     * @param {ProviderSalaryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const providerSalary = await prisma.providerSalary.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProviderSalaryAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ProviderSalaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderSalaryCountArgs} args - Arguments to filter ProviderSalaries to count.
     * @example
     * // Count the number of ProviderSalaries
     * const count = await prisma.providerSalary.count({
     *   where: {
     *     // ... the filter for the ProviderSalaries we want to count
     *   }
     * })
    **/
    count<T extends ProviderSalaryCountArgs>(
      args?: Subset<T, ProviderSalaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderSalaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderSalary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderSalaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderSalaryAggregateArgs>(args: Subset<T, ProviderSalaryAggregateArgs>): Prisma.PrismaPromise<GetProviderSalaryAggregateType<T>>

    /**
     * Group by ProviderSalary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderSalaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderSalaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderSalaryGroupByArgs['orderBy'] }
        : { orderBy?: ProviderSalaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderSalaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderSalaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderSalary model
   */
  readonly fields: ProviderSalaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderSalary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderSalaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceProvider<T extends ServiceProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceProviderDefaultArgs<ExtArgs>>): Prisma__ServiceProviderClient<$Result.GetResult<Prisma.$ServiceProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProviderSalary model
   */ 
  interface ProviderSalaryFieldRefs {
    readonly id: FieldRef<"ProviderSalary", 'String'>
    readonly provider: FieldRef<"ProviderSalary", 'String'>
    readonly EPF: FieldRef<"ProviderSalary", 'Float'>
    readonly ETF: FieldRef<"ProviderSalary", 'Float'>
    readonly totSalary: FieldRef<"ProviderSalary", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ProviderSalary findUnique
   */
  export type ProviderSalaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
    /**
     * Filter, which ProviderSalary to fetch.
     */
    where: ProviderSalaryWhereUniqueInput
  }

  /**
   * ProviderSalary findUniqueOrThrow
   */
  export type ProviderSalaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
    /**
     * Filter, which ProviderSalary to fetch.
     */
    where: ProviderSalaryWhereUniqueInput
  }

  /**
   * ProviderSalary findFirst
   */
  export type ProviderSalaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
    /**
     * Filter, which ProviderSalary to fetch.
     */
    where?: ProviderSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderSalaries to fetch.
     */
    orderBy?: ProviderSalaryOrderByWithRelationInput | ProviderSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderSalaries.
     */
    cursor?: ProviderSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderSalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderSalaries.
     */
    distinct?: ProviderSalaryScalarFieldEnum | ProviderSalaryScalarFieldEnum[]
  }

  /**
   * ProviderSalary findFirstOrThrow
   */
  export type ProviderSalaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
    /**
     * Filter, which ProviderSalary to fetch.
     */
    where?: ProviderSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderSalaries to fetch.
     */
    orderBy?: ProviderSalaryOrderByWithRelationInput | ProviderSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderSalaries.
     */
    cursor?: ProviderSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderSalaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderSalaries.
     */
    distinct?: ProviderSalaryScalarFieldEnum | ProviderSalaryScalarFieldEnum[]
  }

  /**
   * ProviderSalary findMany
   */
  export type ProviderSalaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
    /**
     * Filter, which ProviderSalaries to fetch.
     */
    where?: ProviderSalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderSalaries to fetch.
     */
    orderBy?: ProviderSalaryOrderByWithRelationInput | ProviderSalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderSalaries.
     */
    cursor?: ProviderSalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProviderSalaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderSalaries.
     */
    skip?: number
    distinct?: ProviderSalaryScalarFieldEnum | ProviderSalaryScalarFieldEnum[]
  }

  /**
   * ProviderSalary create
   */
  export type ProviderSalaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProviderSalary.
     */
    data: XOR<ProviderSalaryCreateInput, ProviderSalaryUncheckedCreateInput>
  }

  /**
   * ProviderSalary createMany
   */
  export type ProviderSalaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderSalaries.
     */
    data: ProviderSalaryCreateManyInput | ProviderSalaryCreateManyInput[]
  }

  /**
   * ProviderSalary update
   */
  export type ProviderSalaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProviderSalary.
     */
    data: XOR<ProviderSalaryUpdateInput, ProviderSalaryUncheckedUpdateInput>
    /**
     * Choose, which ProviderSalary to update.
     */
    where: ProviderSalaryWhereUniqueInput
  }

  /**
   * ProviderSalary updateMany
   */
  export type ProviderSalaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderSalaries.
     */
    data: XOR<ProviderSalaryUpdateManyMutationInput, ProviderSalaryUncheckedUpdateManyInput>
    /**
     * Filter which ProviderSalaries to update
     */
    where?: ProviderSalaryWhereInput
    /**
     * Limit how many ProviderSalaries to update.
     */
    limit?: number
  }

  /**
   * ProviderSalary upsert
   */
  export type ProviderSalaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProviderSalary to update in case it exists.
     */
    where: ProviderSalaryWhereUniqueInput
    /**
     * In case the ProviderSalary found by the `where` argument doesn't exist, create a new ProviderSalary with this data.
     */
    create: XOR<ProviderSalaryCreateInput, ProviderSalaryUncheckedCreateInput>
    /**
     * In case the ProviderSalary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderSalaryUpdateInput, ProviderSalaryUncheckedUpdateInput>
  }

  /**
   * ProviderSalary delete
   */
  export type ProviderSalaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
    /**
     * Filter which ProviderSalary to delete.
     */
    where: ProviderSalaryWhereUniqueInput
  }

  /**
   * ProviderSalary deleteMany
   */
  export type ProviderSalaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderSalaries to delete
     */
    where?: ProviderSalaryWhereInput
    /**
     * Limit how many ProviderSalaries to delete.
     */
    limit?: number
  }

  /**
   * ProviderSalary findRaw
   */
  export type ProviderSalaryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProviderSalary aggregateRaw
   */
  export type ProviderSalaryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ProviderSalary without action
   */
  export type ProviderSalaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderSalary
     */
    select?: ProviderSalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderSalary
     */
    omit?: ProviderSalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderSalaryInclude<ExtArgs> | null
  }


  /**
   * Model InFlow
   */

  export type AggregateInFlow = {
    _count: InFlowCountAggregateOutputType | null
    _avg: InFlowAvgAggregateOutputType | null
    _sum: InFlowSumAggregateOutputType | null
    _min: InFlowMinAggregateOutputType | null
    _max: InFlowMaxAggregateOutputType | null
  }

  export type InFlowAvgAggregateOutputType = {
    Amount: number | null
  }

  export type InFlowSumAggregateOutputType = {
    Amount: number | null
  }

  export type InFlowMinAggregateOutputType = {
    id: string | null
    flowDate: Date | null
    inflowItem: string | null
    Amount: number | null
  }

  export type InFlowMaxAggregateOutputType = {
    id: string | null
    flowDate: Date | null
    inflowItem: string | null
    Amount: number | null
  }

  export type InFlowCountAggregateOutputType = {
    id: number
    flowDate: number
    inflowItem: number
    Amount: number
    _all: number
  }


  export type InFlowAvgAggregateInputType = {
    Amount?: true
  }

  export type InFlowSumAggregateInputType = {
    Amount?: true
  }

  export type InFlowMinAggregateInputType = {
    id?: true
    flowDate?: true
    inflowItem?: true
    Amount?: true
  }

  export type InFlowMaxAggregateInputType = {
    id?: true
    flowDate?: true
    inflowItem?: true
    Amount?: true
  }

  export type InFlowCountAggregateInputType = {
    id?: true
    flowDate?: true
    inflowItem?: true
    Amount?: true
    _all?: true
  }

  export type InFlowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InFlow to aggregate.
     */
    where?: InFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InFlows to fetch.
     */
    orderBy?: InFlowOrderByWithRelationInput | InFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InFlows
    **/
    _count?: true | InFlowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InFlowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InFlowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InFlowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InFlowMaxAggregateInputType
  }

  export type GetInFlowAggregateType<T extends InFlowAggregateArgs> = {
        [P in keyof T & keyof AggregateInFlow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInFlow[P]>
      : GetScalarType<T[P], AggregateInFlow[P]>
  }




  export type InFlowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InFlowWhereInput
    orderBy?: InFlowOrderByWithAggregationInput | InFlowOrderByWithAggregationInput[]
    by: InFlowScalarFieldEnum[] | InFlowScalarFieldEnum
    having?: InFlowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InFlowCountAggregateInputType | true
    _avg?: InFlowAvgAggregateInputType
    _sum?: InFlowSumAggregateInputType
    _min?: InFlowMinAggregateInputType
    _max?: InFlowMaxAggregateInputType
  }

  export type InFlowGroupByOutputType = {
    id: string
    flowDate: Date | null
    inflowItem: string | null
    Amount: number | null
    _count: InFlowCountAggregateOutputType | null
    _avg: InFlowAvgAggregateOutputType | null
    _sum: InFlowSumAggregateOutputType | null
    _min: InFlowMinAggregateOutputType | null
    _max: InFlowMaxAggregateOutputType | null
  }

  type GetInFlowGroupByPayload<T extends InFlowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InFlowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InFlowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InFlowGroupByOutputType[P]>
            : GetScalarType<T[P], InFlowGroupByOutputType[P]>
        }
      >
    >


  export type InFlowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flowDate?: boolean
    inflowItem?: boolean
    Amount?: boolean
  }, ExtArgs["result"]["inFlow"]>



  export type InFlowSelectScalar = {
    id?: boolean
    flowDate?: boolean
    inflowItem?: boolean
    Amount?: boolean
  }

  export type InFlowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "flowDate" | "inflowItem" | "Amount", ExtArgs["result"]["inFlow"]>

  export type $InFlowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InFlow"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flowDate: Date | null
      inflowItem: string | null
      Amount: number | null
    }, ExtArgs["result"]["inFlow"]>
    composites: {}
  }

  type InFlowGetPayload<S extends boolean | null | undefined | InFlowDefaultArgs> = $Result.GetResult<Prisma.$InFlowPayload, S>

  type InFlowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InFlowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InFlowCountAggregateInputType | true
    }

  export interface InFlowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InFlow'], meta: { name: 'InFlow' } }
    /**
     * Find zero or one InFlow that matches the filter.
     * @param {InFlowFindUniqueArgs} args - Arguments to find a InFlow
     * @example
     * // Get one InFlow
     * const inFlow = await prisma.inFlow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InFlowFindUniqueArgs>(args: SelectSubset<T, InFlowFindUniqueArgs<ExtArgs>>): Prisma__InFlowClient<$Result.GetResult<Prisma.$InFlowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InFlow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InFlowFindUniqueOrThrowArgs} args - Arguments to find a InFlow
     * @example
     * // Get one InFlow
     * const inFlow = await prisma.inFlow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InFlowFindUniqueOrThrowArgs>(args: SelectSubset<T, InFlowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InFlowClient<$Result.GetResult<Prisma.$InFlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InFlow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InFlowFindFirstArgs} args - Arguments to find a InFlow
     * @example
     * // Get one InFlow
     * const inFlow = await prisma.inFlow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InFlowFindFirstArgs>(args?: SelectSubset<T, InFlowFindFirstArgs<ExtArgs>>): Prisma__InFlowClient<$Result.GetResult<Prisma.$InFlowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InFlow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InFlowFindFirstOrThrowArgs} args - Arguments to find a InFlow
     * @example
     * // Get one InFlow
     * const inFlow = await prisma.inFlow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InFlowFindFirstOrThrowArgs>(args?: SelectSubset<T, InFlowFindFirstOrThrowArgs<ExtArgs>>): Prisma__InFlowClient<$Result.GetResult<Prisma.$InFlowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InFlows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InFlowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InFlows
     * const inFlows = await prisma.inFlow.findMany()
     * 
     * // Get first 10 InFlows
     * const inFlows = await prisma.inFlow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inFlowWithIdOnly = await prisma.inFlow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InFlowFindManyArgs>(args?: SelectSubset<T, InFlowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InFlowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InFlow.
     * @param {InFlowCreateArgs} args - Arguments to create a InFlow.
     * @example
     * // Create one InFlow
     * const InFlow = await prisma.inFlow.create({
     *   data: {
     *     // ... data to create a InFlow
     *   }
     * })
     * 
     */
    create<T extends InFlowCreateArgs>(args: SelectSubset<T, InFlowCreateArgs<ExtArgs>>): Prisma__InFlowClient<$Result.GetResult<Prisma.$InFlowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InFlows.
     * @param {InFlowCreateManyArgs} args - Arguments to create many InFlows.
     * @example
     * // Create many InFlows
     * const inFlow = await prisma.inFlow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InFlowCreateManyArgs>(args?: SelectSubset<T, InFlowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InFlow.
     * @param {InFlowDeleteArgs} args - Arguments to delete one InFlow.
     * @example
     * // Delete one InFlow
     * const InFlow = await prisma.inFlow.delete({
     *   where: {
     *     // ... filter to delete one InFlow
     *   }
     * })
     * 
     */
    delete<T extends InFlowDeleteArgs>(args: SelectSubset<T, InFlowDeleteArgs<ExtArgs>>): Prisma__InFlowClient<$Result.GetResult<Prisma.$InFlowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InFlow.
     * @param {InFlowUpdateArgs} args - Arguments to update one InFlow.
     * @example
     * // Update one InFlow
     * const inFlow = await prisma.inFlow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InFlowUpdateArgs>(args: SelectSubset<T, InFlowUpdateArgs<ExtArgs>>): Prisma__InFlowClient<$Result.GetResult<Prisma.$InFlowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InFlows.
     * @param {InFlowDeleteManyArgs} args - Arguments to filter InFlows to delete.
     * @example
     * // Delete a few InFlows
     * const { count } = await prisma.inFlow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InFlowDeleteManyArgs>(args?: SelectSubset<T, InFlowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InFlowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InFlows
     * const inFlow = await prisma.inFlow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InFlowUpdateManyArgs>(args: SelectSubset<T, InFlowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InFlow.
     * @param {InFlowUpsertArgs} args - Arguments to update or create a InFlow.
     * @example
     * // Update or create a InFlow
     * const inFlow = await prisma.inFlow.upsert({
     *   create: {
     *     // ... data to create a InFlow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InFlow we want to update
     *   }
     * })
     */
    upsert<T extends InFlowUpsertArgs>(args: SelectSubset<T, InFlowUpsertArgs<ExtArgs>>): Prisma__InFlowClient<$Result.GetResult<Prisma.$InFlowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InFlows that matches the filter.
     * @param {InFlowFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const inFlow = await prisma.inFlow.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: InFlowFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a InFlow.
     * @param {InFlowAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const inFlow = await prisma.inFlow.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InFlowAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of InFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InFlowCountArgs} args - Arguments to filter InFlows to count.
     * @example
     * // Count the number of InFlows
     * const count = await prisma.inFlow.count({
     *   where: {
     *     // ... the filter for the InFlows we want to count
     *   }
     * })
    **/
    count<T extends InFlowCountArgs>(
      args?: Subset<T, InFlowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InFlowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InFlowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InFlowAggregateArgs>(args: Subset<T, InFlowAggregateArgs>): Prisma.PrismaPromise<GetInFlowAggregateType<T>>

    /**
     * Group by InFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InFlowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InFlowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InFlowGroupByArgs['orderBy'] }
        : { orderBy?: InFlowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InFlowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInFlowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InFlow model
   */
  readonly fields: InFlowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InFlow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InFlowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InFlow model
   */ 
  interface InFlowFieldRefs {
    readonly id: FieldRef<"InFlow", 'String'>
    readonly flowDate: FieldRef<"InFlow", 'DateTime'>
    readonly inflowItem: FieldRef<"InFlow", 'String'>
    readonly Amount: FieldRef<"InFlow", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * InFlow findUnique
   */
  export type InFlowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InFlow
     */
    select?: InFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InFlow
     */
    omit?: InFlowOmit<ExtArgs> | null
    /**
     * Filter, which InFlow to fetch.
     */
    where: InFlowWhereUniqueInput
  }

  /**
   * InFlow findUniqueOrThrow
   */
  export type InFlowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InFlow
     */
    select?: InFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InFlow
     */
    omit?: InFlowOmit<ExtArgs> | null
    /**
     * Filter, which InFlow to fetch.
     */
    where: InFlowWhereUniqueInput
  }

  /**
   * InFlow findFirst
   */
  export type InFlowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InFlow
     */
    select?: InFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InFlow
     */
    omit?: InFlowOmit<ExtArgs> | null
    /**
     * Filter, which InFlow to fetch.
     */
    where?: InFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InFlows to fetch.
     */
    orderBy?: InFlowOrderByWithRelationInput | InFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InFlows.
     */
    cursor?: InFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InFlows.
     */
    distinct?: InFlowScalarFieldEnum | InFlowScalarFieldEnum[]
  }

  /**
   * InFlow findFirstOrThrow
   */
  export type InFlowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InFlow
     */
    select?: InFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InFlow
     */
    omit?: InFlowOmit<ExtArgs> | null
    /**
     * Filter, which InFlow to fetch.
     */
    where?: InFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InFlows to fetch.
     */
    orderBy?: InFlowOrderByWithRelationInput | InFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InFlows.
     */
    cursor?: InFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InFlows.
     */
    distinct?: InFlowScalarFieldEnum | InFlowScalarFieldEnum[]
  }

  /**
   * InFlow findMany
   */
  export type InFlowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InFlow
     */
    select?: InFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InFlow
     */
    omit?: InFlowOmit<ExtArgs> | null
    /**
     * Filter, which InFlows to fetch.
     */
    where?: InFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InFlows to fetch.
     */
    orderBy?: InFlowOrderByWithRelationInput | InFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InFlows.
     */
    cursor?: InFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InFlows.
     */
    skip?: number
    distinct?: InFlowScalarFieldEnum | InFlowScalarFieldEnum[]
  }

  /**
   * InFlow create
   */
  export type InFlowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InFlow
     */
    select?: InFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InFlow
     */
    omit?: InFlowOmit<ExtArgs> | null
    /**
     * The data needed to create a InFlow.
     */
    data?: XOR<InFlowCreateInput, InFlowUncheckedCreateInput>
  }

  /**
   * InFlow createMany
   */
  export type InFlowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InFlows.
     */
    data: InFlowCreateManyInput | InFlowCreateManyInput[]
  }

  /**
   * InFlow update
   */
  export type InFlowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InFlow
     */
    select?: InFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InFlow
     */
    omit?: InFlowOmit<ExtArgs> | null
    /**
     * The data needed to update a InFlow.
     */
    data: XOR<InFlowUpdateInput, InFlowUncheckedUpdateInput>
    /**
     * Choose, which InFlow to update.
     */
    where: InFlowWhereUniqueInput
  }

  /**
   * InFlow updateMany
   */
  export type InFlowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InFlows.
     */
    data: XOR<InFlowUpdateManyMutationInput, InFlowUncheckedUpdateManyInput>
    /**
     * Filter which InFlows to update
     */
    where?: InFlowWhereInput
    /**
     * Limit how many InFlows to update.
     */
    limit?: number
  }

  /**
   * InFlow upsert
   */
  export type InFlowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InFlow
     */
    select?: InFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InFlow
     */
    omit?: InFlowOmit<ExtArgs> | null
    /**
     * The filter to search for the InFlow to update in case it exists.
     */
    where: InFlowWhereUniqueInput
    /**
     * In case the InFlow found by the `where` argument doesn't exist, create a new InFlow with this data.
     */
    create: XOR<InFlowCreateInput, InFlowUncheckedCreateInput>
    /**
     * In case the InFlow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InFlowUpdateInput, InFlowUncheckedUpdateInput>
  }

  /**
   * InFlow delete
   */
  export type InFlowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InFlow
     */
    select?: InFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InFlow
     */
    omit?: InFlowOmit<ExtArgs> | null
    /**
     * Filter which InFlow to delete.
     */
    where: InFlowWhereUniqueInput
  }

  /**
   * InFlow deleteMany
   */
  export type InFlowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InFlows to delete
     */
    where?: InFlowWhereInput
    /**
     * Limit how many InFlows to delete.
     */
    limit?: number
  }

  /**
   * InFlow findRaw
   */
  export type InFlowFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * InFlow aggregateRaw
   */
  export type InFlowAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * InFlow without action
   */
  export type InFlowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InFlow
     */
    select?: InFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InFlow
     */
    omit?: InFlowOmit<ExtArgs> | null
  }


  /**
   * Model OutFlow
   */

  export type AggregateOutFlow = {
    _count: OutFlowCountAggregateOutputType | null
    _avg: OutFlowAvgAggregateOutputType | null
    _sum: OutFlowSumAggregateOutputType | null
    _min: OutFlowMinAggregateOutputType | null
    _max: OutFlowMaxAggregateOutputType | null
  }

  export type OutFlowAvgAggregateOutputType = {
    Amount: number | null
  }

  export type OutFlowSumAggregateOutputType = {
    Amount: number | null
  }

  export type OutFlowMinAggregateOutputType = {
    id: string | null
    OutDate: Date | null
    outFlowItem: string | null
    Amount: number | null
  }

  export type OutFlowMaxAggregateOutputType = {
    id: string | null
    OutDate: Date | null
    outFlowItem: string | null
    Amount: number | null
  }

  export type OutFlowCountAggregateOutputType = {
    id: number
    OutDate: number
    outFlowItem: number
    Amount: number
    _all: number
  }


  export type OutFlowAvgAggregateInputType = {
    Amount?: true
  }

  export type OutFlowSumAggregateInputType = {
    Amount?: true
  }

  export type OutFlowMinAggregateInputType = {
    id?: true
    OutDate?: true
    outFlowItem?: true
    Amount?: true
  }

  export type OutFlowMaxAggregateInputType = {
    id?: true
    OutDate?: true
    outFlowItem?: true
    Amount?: true
  }

  export type OutFlowCountAggregateInputType = {
    id?: true
    OutDate?: true
    outFlowItem?: true
    Amount?: true
    _all?: true
  }

  export type OutFlowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutFlow to aggregate.
     */
    where?: OutFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutFlows to fetch.
     */
    orderBy?: OutFlowOrderByWithRelationInput | OutFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutFlows
    **/
    _count?: true | OutFlowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutFlowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutFlowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutFlowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutFlowMaxAggregateInputType
  }

  export type GetOutFlowAggregateType<T extends OutFlowAggregateArgs> = {
        [P in keyof T & keyof AggregateOutFlow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutFlow[P]>
      : GetScalarType<T[P], AggregateOutFlow[P]>
  }




  export type OutFlowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutFlowWhereInput
    orderBy?: OutFlowOrderByWithAggregationInput | OutFlowOrderByWithAggregationInput[]
    by: OutFlowScalarFieldEnum[] | OutFlowScalarFieldEnum
    having?: OutFlowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutFlowCountAggregateInputType | true
    _avg?: OutFlowAvgAggregateInputType
    _sum?: OutFlowSumAggregateInputType
    _min?: OutFlowMinAggregateInputType
    _max?: OutFlowMaxAggregateInputType
  }

  export type OutFlowGroupByOutputType = {
    id: string
    OutDate: Date | null
    outFlowItem: string | null
    Amount: number | null
    _count: OutFlowCountAggregateOutputType | null
    _avg: OutFlowAvgAggregateOutputType | null
    _sum: OutFlowSumAggregateOutputType | null
    _min: OutFlowMinAggregateOutputType | null
    _max: OutFlowMaxAggregateOutputType | null
  }

  type GetOutFlowGroupByPayload<T extends OutFlowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutFlowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutFlowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutFlowGroupByOutputType[P]>
            : GetScalarType<T[P], OutFlowGroupByOutputType[P]>
        }
      >
    >


  export type OutFlowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    OutDate?: boolean
    outFlowItem?: boolean
    Amount?: boolean
  }, ExtArgs["result"]["outFlow"]>



  export type OutFlowSelectScalar = {
    id?: boolean
    OutDate?: boolean
    outFlowItem?: boolean
    Amount?: boolean
  }

  export type OutFlowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "OutDate" | "outFlowItem" | "Amount", ExtArgs["result"]["outFlow"]>

  export type $OutFlowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutFlow"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      OutDate: Date | null
      outFlowItem: string | null
      Amount: number | null
    }, ExtArgs["result"]["outFlow"]>
    composites: {}
  }

  type OutFlowGetPayload<S extends boolean | null | undefined | OutFlowDefaultArgs> = $Result.GetResult<Prisma.$OutFlowPayload, S>

  type OutFlowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutFlowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutFlowCountAggregateInputType | true
    }

  export interface OutFlowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutFlow'], meta: { name: 'OutFlow' } }
    /**
     * Find zero or one OutFlow that matches the filter.
     * @param {OutFlowFindUniqueArgs} args - Arguments to find a OutFlow
     * @example
     * // Get one OutFlow
     * const outFlow = await prisma.outFlow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutFlowFindUniqueArgs>(args: SelectSubset<T, OutFlowFindUniqueArgs<ExtArgs>>): Prisma__OutFlowClient<$Result.GetResult<Prisma.$OutFlowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OutFlow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutFlowFindUniqueOrThrowArgs} args - Arguments to find a OutFlow
     * @example
     * // Get one OutFlow
     * const outFlow = await prisma.outFlow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutFlowFindUniqueOrThrowArgs>(args: SelectSubset<T, OutFlowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutFlowClient<$Result.GetResult<Prisma.$OutFlowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutFlow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutFlowFindFirstArgs} args - Arguments to find a OutFlow
     * @example
     * // Get one OutFlow
     * const outFlow = await prisma.outFlow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutFlowFindFirstArgs>(args?: SelectSubset<T, OutFlowFindFirstArgs<ExtArgs>>): Prisma__OutFlowClient<$Result.GetResult<Prisma.$OutFlowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutFlow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutFlowFindFirstOrThrowArgs} args - Arguments to find a OutFlow
     * @example
     * // Get one OutFlow
     * const outFlow = await prisma.outFlow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutFlowFindFirstOrThrowArgs>(args?: SelectSubset<T, OutFlowFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutFlowClient<$Result.GetResult<Prisma.$OutFlowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OutFlows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutFlowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutFlows
     * const outFlows = await prisma.outFlow.findMany()
     * 
     * // Get first 10 OutFlows
     * const outFlows = await prisma.outFlow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outFlowWithIdOnly = await prisma.outFlow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutFlowFindManyArgs>(args?: SelectSubset<T, OutFlowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutFlowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OutFlow.
     * @param {OutFlowCreateArgs} args - Arguments to create a OutFlow.
     * @example
     * // Create one OutFlow
     * const OutFlow = await prisma.outFlow.create({
     *   data: {
     *     // ... data to create a OutFlow
     *   }
     * })
     * 
     */
    create<T extends OutFlowCreateArgs>(args: SelectSubset<T, OutFlowCreateArgs<ExtArgs>>): Prisma__OutFlowClient<$Result.GetResult<Prisma.$OutFlowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OutFlows.
     * @param {OutFlowCreateManyArgs} args - Arguments to create many OutFlows.
     * @example
     * // Create many OutFlows
     * const outFlow = await prisma.outFlow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutFlowCreateManyArgs>(args?: SelectSubset<T, OutFlowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OutFlow.
     * @param {OutFlowDeleteArgs} args - Arguments to delete one OutFlow.
     * @example
     * // Delete one OutFlow
     * const OutFlow = await prisma.outFlow.delete({
     *   where: {
     *     // ... filter to delete one OutFlow
     *   }
     * })
     * 
     */
    delete<T extends OutFlowDeleteArgs>(args: SelectSubset<T, OutFlowDeleteArgs<ExtArgs>>): Prisma__OutFlowClient<$Result.GetResult<Prisma.$OutFlowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OutFlow.
     * @param {OutFlowUpdateArgs} args - Arguments to update one OutFlow.
     * @example
     * // Update one OutFlow
     * const outFlow = await prisma.outFlow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutFlowUpdateArgs>(args: SelectSubset<T, OutFlowUpdateArgs<ExtArgs>>): Prisma__OutFlowClient<$Result.GetResult<Prisma.$OutFlowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OutFlows.
     * @param {OutFlowDeleteManyArgs} args - Arguments to filter OutFlows to delete.
     * @example
     * // Delete a few OutFlows
     * const { count } = await prisma.outFlow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutFlowDeleteManyArgs>(args?: SelectSubset<T, OutFlowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutFlowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutFlows
     * const outFlow = await prisma.outFlow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutFlowUpdateManyArgs>(args: SelectSubset<T, OutFlowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OutFlow.
     * @param {OutFlowUpsertArgs} args - Arguments to update or create a OutFlow.
     * @example
     * // Update or create a OutFlow
     * const outFlow = await prisma.outFlow.upsert({
     *   create: {
     *     // ... data to create a OutFlow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutFlow we want to update
     *   }
     * })
     */
    upsert<T extends OutFlowUpsertArgs>(args: SelectSubset<T, OutFlowUpsertArgs<ExtArgs>>): Prisma__OutFlowClient<$Result.GetResult<Prisma.$OutFlowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OutFlows that matches the filter.
     * @param {OutFlowFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const outFlow = await prisma.outFlow.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: OutFlowFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OutFlow.
     * @param {OutFlowAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const outFlow = await prisma.outFlow.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: OutFlowAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of OutFlows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutFlowCountArgs} args - Arguments to filter OutFlows to count.
     * @example
     * // Count the number of OutFlows
     * const count = await prisma.outFlow.count({
     *   where: {
     *     // ... the filter for the OutFlows we want to count
     *   }
     * })
    **/
    count<T extends OutFlowCountArgs>(
      args?: Subset<T, OutFlowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutFlowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutFlowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutFlowAggregateArgs>(args: Subset<T, OutFlowAggregateArgs>): Prisma.PrismaPromise<GetOutFlowAggregateType<T>>

    /**
     * Group by OutFlow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutFlowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutFlowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutFlowGroupByArgs['orderBy'] }
        : { orderBy?: OutFlowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutFlowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutFlowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutFlow model
   */
  readonly fields: OutFlowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutFlow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutFlowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutFlow model
   */ 
  interface OutFlowFieldRefs {
    readonly id: FieldRef<"OutFlow", 'String'>
    readonly OutDate: FieldRef<"OutFlow", 'DateTime'>
    readonly outFlowItem: FieldRef<"OutFlow", 'String'>
    readonly Amount: FieldRef<"OutFlow", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * OutFlow findUnique
   */
  export type OutFlowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutFlow
     */
    select?: OutFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutFlow
     */
    omit?: OutFlowOmit<ExtArgs> | null
    /**
     * Filter, which OutFlow to fetch.
     */
    where: OutFlowWhereUniqueInput
  }

  /**
   * OutFlow findUniqueOrThrow
   */
  export type OutFlowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutFlow
     */
    select?: OutFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutFlow
     */
    omit?: OutFlowOmit<ExtArgs> | null
    /**
     * Filter, which OutFlow to fetch.
     */
    where: OutFlowWhereUniqueInput
  }

  /**
   * OutFlow findFirst
   */
  export type OutFlowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutFlow
     */
    select?: OutFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutFlow
     */
    omit?: OutFlowOmit<ExtArgs> | null
    /**
     * Filter, which OutFlow to fetch.
     */
    where?: OutFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutFlows to fetch.
     */
    orderBy?: OutFlowOrderByWithRelationInput | OutFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutFlows.
     */
    cursor?: OutFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutFlows.
     */
    distinct?: OutFlowScalarFieldEnum | OutFlowScalarFieldEnum[]
  }

  /**
   * OutFlow findFirstOrThrow
   */
  export type OutFlowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutFlow
     */
    select?: OutFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutFlow
     */
    omit?: OutFlowOmit<ExtArgs> | null
    /**
     * Filter, which OutFlow to fetch.
     */
    where?: OutFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutFlows to fetch.
     */
    orderBy?: OutFlowOrderByWithRelationInput | OutFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutFlows.
     */
    cursor?: OutFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutFlows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutFlows.
     */
    distinct?: OutFlowScalarFieldEnum | OutFlowScalarFieldEnum[]
  }

  /**
   * OutFlow findMany
   */
  export type OutFlowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutFlow
     */
    select?: OutFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutFlow
     */
    omit?: OutFlowOmit<ExtArgs> | null
    /**
     * Filter, which OutFlows to fetch.
     */
    where?: OutFlowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutFlows to fetch.
     */
    orderBy?: OutFlowOrderByWithRelationInput | OutFlowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutFlows.
     */
    cursor?: OutFlowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutFlows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutFlows.
     */
    skip?: number
    distinct?: OutFlowScalarFieldEnum | OutFlowScalarFieldEnum[]
  }

  /**
   * OutFlow create
   */
  export type OutFlowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutFlow
     */
    select?: OutFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutFlow
     */
    omit?: OutFlowOmit<ExtArgs> | null
    /**
     * The data needed to create a OutFlow.
     */
    data?: XOR<OutFlowCreateInput, OutFlowUncheckedCreateInput>
  }

  /**
   * OutFlow createMany
   */
  export type OutFlowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutFlows.
     */
    data: OutFlowCreateManyInput | OutFlowCreateManyInput[]
  }

  /**
   * OutFlow update
   */
  export type OutFlowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutFlow
     */
    select?: OutFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutFlow
     */
    omit?: OutFlowOmit<ExtArgs> | null
    /**
     * The data needed to update a OutFlow.
     */
    data: XOR<OutFlowUpdateInput, OutFlowUncheckedUpdateInput>
    /**
     * Choose, which OutFlow to update.
     */
    where: OutFlowWhereUniqueInput
  }

  /**
   * OutFlow updateMany
   */
  export type OutFlowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutFlows.
     */
    data: XOR<OutFlowUpdateManyMutationInput, OutFlowUncheckedUpdateManyInput>
    /**
     * Filter which OutFlows to update
     */
    where?: OutFlowWhereInput
    /**
     * Limit how many OutFlows to update.
     */
    limit?: number
  }

  /**
   * OutFlow upsert
   */
  export type OutFlowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutFlow
     */
    select?: OutFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutFlow
     */
    omit?: OutFlowOmit<ExtArgs> | null
    /**
     * The filter to search for the OutFlow to update in case it exists.
     */
    where: OutFlowWhereUniqueInput
    /**
     * In case the OutFlow found by the `where` argument doesn't exist, create a new OutFlow with this data.
     */
    create: XOR<OutFlowCreateInput, OutFlowUncheckedCreateInput>
    /**
     * In case the OutFlow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutFlowUpdateInput, OutFlowUncheckedUpdateInput>
  }

  /**
   * OutFlow delete
   */
  export type OutFlowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutFlow
     */
    select?: OutFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutFlow
     */
    omit?: OutFlowOmit<ExtArgs> | null
    /**
     * Filter which OutFlow to delete.
     */
    where: OutFlowWhereUniqueInput
  }

  /**
   * OutFlow deleteMany
   */
  export type OutFlowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutFlows to delete
     */
    where?: OutFlowWhereInput
    /**
     * Limit how many OutFlows to delete.
     */
    limit?: number
  }

  /**
   * OutFlow findRaw
   */
  export type OutFlowFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OutFlow aggregateRaw
   */
  export type OutFlowAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * OutFlow without action
   */
  export type OutFlowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutFlow
     */
    select?: OutFlowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutFlow
     */
    omit?: OutFlowOmit<ExtArgs> | null
  }


  /**
   * Model Revenue
   */

  export type AggregateRevenue = {
    _count: RevenueCountAggregateOutputType | null
    _avg: RevenueAvgAggregateOutputType | null
    _sum: RevenueSumAggregateOutputType | null
    _min: RevenueMinAggregateOutputType | null
    _max: RevenueMaxAggregateOutputType | null
  }

  export type RevenueAvgAggregateOutputType = {
    Amount: number | null
  }

  export type RevenueSumAggregateOutputType = {
    Amount: number | null
  }

  export type RevenueMinAggregateOutputType = {
    id: string | null
    Date: Date | null
    Description: string | null
    Amount: number | null
  }

  export type RevenueMaxAggregateOutputType = {
    id: string | null
    Date: Date | null
    Description: string | null
    Amount: number | null
  }

  export type RevenueCountAggregateOutputType = {
    id: number
    Date: number
    Description: number
    Amount: number
    _all: number
  }


  export type RevenueAvgAggregateInputType = {
    Amount?: true
  }

  export type RevenueSumAggregateInputType = {
    Amount?: true
  }

  export type RevenueMinAggregateInputType = {
    id?: true
    Date?: true
    Description?: true
    Amount?: true
  }

  export type RevenueMaxAggregateInputType = {
    id?: true
    Date?: true
    Description?: true
    Amount?: true
  }

  export type RevenueCountAggregateInputType = {
    id?: true
    Date?: true
    Description?: true
    Amount?: true
    _all?: true
  }

  export type RevenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Revenue to aggregate.
     */
    where?: RevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revenues to fetch.
     */
    orderBy?: RevenueOrderByWithRelationInput | RevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Revenues
    **/
    _count?: true | RevenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RevenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RevenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevenueMaxAggregateInputType
  }

  export type GetRevenueAggregateType<T extends RevenueAggregateArgs> = {
        [P in keyof T & keyof AggregateRevenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevenue[P]>
      : GetScalarType<T[P], AggregateRevenue[P]>
  }




  export type RevenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueWhereInput
    orderBy?: RevenueOrderByWithAggregationInput | RevenueOrderByWithAggregationInput[]
    by: RevenueScalarFieldEnum[] | RevenueScalarFieldEnum
    having?: RevenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevenueCountAggregateInputType | true
    _avg?: RevenueAvgAggregateInputType
    _sum?: RevenueSumAggregateInputType
    _min?: RevenueMinAggregateInputType
    _max?: RevenueMaxAggregateInputType
  }

  export type RevenueGroupByOutputType = {
    id: string
    Date: Date
    Description: string | null
    Amount: number | null
    _count: RevenueCountAggregateOutputType | null
    _avg: RevenueAvgAggregateOutputType | null
    _sum: RevenueSumAggregateOutputType | null
    _min: RevenueMinAggregateOutputType | null
    _max: RevenueMaxAggregateOutputType | null
  }

  type GetRevenueGroupByPayload<T extends RevenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevenueGroupByOutputType[P]>
            : GetScalarType<T[P], RevenueGroupByOutputType[P]>
        }
      >
    >


  export type RevenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Date?: boolean
    Description?: boolean
    Amount?: boolean
  }, ExtArgs["result"]["revenue"]>



  export type RevenueSelectScalar = {
    id?: boolean
    Date?: boolean
    Description?: boolean
    Amount?: boolean
  }

  export type RevenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Date" | "Description" | "Amount", ExtArgs["result"]["revenue"]>

  export type $RevenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Revenue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Date: Date
      Description: string | null
      Amount: number | null
    }, ExtArgs["result"]["revenue"]>
    composites: {}
  }

  type RevenueGetPayload<S extends boolean | null | undefined | RevenueDefaultArgs> = $Result.GetResult<Prisma.$RevenuePayload, S>

  type RevenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RevenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RevenueCountAggregateInputType | true
    }

  export interface RevenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Revenue'], meta: { name: 'Revenue' } }
    /**
     * Find zero or one Revenue that matches the filter.
     * @param {RevenueFindUniqueArgs} args - Arguments to find a Revenue
     * @example
     * // Get one Revenue
     * const revenue = await prisma.revenue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevenueFindUniqueArgs>(args: SelectSubset<T, RevenueFindUniqueArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Revenue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RevenueFindUniqueOrThrowArgs} args - Arguments to find a Revenue
     * @example
     * // Get one Revenue
     * const revenue = await prisma.revenue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevenueFindUniqueOrThrowArgs>(args: SelectSubset<T, RevenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Revenue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueFindFirstArgs} args - Arguments to find a Revenue
     * @example
     * // Get one Revenue
     * const revenue = await prisma.revenue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevenueFindFirstArgs>(args?: SelectSubset<T, RevenueFindFirstArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Revenue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueFindFirstOrThrowArgs} args - Arguments to find a Revenue
     * @example
     * // Get one Revenue
     * const revenue = await prisma.revenue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevenueFindFirstOrThrowArgs>(args?: SelectSubset<T, RevenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Revenues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Revenues
     * const revenues = await prisma.revenue.findMany()
     * 
     * // Get first 10 Revenues
     * const revenues = await prisma.revenue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const revenueWithIdOnly = await prisma.revenue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RevenueFindManyArgs>(args?: SelectSubset<T, RevenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Revenue.
     * @param {RevenueCreateArgs} args - Arguments to create a Revenue.
     * @example
     * // Create one Revenue
     * const Revenue = await prisma.revenue.create({
     *   data: {
     *     // ... data to create a Revenue
     *   }
     * })
     * 
     */
    create<T extends RevenueCreateArgs>(args: SelectSubset<T, RevenueCreateArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Revenues.
     * @param {RevenueCreateManyArgs} args - Arguments to create many Revenues.
     * @example
     * // Create many Revenues
     * const revenue = await prisma.revenue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevenueCreateManyArgs>(args?: SelectSubset<T, RevenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Revenue.
     * @param {RevenueDeleteArgs} args - Arguments to delete one Revenue.
     * @example
     * // Delete one Revenue
     * const Revenue = await prisma.revenue.delete({
     *   where: {
     *     // ... filter to delete one Revenue
     *   }
     * })
     * 
     */
    delete<T extends RevenueDeleteArgs>(args: SelectSubset<T, RevenueDeleteArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Revenue.
     * @param {RevenueUpdateArgs} args - Arguments to update one Revenue.
     * @example
     * // Update one Revenue
     * const revenue = await prisma.revenue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevenueUpdateArgs>(args: SelectSubset<T, RevenueUpdateArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Revenues.
     * @param {RevenueDeleteManyArgs} args - Arguments to filter Revenues to delete.
     * @example
     * // Delete a few Revenues
     * const { count } = await prisma.revenue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevenueDeleteManyArgs>(args?: SelectSubset<T, RevenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Revenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Revenues
     * const revenue = await prisma.revenue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevenueUpdateManyArgs>(args: SelectSubset<T, RevenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Revenue.
     * @param {RevenueUpsertArgs} args - Arguments to update or create a Revenue.
     * @example
     * // Update or create a Revenue
     * const revenue = await prisma.revenue.upsert({
     *   create: {
     *     // ... data to create a Revenue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Revenue we want to update
     *   }
     * })
     */
    upsert<T extends RevenueUpsertArgs>(args: SelectSubset<T, RevenueUpsertArgs<ExtArgs>>): Prisma__RevenueClient<$Result.GetResult<Prisma.$RevenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Revenues that matches the filter.
     * @param {RevenueFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const revenue = await prisma.revenue.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RevenueFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Revenue.
     * @param {RevenueAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const revenue = await prisma.revenue.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RevenueAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Revenues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueCountArgs} args - Arguments to filter Revenues to count.
     * @example
     * // Count the number of Revenues
     * const count = await prisma.revenue.count({
     *   where: {
     *     // ... the filter for the Revenues we want to count
     *   }
     * })
    **/
    count<T extends RevenueCountArgs>(
      args?: Subset<T, RevenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Revenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevenueAggregateArgs>(args: Subset<T, RevenueAggregateArgs>): Prisma.PrismaPromise<GetRevenueAggregateType<T>>

    /**
     * Group by Revenue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevenueGroupByArgs['orderBy'] }
        : { orderBy?: RevenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Revenue model
   */
  readonly fields: RevenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Revenue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Revenue model
   */ 
  interface RevenueFieldRefs {
    readonly id: FieldRef<"Revenue", 'String'>
    readonly Date: FieldRef<"Revenue", 'DateTime'>
    readonly Description: FieldRef<"Revenue", 'String'>
    readonly Amount: FieldRef<"Revenue", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Revenue findUnique
   */
  export type RevenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revenue
     */
    omit?: RevenueOmit<ExtArgs> | null
    /**
     * Filter, which Revenue to fetch.
     */
    where: RevenueWhereUniqueInput
  }

  /**
   * Revenue findUniqueOrThrow
   */
  export type RevenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revenue
     */
    omit?: RevenueOmit<ExtArgs> | null
    /**
     * Filter, which Revenue to fetch.
     */
    where: RevenueWhereUniqueInput
  }

  /**
   * Revenue findFirst
   */
  export type RevenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revenue
     */
    omit?: RevenueOmit<ExtArgs> | null
    /**
     * Filter, which Revenue to fetch.
     */
    where?: RevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revenues to fetch.
     */
    orderBy?: RevenueOrderByWithRelationInput | RevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Revenues.
     */
    cursor?: RevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Revenues.
     */
    distinct?: RevenueScalarFieldEnum | RevenueScalarFieldEnum[]
  }

  /**
   * Revenue findFirstOrThrow
   */
  export type RevenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revenue
     */
    omit?: RevenueOmit<ExtArgs> | null
    /**
     * Filter, which Revenue to fetch.
     */
    where?: RevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revenues to fetch.
     */
    orderBy?: RevenueOrderByWithRelationInput | RevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Revenues.
     */
    cursor?: RevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revenues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Revenues.
     */
    distinct?: RevenueScalarFieldEnum | RevenueScalarFieldEnum[]
  }

  /**
   * Revenue findMany
   */
  export type RevenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revenue
     */
    omit?: RevenueOmit<ExtArgs> | null
    /**
     * Filter, which Revenues to fetch.
     */
    where?: RevenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Revenues to fetch.
     */
    orderBy?: RevenueOrderByWithRelationInput | RevenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Revenues.
     */
    cursor?: RevenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Revenues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Revenues.
     */
    skip?: number
    distinct?: RevenueScalarFieldEnum | RevenueScalarFieldEnum[]
  }

  /**
   * Revenue create
   */
  export type RevenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revenue
     */
    omit?: RevenueOmit<ExtArgs> | null
    /**
     * The data needed to create a Revenue.
     */
    data?: XOR<RevenueCreateInput, RevenueUncheckedCreateInput>
  }

  /**
   * Revenue createMany
   */
  export type RevenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Revenues.
     */
    data: RevenueCreateManyInput | RevenueCreateManyInput[]
  }

  /**
   * Revenue update
   */
  export type RevenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revenue
     */
    omit?: RevenueOmit<ExtArgs> | null
    /**
     * The data needed to update a Revenue.
     */
    data: XOR<RevenueUpdateInput, RevenueUncheckedUpdateInput>
    /**
     * Choose, which Revenue to update.
     */
    where: RevenueWhereUniqueInput
  }

  /**
   * Revenue updateMany
   */
  export type RevenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Revenues.
     */
    data: XOR<RevenueUpdateManyMutationInput, RevenueUncheckedUpdateManyInput>
    /**
     * Filter which Revenues to update
     */
    where?: RevenueWhereInput
    /**
     * Limit how many Revenues to update.
     */
    limit?: number
  }

  /**
   * Revenue upsert
   */
  export type RevenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revenue
     */
    omit?: RevenueOmit<ExtArgs> | null
    /**
     * The filter to search for the Revenue to update in case it exists.
     */
    where: RevenueWhereUniqueInput
    /**
     * In case the Revenue found by the `where` argument doesn't exist, create a new Revenue with this data.
     */
    create: XOR<RevenueCreateInput, RevenueUncheckedCreateInput>
    /**
     * In case the Revenue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevenueUpdateInput, RevenueUncheckedUpdateInput>
  }

  /**
   * Revenue delete
   */
  export type RevenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revenue
     */
    omit?: RevenueOmit<ExtArgs> | null
    /**
     * Filter which Revenue to delete.
     */
    where: RevenueWhereUniqueInput
  }

  /**
   * Revenue deleteMany
   */
  export type RevenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Revenues to delete
     */
    where?: RevenueWhereInput
    /**
     * Limit how many Revenues to delete.
     */
    limit?: number
  }

  /**
   * Revenue findRaw
   */
  export type RevenueFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Revenue aggregateRaw
   */
  export type RevenueAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Revenue without action
   */
  export type RevenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Revenue
     */
    select?: RevenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Revenue
     */
    omit?: RevenueOmit<ExtArgs> | null
  }


  /**
   * Model Expenses
   */

  export type AggregateExpenses = {
    _count: ExpensesCountAggregateOutputType | null
    _avg: ExpensesAvgAggregateOutputType | null
    _sum: ExpensesSumAggregateOutputType | null
    _min: ExpensesMinAggregateOutputType | null
    _max: ExpensesMaxAggregateOutputType | null
  }

  export type ExpensesAvgAggregateOutputType = {
    Amount: number | null
  }

  export type ExpensesSumAggregateOutputType = {
    Amount: number | null
  }

  export type ExpensesMinAggregateOutputType = {
    id: string | null
    Date: Date | null
    Expense: string | null
    Amount: number | null
  }

  export type ExpensesMaxAggregateOutputType = {
    id: string | null
    Date: Date | null
    Expense: string | null
    Amount: number | null
  }

  export type ExpensesCountAggregateOutputType = {
    id: number
    Date: number
    Expense: number
    Amount: number
    _all: number
  }


  export type ExpensesAvgAggregateInputType = {
    Amount?: true
  }

  export type ExpensesSumAggregateInputType = {
    Amount?: true
  }

  export type ExpensesMinAggregateInputType = {
    id?: true
    Date?: true
    Expense?: true
    Amount?: true
  }

  export type ExpensesMaxAggregateInputType = {
    id?: true
    Date?: true
    Expense?: true
    Amount?: true
  }

  export type ExpensesCountAggregateInputType = {
    id?: true
    Date?: true
    Expense?: true
    Amount?: true
    _all?: true
  }

  export type ExpensesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to aggregate.
     */
    where?: ExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpensesOrderByWithRelationInput | ExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpensesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpensesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpensesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpensesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpensesMaxAggregateInputType
  }

  export type GetExpensesAggregateType<T extends ExpensesAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenses[P]>
      : GetScalarType<T[P], AggregateExpenses[P]>
  }




  export type ExpensesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpensesWhereInput
    orderBy?: ExpensesOrderByWithAggregationInput | ExpensesOrderByWithAggregationInput[]
    by: ExpensesScalarFieldEnum[] | ExpensesScalarFieldEnum
    having?: ExpensesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpensesCountAggregateInputType | true
    _avg?: ExpensesAvgAggregateInputType
    _sum?: ExpensesSumAggregateInputType
    _min?: ExpensesMinAggregateInputType
    _max?: ExpensesMaxAggregateInputType
  }

  export type ExpensesGroupByOutputType = {
    id: string
    Date: Date
    Expense: string | null
    Amount: number | null
    _count: ExpensesCountAggregateOutputType | null
    _avg: ExpensesAvgAggregateOutputType | null
    _sum: ExpensesSumAggregateOutputType | null
    _min: ExpensesMinAggregateOutputType | null
    _max: ExpensesMaxAggregateOutputType | null
  }

  type GetExpensesGroupByPayload<T extends ExpensesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpensesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpensesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpensesGroupByOutputType[P]>
            : GetScalarType<T[P], ExpensesGroupByOutputType[P]>
        }
      >
    >


  export type ExpensesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Date?: boolean
    Expense?: boolean
    Amount?: boolean
  }, ExtArgs["result"]["expenses"]>



  export type ExpensesSelectScalar = {
    id?: boolean
    Date?: boolean
    Expense?: boolean
    Amount?: boolean
  }

  export type ExpensesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Date" | "Expense" | "Amount", ExtArgs["result"]["expenses"]>

  export type $ExpensesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expenses"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Date: Date
      Expense: string | null
      Amount: number | null
    }, ExtArgs["result"]["expenses"]>
    composites: {}
  }

  type ExpensesGetPayload<S extends boolean | null | undefined | ExpensesDefaultArgs> = $Result.GetResult<Prisma.$ExpensesPayload, S>

  type ExpensesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpensesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpensesCountAggregateInputType | true
    }

  export interface ExpensesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expenses'], meta: { name: 'Expenses' } }
    /**
     * Find zero or one Expenses that matches the filter.
     * @param {ExpensesFindUniqueArgs} args - Arguments to find a Expenses
     * @example
     * // Get one Expenses
     * const expenses = await prisma.expenses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpensesFindUniqueArgs>(args: SelectSubset<T, ExpensesFindUniqueArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expenses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpensesFindUniqueOrThrowArgs} args - Arguments to find a Expenses
     * @example
     * // Get one Expenses
     * const expenses = await prisma.expenses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpensesFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpensesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesFindFirstArgs} args - Arguments to find a Expenses
     * @example
     * // Get one Expenses
     * const expenses = await prisma.expenses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpensesFindFirstArgs>(args?: SelectSubset<T, ExpensesFindFirstArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expenses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesFindFirstOrThrowArgs} args - Arguments to find a Expenses
     * @example
     * // Get one Expenses
     * const expenses = await prisma.expenses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpensesFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpensesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expenses.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expenses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expensesWithIdOnly = await prisma.expenses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpensesFindManyArgs>(args?: SelectSubset<T, ExpensesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expenses.
     * @param {ExpensesCreateArgs} args - Arguments to create a Expenses.
     * @example
     * // Create one Expenses
     * const Expenses = await prisma.expenses.create({
     *   data: {
     *     // ... data to create a Expenses
     *   }
     * })
     * 
     */
    create<T extends ExpensesCreateArgs>(args: SelectSubset<T, ExpensesCreateArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpensesCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expenses = await prisma.expenses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpensesCreateManyArgs>(args?: SelectSubset<T, ExpensesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Expenses.
     * @param {ExpensesDeleteArgs} args - Arguments to delete one Expenses.
     * @example
     * // Delete one Expenses
     * const Expenses = await prisma.expenses.delete({
     *   where: {
     *     // ... filter to delete one Expenses
     *   }
     * })
     * 
     */
    delete<T extends ExpensesDeleteArgs>(args: SelectSubset<T, ExpensesDeleteArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expenses.
     * @param {ExpensesUpdateArgs} args - Arguments to update one Expenses.
     * @example
     * // Update one Expenses
     * const expenses = await prisma.expenses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpensesUpdateArgs>(args: SelectSubset<T, ExpensesUpdateArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpensesDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expenses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpensesDeleteManyArgs>(args?: SelectSubset<T, ExpensesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expenses = await prisma.expenses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpensesUpdateManyArgs>(args: SelectSubset<T, ExpensesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expenses.
     * @param {ExpensesUpsertArgs} args - Arguments to update or create a Expenses.
     * @example
     * // Update or create a Expenses
     * const expenses = await prisma.expenses.upsert({
     *   create: {
     *     // ... data to create a Expenses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expenses we want to update
     *   }
     * })
     */
    upsert<T extends ExpensesUpsertArgs>(args: SelectSubset<T, ExpensesUpsertArgs<ExtArgs>>): Prisma__ExpensesClient<$Result.GetResult<Prisma.$ExpensesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * @param {ExpensesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const expenses = await prisma.expenses.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ExpensesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Expenses.
     * @param {ExpensesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const expenses = await prisma.expenses.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ExpensesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expenses.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpensesCountArgs>(
      args?: Subset<T, ExpensesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpensesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpensesAggregateArgs>(args: Subset<T, ExpensesAggregateArgs>): Prisma.PrismaPromise<GetExpensesAggregateType<T>>

    /**
     * Group by Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpensesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpensesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpensesGroupByArgs['orderBy'] }
        : { orderBy?: ExpensesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpensesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpensesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expenses model
   */
  readonly fields: ExpensesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expenses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpensesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expenses model
   */ 
  interface ExpensesFieldRefs {
    readonly id: FieldRef<"Expenses", 'String'>
    readonly Date: FieldRef<"Expenses", 'DateTime'>
    readonly Expense: FieldRef<"Expenses", 'String'>
    readonly Amount: FieldRef<"Expenses", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Expenses findUnique
   */
  export type ExpensesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where: ExpensesWhereUniqueInput
  }

  /**
   * Expenses findUniqueOrThrow
   */
  export type ExpensesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where: ExpensesWhereUniqueInput
  }

  /**
   * Expenses findFirst
   */
  export type ExpensesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpensesOrderByWithRelationInput | ExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpensesScalarFieldEnum | ExpensesScalarFieldEnum[]
  }

  /**
   * Expenses findFirstOrThrow
   */
  export type ExpensesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpensesOrderByWithRelationInput | ExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpensesScalarFieldEnum | ExpensesScalarFieldEnum[]
  }

  /**
   * Expenses findMany
   */
  export type ExpensesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpensesOrderByWithRelationInput | ExpensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpensesScalarFieldEnum | ExpensesScalarFieldEnum[]
  }

  /**
   * Expenses create
   */
  export type ExpensesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * The data needed to create a Expenses.
     */
    data?: XOR<ExpensesCreateInput, ExpensesUncheckedCreateInput>
  }

  /**
   * Expenses createMany
   */
  export type ExpensesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpensesCreateManyInput | ExpensesCreateManyInput[]
  }

  /**
   * Expenses update
   */
  export type ExpensesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * The data needed to update a Expenses.
     */
    data: XOR<ExpensesUpdateInput, ExpensesUncheckedUpdateInput>
    /**
     * Choose, which Expenses to update.
     */
    where: ExpensesWhereUniqueInput
  }

  /**
   * Expenses updateMany
   */
  export type ExpensesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpensesUpdateManyMutationInput, ExpensesUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpensesWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expenses upsert
   */
  export type ExpensesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * The filter to search for the Expenses to update in case it exists.
     */
    where: ExpensesWhereUniqueInput
    /**
     * In case the Expenses found by the `where` argument doesn't exist, create a new Expenses with this data.
     */
    create: XOR<ExpensesCreateInput, ExpensesUncheckedCreateInput>
    /**
     * In case the Expenses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpensesUpdateInput, ExpensesUncheckedUpdateInput>
  }

  /**
   * Expenses delete
   */
  export type ExpensesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
    /**
     * Filter which Expenses to delete.
     */
    where: ExpensesWhereUniqueInput
  }

  /**
   * Expenses deleteMany
   */
  export type ExpensesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpensesWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expenses findRaw
   */
  export type ExpensesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Expenses aggregateRaw
   */
  export type ExpensesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Expenses without action
   */
  export type ExpensesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expenses
     */
    select?: ExpensesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expenses
     */
    omit?: ExpensesOmit<ExtArgs> | null
  }


  /**
   * Model Assests
   */

  export type AggregateAssests = {
    _count: AssestsCountAggregateOutputType | null
    _avg: AssestsAvgAggregateOutputType | null
    _sum: AssestsSumAggregateOutputType | null
    _min: AssestsMinAggregateOutputType | null
    _max: AssestsMaxAggregateOutputType | null
  }

  export type AssestsAvgAggregateOutputType = {
    Amount: number | null
  }

  export type AssestsSumAggregateOutputType = {
    Amount: number | null
  }

  export type AssestsMinAggregateOutputType = {
    id: string | null
    Assests: string | null
    Amount: number | null
  }

  export type AssestsMaxAggregateOutputType = {
    id: string | null
    Assests: string | null
    Amount: number | null
  }

  export type AssestsCountAggregateOutputType = {
    id: number
    Assests: number
    Amount: number
    _all: number
  }


  export type AssestsAvgAggregateInputType = {
    Amount?: true
  }

  export type AssestsSumAggregateInputType = {
    Amount?: true
  }

  export type AssestsMinAggregateInputType = {
    id?: true
    Assests?: true
    Amount?: true
  }

  export type AssestsMaxAggregateInputType = {
    id?: true
    Assests?: true
    Amount?: true
  }

  export type AssestsCountAggregateInputType = {
    id?: true
    Assests?: true
    Amount?: true
    _all?: true
  }

  export type AssestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assests to aggregate.
     */
    where?: AssestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assests to fetch.
     */
    orderBy?: AssestsOrderByWithRelationInput | AssestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assests
    **/
    _count?: true | AssestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssestsMaxAggregateInputType
  }

  export type GetAssestsAggregateType<T extends AssestsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssests[P]>
      : GetScalarType<T[P], AggregateAssests[P]>
  }




  export type AssestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssestsWhereInput
    orderBy?: AssestsOrderByWithAggregationInput | AssestsOrderByWithAggregationInput[]
    by: AssestsScalarFieldEnum[] | AssestsScalarFieldEnum
    having?: AssestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssestsCountAggregateInputType | true
    _avg?: AssestsAvgAggregateInputType
    _sum?: AssestsSumAggregateInputType
    _min?: AssestsMinAggregateInputType
    _max?: AssestsMaxAggregateInputType
  }

  export type AssestsGroupByOutputType = {
    id: string
    Assests: string | null
    Amount: number | null
    _count: AssestsCountAggregateOutputType | null
    _avg: AssestsAvgAggregateOutputType | null
    _sum: AssestsSumAggregateOutputType | null
    _min: AssestsMinAggregateOutputType | null
    _max: AssestsMaxAggregateOutputType | null
  }

  type GetAssestsGroupByPayload<T extends AssestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssestsGroupByOutputType[P]>
            : GetScalarType<T[P], AssestsGroupByOutputType[P]>
        }
      >
    >


  export type AssestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Assests?: boolean
    Amount?: boolean
  }, ExtArgs["result"]["assests"]>



  export type AssestsSelectScalar = {
    id?: boolean
    Assests?: boolean
    Amount?: boolean
  }

  export type AssestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Assests" | "Amount", ExtArgs["result"]["assests"]>

  export type $AssestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Assests: string | null
      Amount: number | null
    }, ExtArgs["result"]["assests"]>
    composites: {}
  }

  type AssestsGetPayload<S extends boolean | null | undefined | AssestsDefaultArgs> = $Result.GetResult<Prisma.$AssestsPayload, S>

  type AssestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssestsCountAggregateInputType | true
    }

  export interface AssestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assests'], meta: { name: 'Assests' } }
    /**
     * Find zero or one Assests that matches the filter.
     * @param {AssestsFindUniqueArgs} args - Arguments to find a Assests
     * @example
     * // Get one Assests
     * const assests = await prisma.assests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssestsFindUniqueArgs>(args: SelectSubset<T, AssestsFindUniqueArgs<ExtArgs>>): Prisma__AssestsClient<$Result.GetResult<Prisma.$AssestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssestsFindUniqueOrThrowArgs} args - Arguments to find a Assests
     * @example
     * // Get one Assests
     * const assests = await prisma.assests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssestsFindUniqueOrThrowArgs>(args: SelectSubset<T, AssestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssestsClient<$Result.GetResult<Prisma.$AssestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssestsFindFirstArgs} args - Arguments to find a Assests
     * @example
     * // Get one Assests
     * const assests = await prisma.assests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssestsFindFirstArgs>(args?: SelectSubset<T, AssestsFindFirstArgs<ExtArgs>>): Prisma__AssestsClient<$Result.GetResult<Prisma.$AssestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssestsFindFirstOrThrowArgs} args - Arguments to find a Assests
     * @example
     * // Get one Assests
     * const assests = await prisma.assests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssestsFindFirstOrThrowArgs>(args?: SelectSubset<T, AssestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssestsClient<$Result.GetResult<Prisma.$AssestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assests
     * const assests = await prisma.assests.findMany()
     * 
     * // Get first 10 Assests
     * const assests = await prisma.assests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assestsWithIdOnly = await prisma.assests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssestsFindManyArgs>(args?: SelectSubset<T, AssestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assests.
     * @param {AssestsCreateArgs} args - Arguments to create a Assests.
     * @example
     * // Create one Assests
     * const Assests = await prisma.assests.create({
     *   data: {
     *     // ... data to create a Assests
     *   }
     * })
     * 
     */
    create<T extends AssestsCreateArgs>(args: SelectSubset<T, AssestsCreateArgs<ExtArgs>>): Prisma__AssestsClient<$Result.GetResult<Prisma.$AssestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assests.
     * @param {AssestsCreateManyArgs} args - Arguments to create many Assests.
     * @example
     * // Create many Assests
     * const assests = await prisma.assests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssestsCreateManyArgs>(args?: SelectSubset<T, AssestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Assests.
     * @param {AssestsDeleteArgs} args - Arguments to delete one Assests.
     * @example
     * // Delete one Assests
     * const Assests = await prisma.assests.delete({
     *   where: {
     *     // ... filter to delete one Assests
     *   }
     * })
     * 
     */
    delete<T extends AssestsDeleteArgs>(args: SelectSubset<T, AssestsDeleteArgs<ExtArgs>>): Prisma__AssestsClient<$Result.GetResult<Prisma.$AssestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assests.
     * @param {AssestsUpdateArgs} args - Arguments to update one Assests.
     * @example
     * // Update one Assests
     * const assests = await prisma.assests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssestsUpdateArgs>(args: SelectSubset<T, AssestsUpdateArgs<ExtArgs>>): Prisma__AssestsClient<$Result.GetResult<Prisma.$AssestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assests.
     * @param {AssestsDeleteManyArgs} args - Arguments to filter Assests to delete.
     * @example
     * // Delete a few Assests
     * const { count } = await prisma.assests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssestsDeleteManyArgs>(args?: SelectSubset<T, AssestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assests
     * const assests = await prisma.assests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssestsUpdateManyArgs>(args: SelectSubset<T, AssestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assests.
     * @param {AssestsUpsertArgs} args - Arguments to update or create a Assests.
     * @example
     * // Update or create a Assests
     * const assests = await prisma.assests.upsert({
     *   create: {
     *     // ... data to create a Assests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assests we want to update
     *   }
     * })
     */
    upsert<T extends AssestsUpsertArgs>(args: SelectSubset<T, AssestsUpsertArgs<ExtArgs>>): Prisma__AssestsClient<$Result.GetResult<Prisma.$AssestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assests that matches the filter.
     * @param {AssestsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const assests = await prisma.assests.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AssestsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Assests.
     * @param {AssestsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const assests = await prisma.assests.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AssestsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Assests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssestsCountArgs} args - Arguments to filter Assests to count.
     * @example
     * // Count the number of Assests
     * const count = await prisma.assests.count({
     *   where: {
     *     // ... the filter for the Assests we want to count
     *   }
     * })
    **/
    count<T extends AssestsCountArgs>(
      args?: Subset<T, AssestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssestsAggregateArgs>(args: Subset<T, AssestsAggregateArgs>): Prisma.PrismaPromise<GetAssestsAggregateType<T>>

    /**
     * Group by Assests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssestsGroupByArgs['orderBy'] }
        : { orderBy?: AssestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assests model
   */
  readonly fields: AssestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assests model
   */ 
  interface AssestsFieldRefs {
    readonly id: FieldRef<"Assests", 'String'>
    readonly Assests: FieldRef<"Assests", 'String'>
    readonly Amount: FieldRef<"Assests", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Assests findUnique
   */
  export type AssestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assests
     */
    select?: AssestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assests
     */
    omit?: AssestsOmit<ExtArgs> | null
    /**
     * Filter, which Assests to fetch.
     */
    where: AssestsWhereUniqueInput
  }

  /**
   * Assests findUniqueOrThrow
   */
  export type AssestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assests
     */
    select?: AssestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assests
     */
    omit?: AssestsOmit<ExtArgs> | null
    /**
     * Filter, which Assests to fetch.
     */
    where: AssestsWhereUniqueInput
  }

  /**
   * Assests findFirst
   */
  export type AssestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assests
     */
    select?: AssestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assests
     */
    omit?: AssestsOmit<ExtArgs> | null
    /**
     * Filter, which Assests to fetch.
     */
    where?: AssestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assests to fetch.
     */
    orderBy?: AssestsOrderByWithRelationInput | AssestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assests.
     */
    cursor?: AssestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assests.
     */
    distinct?: AssestsScalarFieldEnum | AssestsScalarFieldEnum[]
  }

  /**
   * Assests findFirstOrThrow
   */
  export type AssestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assests
     */
    select?: AssestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assests
     */
    omit?: AssestsOmit<ExtArgs> | null
    /**
     * Filter, which Assests to fetch.
     */
    where?: AssestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assests to fetch.
     */
    orderBy?: AssestsOrderByWithRelationInput | AssestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assests.
     */
    cursor?: AssestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assests.
     */
    distinct?: AssestsScalarFieldEnum | AssestsScalarFieldEnum[]
  }

  /**
   * Assests findMany
   */
  export type AssestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assests
     */
    select?: AssestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assests
     */
    omit?: AssestsOmit<ExtArgs> | null
    /**
     * Filter, which Assests to fetch.
     */
    where?: AssestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assests to fetch.
     */
    orderBy?: AssestsOrderByWithRelationInput | AssestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assests.
     */
    cursor?: AssestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assests.
     */
    skip?: number
    distinct?: AssestsScalarFieldEnum | AssestsScalarFieldEnum[]
  }

  /**
   * Assests create
   */
  export type AssestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assests
     */
    select?: AssestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assests
     */
    omit?: AssestsOmit<ExtArgs> | null
    /**
     * The data needed to create a Assests.
     */
    data?: XOR<AssestsCreateInput, AssestsUncheckedCreateInput>
  }

  /**
   * Assests createMany
   */
  export type AssestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assests.
     */
    data: AssestsCreateManyInput | AssestsCreateManyInput[]
  }

  /**
   * Assests update
   */
  export type AssestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assests
     */
    select?: AssestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assests
     */
    omit?: AssestsOmit<ExtArgs> | null
    /**
     * The data needed to update a Assests.
     */
    data: XOR<AssestsUpdateInput, AssestsUncheckedUpdateInput>
    /**
     * Choose, which Assests to update.
     */
    where: AssestsWhereUniqueInput
  }

  /**
   * Assests updateMany
   */
  export type AssestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assests.
     */
    data: XOR<AssestsUpdateManyMutationInput, AssestsUncheckedUpdateManyInput>
    /**
     * Filter which Assests to update
     */
    where?: AssestsWhereInput
    /**
     * Limit how many Assests to update.
     */
    limit?: number
  }

  /**
   * Assests upsert
   */
  export type AssestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assests
     */
    select?: AssestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assests
     */
    omit?: AssestsOmit<ExtArgs> | null
    /**
     * The filter to search for the Assests to update in case it exists.
     */
    where: AssestsWhereUniqueInput
    /**
     * In case the Assests found by the `where` argument doesn't exist, create a new Assests with this data.
     */
    create: XOR<AssestsCreateInput, AssestsUncheckedCreateInput>
    /**
     * In case the Assests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssestsUpdateInput, AssestsUncheckedUpdateInput>
  }

  /**
   * Assests delete
   */
  export type AssestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assests
     */
    select?: AssestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assests
     */
    omit?: AssestsOmit<ExtArgs> | null
    /**
     * Filter which Assests to delete.
     */
    where: AssestsWhereUniqueInput
  }

  /**
   * Assests deleteMany
   */
  export type AssestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assests to delete
     */
    where?: AssestsWhereInput
    /**
     * Limit how many Assests to delete.
     */
    limit?: number
  }

  /**
   * Assests findRaw
   */
  export type AssestsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Assests aggregateRaw
   */
  export type AssestsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Assests without action
   */
  export type AssestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assests
     */
    select?: AssestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assests
     */
    omit?: AssestsOmit<ExtArgs> | null
  }


  /**
   * Model Liability
   */

  export type AggregateLiability = {
    _count: LiabilityCountAggregateOutputType | null
    _avg: LiabilityAvgAggregateOutputType | null
    _sum: LiabilitySumAggregateOutputType | null
    _min: LiabilityMinAggregateOutputType | null
    _max: LiabilityMaxAggregateOutputType | null
  }

  export type LiabilityAvgAggregateOutputType = {
    Amount: number | null
  }

  export type LiabilitySumAggregateOutputType = {
    Amount: number | null
  }

  export type LiabilityMinAggregateOutputType = {
    id: string | null
    Liability: string | null
    Amount: number | null
  }

  export type LiabilityMaxAggregateOutputType = {
    id: string | null
    Liability: string | null
    Amount: number | null
  }

  export type LiabilityCountAggregateOutputType = {
    id: number
    Liability: number
    Amount: number
    _all: number
  }


  export type LiabilityAvgAggregateInputType = {
    Amount?: true
  }

  export type LiabilitySumAggregateInputType = {
    Amount?: true
  }

  export type LiabilityMinAggregateInputType = {
    id?: true
    Liability?: true
    Amount?: true
  }

  export type LiabilityMaxAggregateInputType = {
    id?: true
    Liability?: true
    Amount?: true
  }

  export type LiabilityCountAggregateInputType = {
    id?: true
    Liability?: true
    Amount?: true
    _all?: true
  }

  export type LiabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Liability to aggregate.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Liabilities
    **/
    _count?: true | LiabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LiabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LiabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LiabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LiabilityMaxAggregateInputType
  }

  export type GetLiabilityAggregateType<T extends LiabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateLiability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLiability[P]>
      : GetScalarType<T[P], AggregateLiability[P]>
  }




  export type LiabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LiabilityWhereInput
    orderBy?: LiabilityOrderByWithAggregationInput | LiabilityOrderByWithAggregationInput[]
    by: LiabilityScalarFieldEnum[] | LiabilityScalarFieldEnum
    having?: LiabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LiabilityCountAggregateInputType | true
    _avg?: LiabilityAvgAggregateInputType
    _sum?: LiabilitySumAggregateInputType
    _min?: LiabilityMinAggregateInputType
    _max?: LiabilityMaxAggregateInputType
  }

  export type LiabilityGroupByOutputType = {
    id: string
    Liability: string | null
    Amount: number | null
    _count: LiabilityCountAggregateOutputType | null
    _avg: LiabilityAvgAggregateOutputType | null
    _sum: LiabilitySumAggregateOutputType | null
    _min: LiabilityMinAggregateOutputType | null
    _max: LiabilityMaxAggregateOutputType | null
  }

  type GetLiabilityGroupByPayload<T extends LiabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LiabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LiabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LiabilityGroupByOutputType[P]>
            : GetScalarType<T[P], LiabilityGroupByOutputType[P]>
        }
      >
    >


  export type LiabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Liability?: boolean
    Amount?: boolean
  }, ExtArgs["result"]["liability"]>



  export type LiabilitySelectScalar = {
    id?: boolean
    Liability?: boolean
    Amount?: boolean
  }

  export type LiabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "Liability" | "Amount", ExtArgs["result"]["liability"]>

  export type $LiabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Liability"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      Liability: string | null
      Amount: number | null
    }, ExtArgs["result"]["liability"]>
    composites: {}
  }

  type LiabilityGetPayload<S extends boolean | null | undefined | LiabilityDefaultArgs> = $Result.GetResult<Prisma.$LiabilityPayload, S>

  type LiabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LiabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LiabilityCountAggregateInputType | true
    }

  export interface LiabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Liability'], meta: { name: 'Liability' } }
    /**
     * Find zero or one Liability that matches the filter.
     * @param {LiabilityFindUniqueArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LiabilityFindUniqueArgs>(args: SelectSubset<T, LiabilityFindUniqueArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Liability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LiabilityFindUniqueOrThrowArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LiabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, LiabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Liability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityFindFirstArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LiabilityFindFirstArgs>(args?: SelectSubset<T, LiabilityFindFirstArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Liability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityFindFirstOrThrowArgs} args - Arguments to find a Liability
     * @example
     * // Get one Liability
     * const liability = await prisma.liability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LiabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, LiabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Liabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Liabilities
     * const liabilities = await prisma.liability.findMany()
     * 
     * // Get first 10 Liabilities
     * const liabilities = await prisma.liability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const liabilityWithIdOnly = await prisma.liability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LiabilityFindManyArgs>(args?: SelectSubset<T, LiabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Liability.
     * @param {LiabilityCreateArgs} args - Arguments to create a Liability.
     * @example
     * // Create one Liability
     * const Liability = await prisma.liability.create({
     *   data: {
     *     // ... data to create a Liability
     *   }
     * })
     * 
     */
    create<T extends LiabilityCreateArgs>(args: SelectSubset<T, LiabilityCreateArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Liabilities.
     * @param {LiabilityCreateManyArgs} args - Arguments to create many Liabilities.
     * @example
     * // Create many Liabilities
     * const liability = await prisma.liability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LiabilityCreateManyArgs>(args?: SelectSubset<T, LiabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Liability.
     * @param {LiabilityDeleteArgs} args - Arguments to delete one Liability.
     * @example
     * // Delete one Liability
     * const Liability = await prisma.liability.delete({
     *   where: {
     *     // ... filter to delete one Liability
     *   }
     * })
     * 
     */
    delete<T extends LiabilityDeleteArgs>(args: SelectSubset<T, LiabilityDeleteArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Liability.
     * @param {LiabilityUpdateArgs} args - Arguments to update one Liability.
     * @example
     * // Update one Liability
     * const liability = await prisma.liability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LiabilityUpdateArgs>(args: SelectSubset<T, LiabilityUpdateArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Liabilities.
     * @param {LiabilityDeleteManyArgs} args - Arguments to filter Liabilities to delete.
     * @example
     * // Delete a few Liabilities
     * const { count } = await prisma.liability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LiabilityDeleteManyArgs>(args?: SelectSubset<T, LiabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Liabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Liabilities
     * const liability = await prisma.liability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LiabilityUpdateManyArgs>(args: SelectSubset<T, LiabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Liability.
     * @param {LiabilityUpsertArgs} args - Arguments to update or create a Liability.
     * @example
     * // Update or create a Liability
     * const liability = await prisma.liability.upsert({
     *   create: {
     *     // ... data to create a Liability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Liability we want to update
     *   }
     * })
     */
    upsert<T extends LiabilityUpsertArgs>(args: SelectSubset<T, LiabilityUpsertArgs<ExtArgs>>): Prisma__LiabilityClient<$Result.GetResult<Prisma.$LiabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Liabilities that matches the filter.
     * @param {LiabilityFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const liability = await prisma.liability.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LiabilityFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Liability.
     * @param {LiabilityAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const liability = await prisma.liability.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LiabilityAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Liabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityCountArgs} args - Arguments to filter Liabilities to count.
     * @example
     * // Count the number of Liabilities
     * const count = await prisma.liability.count({
     *   where: {
     *     // ... the filter for the Liabilities we want to count
     *   }
     * })
    **/
    count<T extends LiabilityCountArgs>(
      args?: Subset<T, LiabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LiabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Liability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LiabilityAggregateArgs>(args: Subset<T, LiabilityAggregateArgs>): Prisma.PrismaPromise<GetLiabilityAggregateType<T>>

    /**
     * Group by Liability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LiabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LiabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LiabilityGroupByArgs['orderBy'] }
        : { orderBy?: LiabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LiabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLiabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Liability model
   */
  readonly fields: LiabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Liability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LiabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Liability model
   */ 
  interface LiabilityFieldRefs {
    readonly id: FieldRef<"Liability", 'String'>
    readonly Liability: FieldRef<"Liability", 'String'>
    readonly Amount: FieldRef<"Liability", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Liability findUnique
   */
  export type LiabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability findUniqueOrThrow
   */
  export type LiabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability findFirst
   */
  export type LiabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Liabilities.
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Liabilities.
     */
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * Liability findFirstOrThrow
   */
  export type LiabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Filter, which Liability to fetch.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Liabilities.
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Liabilities.
     */
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * Liability findMany
   */
  export type LiabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Filter, which Liabilities to fetch.
     */
    where?: LiabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Liabilities to fetch.
     */
    orderBy?: LiabilityOrderByWithRelationInput | LiabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Liabilities.
     */
    cursor?: LiabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Liabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Liabilities.
     */
    skip?: number
    distinct?: LiabilityScalarFieldEnum | LiabilityScalarFieldEnum[]
  }

  /**
   * Liability create
   */
  export type LiabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * The data needed to create a Liability.
     */
    data?: XOR<LiabilityCreateInput, LiabilityUncheckedCreateInput>
  }

  /**
   * Liability createMany
   */
  export type LiabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Liabilities.
     */
    data: LiabilityCreateManyInput | LiabilityCreateManyInput[]
  }

  /**
   * Liability update
   */
  export type LiabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * The data needed to update a Liability.
     */
    data: XOR<LiabilityUpdateInput, LiabilityUncheckedUpdateInput>
    /**
     * Choose, which Liability to update.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability updateMany
   */
  export type LiabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Liabilities.
     */
    data: XOR<LiabilityUpdateManyMutationInput, LiabilityUncheckedUpdateManyInput>
    /**
     * Filter which Liabilities to update
     */
    where?: LiabilityWhereInput
    /**
     * Limit how many Liabilities to update.
     */
    limit?: number
  }

  /**
   * Liability upsert
   */
  export type LiabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * The filter to search for the Liability to update in case it exists.
     */
    where: LiabilityWhereUniqueInput
    /**
     * In case the Liability found by the `where` argument doesn't exist, create a new Liability with this data.
     */
    create: XOR<LiabilityCreateInput, LiabilityUncheckedCreateInput>
    /**
     * In case the Liability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LiabilityUpdateInput, LiabilityUncheckedUpdateInput>
  }

  /**
   * Liability delete
   */
  export type LiabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
    /**
     * Filter which Liability to delete.
     */
    where: LiabilityWhereUniqueInput
  }

  /**
   * Liability deleteMany
   */
  export type LiabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Liabilities to delete
     */
    where?: LiabilityWhereInput
    /**
     * Limit how many Liabilities to delete.
     */
    limit?: number
  }

  /**
   * Liability findRaw
   */
  export type LiabilityFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Liability aggregateRaw
   */
  export type LiabilityAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Liability without action
   */
  export type LiabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Liability
     */
    select?: LiabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Liability
     */
    omit?: LiabilityOmit<ExtArgs> | null
  }


  /**
   * Model profitLoss
   */

  export type AggregateProfitLoss = {
    _count: ProfitLossCountAggregateOutputType | null
    _avg: ProfitLossAvgAggregateOutputType | null
    _sum: ProfitLossSumAggregateOutputType | null
    _min: ProfitLossMinAggregateOutputType | null
    _max: ProfitLossMaxAggregateOutputType | null
  }

  export type ProfitLossAvgAggregateOutputType = {
    totalrevenue: number | null
    totalExpence: number | null
    NetAmount: number | null
  }

  export type ProfitLossSumAggregateOutputType = {
    totalrevenue: number | null
    totalExpence: number | null
    NetAmount: number | null
  }

  export type ProfitLossMinAggregateOutputType = {
    id: string | null
    month: Date | null
    totalrevenue: number | null
    totalExpence: number | null
    NetAmount: number | null
  }

  export type ProfitLossMaxAggregateOutputType = {
    id: string | null
    month: Date | null
    totalrevenue: number | null
    totalExpence: number | null
    NetAmount: number | null
  }

  export type ProfitLossCountAggregateOutputType = {
    id: number
    month: number
    totalrevenue: number
    totalExpence: number
    NetAmount: number
    _all: number
  }


  export type ProfitLossAvgAggregateInputType = {
    totalrevenue?: true
    totalExpence?: true
    NetAmount?: true
  }

  export type ProfitLossSumAggregateInputType = {
    totalrevenue?: true
    totalExpence?: true
    NetAmount?: true
  }

  export type ProfitLossMinAggregateInputType = {
    id?: true
    month?: true
    totalrevenue?: true
    totalExpence?: true
    NetAmount?: true
  }

  export type ProfitLossMaxAggregateInputType = {
    id?: true
    month?: true
    totalrevenue?: true
    totalExpence?: true
    NetAmount?: true
  }

  export type ProfitLossCountAggregateInputType = {
    id?: true
    month?: true
    totalrevenue?: true
    totalExpence?: true
    NetAmount?: true
    _all?: true
  }

  export type ProfitLossAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profitLoss to aggregate.
     */
    where?: profitLossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profitLosses to fetch.
     */
    orderBy?: profitLossOrderByWithRelationInput | profitLossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profitLossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profitLosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profitLosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profitLosses
    **/
    _count?: true | ProfitLossCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfitLossAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfitLossSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfitLossMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfitLossMaxAggregateInputType
  }

  export type GetProfitLossAggregateType<T extends ProfitLossAggregateArgs> = {
        [P in keyof T & keyof AggregateProfitLoss]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfitLoss[P]>
      : GetScalarType<T[P], AggregateProfitLoss[P]>
  }




  export type profitLossGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profitLossWhereInput
    orderBy?: profitLossOrderByWithAggregationInput | profitLossOrderByWithAggregationInput[]
    by: ProfitLossScalarFieldEnum[] | ProfitLossScalarFieldEnum
    having?: profitLossScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfitLossCountAggregateInputType | true
    _avg?: ProfitLossAvgAggregateInputType
    _sum?: ProfitLossSumAggregateInputType
    _min?: ProfitLossMinAggregateInputType
    _max?: ProfitLossMaxAggregateInputType
  }

  export type ProfitLossGroupByOutputType = {
    id: string
    month: Date | null
    totalrevenue: number | null
    totalExpence: number | null
    NetAmount: number | null
    _count: ProfitLossCountAggregateOutputType | null
    _avg: ProfitLossAvgAggregateOutputType | null
    _sum: ProfitLossSumAggregateOutputType | null
    _min: ProfitLossMinAggregateOutputType | null
    _max: ProfitLossMaxAggregateOutputType | null
  }

  type GetProfitLossGroupByPayload<T extends profitLossGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfitLossGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfitLossGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfitLossGroupByOutputType[P]>
            : GetScalarType<T[P], ProfitLossGroupByOutputType[P]>
        }
      >
    >


  export type profitLossSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    totalrevenue?: boolean
    totalExpence?: boolean
    NetAmount?: boolean
  }, ExtArgs["result"]["profitLoss"]>



  export type profitLossSelectScalar = {
    id?: boolean
    month?: boolean
    totalrevenue?: boolean
    totalExpence?: boolean
    NetAmount?: boolean
  }

  export type profitLossOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "totalrevenue" | "totalExpence" | "NetAmount", ExtArgs["result"]["profitLoss"]>

  export type $profitLossPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profitLoss"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      month: Date | null
      totalrevenue: number | null
      totalExpence: number | null
      NetAmount: number | null
    }, ExtArgs["result"]["profitLoss"]>
    composites: {}
  }

  type profitLossGetPayload<S extends boolean | null | undefined | profitLossDefaultArgs> = $Result.GetResult<Prisma.$profitLossPayload, S>

  type profitLossCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<profitLossFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfitLossCountAggregateInputType | true
    }

  export interface profitLossDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profitLoss'], meta: { name: 'profitLoss' } }
    /**
     * Find zero or one ProfitLoss that matches the filter.
     * @param {profitLossFindUniqueArgs} args - Arguments to find a ProfitLoss
     * @example
     * // Get one ProfitLoss
     * const profitLoss = await prisma.profitLoss.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends profitLossFindUniqueArgs>(args: SelectSubset<T, profitLossFindUniqueArgs<ExtArgs>>): Prisma__profitLossClient<$Result.GetResult<Prisma.$profitLossPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfitLoss that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {profitLossFindUniqueOrThrowArgs} args - Arguments to find a ProfitLoss
     * @example
     * // Get one ProfitLoss
     * const profitLoss = await prisma.profitLoss.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends profitLossFindUniqueOrThrowArgs>(args: SelectSubset<T, profitLossFindUniqueOrThrowArgs<ExtArgs>>): Prisma__profitLossClient<$Result.GetResult<Prisma.$profitLossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfitLoss that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profitLossFindFirstArgs} args - Arguments to find a ProfitLoss
     * @example
     * // Get one ProfitLoss
     * const profitLoss = await prisma.profitLoss.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends profitLossFindFirstArgs>(args?: SelectSubset<T, profitLossFindFirstArgs<ExtArgs>>): Prisma__profitLossClient<$Result.GetResult<Prisma.$profitLossPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfitLoss that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profitLossFindFirstOrThrowArgs} args - Arguments to find a ProfitLoss
     * @example
     * // Get one ProfitLoss
     * const profitLoss = await prisma.profitLoss.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends profitLossFindFirstOrThrowArgs>(args?: SelectSubset<T, profitLossFindFirstOrThrowArgs<ExtArgs>>): Prisma__profitLossClient<$Result.GetResult<Prisma.$profitLossPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfitLosses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profitLossFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfitLosses
     * const profitLosses = await prisma.profitLoss.findMany()
     * 
     * // Get first 10 ProfitLosses
     * const profitLosses = await prisma.profitLoss.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profitLossWithIdOnly = await prisma.profitLoss.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends profitLossFindManyArgs>(args?: SelectSubset<T, profitLossFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profitLossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfitLoss.
     * @param {profitLossCreateArgs} args - Arguments to create a ProfitLoss.
     * @example
     * // Create one ProfitLoss
     * const ProfitLoss = await prisma.profitLoss.create({
     *   data: {
     *     // ... data to create a ProfitLoss
     *   }
     * })
     * 
     */
    create<T extends profitLossCreateArgs>(args: SelectSubset<T, profitLossCreateArgs<ExtArgs>>): Prisma__profitLossClient<$Result.GetResult<Prisma.$profitLossPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfitLosses.
     * @param {profitLossCreateManyArgs} args - Arguments to create many ProfitLosses.
     * @example
     * // Create many ProfitLosses
     * const profitLoss = await prisma.profitLoss.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends profitLossCreateManyArgs>(args?: SelectSubset<T, profitLossCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProfitLoss.
     * @param {profitLossDeleteArgs} args - Arguments to delete one ProfitLoss.
     * @example
     * // Delete one ProfitLoss
     * const ProfitLoss = await prisma.profitLoss.delete({
     *   where: {
     *     // ... filter to delete one ProfitLoss
     *   }
     * })
     * 
     */
    delete<T extends profitLossDeleteArgs>(args: SelectSubset<T, profitLossDeleteArgs<ExtArgs>>): Prisma__profitLossClient<$Result.GetResult<Prisma.$profitLossPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfitLoss.
     * @param {profitLossUpdateArgs} args - Arguments to update one ProfitLoss.
     * @example
     * // Update one ProfitLoss
     * const profitLoss = await prisma.profitLoss.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends profitLossUpdateArgs>(args: SelectSubset<T, profitLossUpdateArgs<ExtArgs>>): Prisma__profitLossClient<$Result.GetResult<Prisma.$profitLossPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfitLosses.
     * @param {profitLossDeleteManyArgs} args - Arguments to filter ProfitLosses to delete.
     * @example
     * // Delete a few ProfitLosses
     * const { count } = await prisma.profitLoss.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends profitLossDeleteManyArgs>(args?: SelectSubset<T, profitLossDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfitLosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profitLossUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfitLosses
     * const profitLoss = await prisma.profitLoss.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends profitLossUpdateManyArgs>(args: SelectSubset<T, profitLossUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfitLoss.
     * @param {profitLossUpsertArgs} args - Arguments to update or create a ProfitLoss.
     * @example
     * // Update or create a ProfitLoss
     * const profitLoss = await prisma.profitLoss.upsert({
     *   create: {
     *     // ... data to create a ProfitLoss
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfitLoss we want to update
     *   }
     * })
     */
    upsert<T extends profitLossUpsertArgs>(args: SelectSubset<T, profitLossUpsertArgs<ExtArgs>>): Prisma__profitLossClient<$Result.GetResult<Prisma.$profitLossPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfitLosses that matches the filter.
     * @param {profitLossFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const profitLoss = await prisma.profitLoss.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: profitLossFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ProfitLoss.
     * @param {profitLossAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const profitLoss = await prisma.profitLoss.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: profitLossAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ProfitLosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profitLossCountArgs} args - Arguments to filter ProfitLosses to count.
     * @example
     * // Count the number of ProfitLosses
     * const count = await prisma.profitLoss.count({
     *   where: {
     *     // ... the filter for the ProfitLosses we want to count
     *   }
     * })
    **/
    count<T extends profitLossCountArgs>(
      args?: Subset<T, profitLossCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfitLossCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfitLoss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfitLossAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfitLossAggregateArgs>(args: Subset<T, ProfitLossAggregateArgs>): Prisma.PrismaPromise<GetProfitLossAggregateType<T>>

    /**
     * Group by ProfitLoss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profitLossGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profitLossGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profitLossGroupByArgs['orderBy'] }
        : { orderBy?: profitLossGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profitLossGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfitLossGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profitLoss model
   */
  readonly fields: profitLossFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profitLoss.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profitLossClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the profitLoss model
   */ 
  interface profitLossFieldRefs {
    readonly id: FieldRef<"profitLoss", 'String'>
    readonly month: FieldRef<"profitLoss", 'DateTime'>
    readonly totalrevenue: FieldRef<"profitLoss", 'Float'>
    readonly totalExpence: FieldRef<"profitLoss", 'Float'>
    readonly NetAmount: FieldRef<"profitLoss", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * profitLoss findUnique
   */
  export type profitLossFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profitLoss
     */
    select?: profitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profitLoss
     */
    omit?: profitLossOmit<ExtArgs> | null
    /**
     * Filter, which profitLoss to fetch.
     */
    where: profitLossWhereUniqueInput
  }

  /**
   * profitLoss findUniqueOrThrow
   */
  export type profitLossFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profitLoss
     */
    select?: profitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profitLoss
     */
    omit?: profitLossOmit<ExtArgs> | null
    /**
     * Filter, which profitLoss to fetch.
     */
    where: profitLossWhereUniqueInput
  }

  /**
   * profitLoss findFirst
   */
  export type profitLossFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profitLoss
     */
    select?: profitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profitLoss
     */
    omit?: profitLossOmit<ExtArgs> | null
    /**
     * Filter, which profitLoss to fetch.
     */
    where?: profitLossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profitLosses to fetch.
     */
    orderBy?: profitLossOrderByWithRelationInput | profitLossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profitLosses.
     */
    cursor?: profitLossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profitLosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profitLosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profitLosses.
     */
    distinct?: ProfitLossScalarFieldEnum | ProfitLossScalarFieldEnum[]
  }

  /**
   * profitLoss findFirstOrThrow
   */
  export type profitLossFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profitLoss
     */
    select?: profitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profitLoss
     */
    omit?: profitLossOmit<ExtArgs> | null
    /**
     * Filter, which profitLoss to fetch.
     */
    where?: profitLossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profitLosses to fetch.
     */
    orderBy?: profitLossOrderByWithRelationInput | profitLossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profitLosses.
     */
    cursor?: profitLossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profitLosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profitLosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profitLosses.
     */
    distinct?: ProfitLossScalarFieldEnum | ProfitLossScalarFieldEnum[]
  }

  /**
   * profitLoss findMany
   */
  export type profitLossFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profitLoss
     */
    select?: profitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profitLoss
     */
    omit?: profitLossOmit<ExtArgs> | null
    /**
     * Filter, which profitLosses to fetch.
     */
    where?: profitLossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profitLosses to fetch.
     */
    orderBy?: profitLossOrderByWithRelationInput | profitLossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profitLosses.
     */
    cursor?: profitLossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profitLosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profitLosses.
     */
    skip?: number
    distinct?: ProfitLossScalarFieldEnum | ProfitLossScalarFieldEnum[]
  }

  /**
   * profitLoss create
   */
  export type profitLossCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profitLoss
     */
    select?: profitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profitLoss
     */
    omit?: profitLossOmit<ExtArgs> | null
    /**
     * The data needed to create a profitLoss.
     */
    data?: XOR<profitLossCreateInput, profitLossUncheckedCreateInput>
  }

  /**
   * profitLoss createMany
   */
  export type profitLossCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profitLosses.
     */
    data: profitLossCreateManyInput | profitLossCreateManyInput[]
  }

  /**
   * profitLoss update
   */
  export type profitLossUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profitLoss
     */
    select?: profitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profitLoss
     */
    omit?: profitLossOmit<ExtArgs> | null
    /**
     * The data needed to update a profitLoss.
     */
    data: XOR<profitLossUpdateInput, profitLossUncheckedUpdateInput>
    /**
     * Choose, which profitLoss to update.
     */
    where: profitLossWhereUniqueInput
  }

  /**
   * profitLoss updateMany
   */
  export type profitLossUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profitLosses.
     */
    data: XOR<profitLossUpdateManyMutationInput, profitLossUncheckedUpdateManyInput>
    /**
     * Filter which profitLosses to update
     */
    where?: profitLossWhereInput
    /**
     * Limit how many profitLosses to update.
     */
    limit?: number
  }

  /**
   * profitLoss upsert
   */
  export type profitLossUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profitLoss
     */
    select?: profitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profitLoss
     */
    omit?: profitLossOmit<ExtArgs> | null
    /**
     * The filter to search for the profitLoss to update in case it exists.
     */
    where: profitLossWhereUniqueInput
    /**
     * In case the profitLoss found by the `where` argument doesn't exist, create a new profitLoss with this data.
     */
    create: XOR<profitLossCreateInput, profitLossUncheckedCreateInput>
    /**
     * In case the profitLoss was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profitLossUpdateInput, profitLossUncheckedUpdateInput>
  }

  /**
   * profitLoss delete
   */
  export type profitLossDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profitLoss
     */
    select?: profitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profitLoss
     */
    omit?: profitLossOmit<ExtArgs> | null
    /**
     * Filter which profitLoss to delete.
     */
    where: profitLossWhereUniqueInput
  }

  /**
   * profitLoss deleteMany
   */
  export type profitLossDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profitLosses to delete
     */
    where?: profitLossWhereInput
    /**
     * Limit how many profitLosses to delete.
     */
    limit?: number
  }

  /**
   * profitLoss findRaw
   */
  export type profitLossFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * profitLoss aggregateRaw
   */
  export type profitLossAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * profitLoss without action
   */
  export type profitLossDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profitLoss
     */
    select?: profitLossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the profitLoss
     */
    omit?: profitLossOmit<ExtArgs> | null
  }


  /**
   * Model savedPaymentMethod
   */

  export type AggregateSavedPaymentMethod = {
    _count: SavedPaymentMethodCountAggregateOutputType | null
    _min: SavedPaymentMethodMinAggregateOutputType | null
    _max: SavedPaymentMethodMaxAggregateOutputType | null
  }

  export type SavedPaymentMethodMinAggregateOutputType = {
    id: string | null
    paymentMethod: string | null
    cardNumber: string | null
    cardHolderName: string | null
  }

  export type SavedPaymentMethodMaxAggregateOutputType = {
    id: string | null
    paymentMethod: string | null
    cardNumber: string | null
    cardHolderName: string | null
  }

  export type SavedPaymentMethodCountAggregateOutputType = {
    id: number
    paymentMethod: number
    cardNumber: number
    cardHolderName: number
    _all: number
  }


  export type SavedPaymentMethodMinAggregateInputType = {
    id?: true
    paymentMethod?: true
    cardNumber?: true
    cardHolderName?: true
  }

  export type SavedPaymentMethodMaxAggregateInputType = {
    id?: true
    paymentMethod?: true
    cardNumber?: true
    cardHolderName?: true
  }

  export type SavedPaymentMethodCountAggregateInputType = {
    id?: true
    paymentMethod?: true
    cardNumber?: true
    cardHolderName?: true
    _all?: true
  }

  export type SavedPaymentMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which savedPaymentMethod to aggregate.
     */
    where?: savedPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of savedPaymentMethods to fetch.
     */
    orderBy?: savedPaymentMethodOrderByWithRelationInput | savedPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: savedPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` savedPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` savedPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned savedPaymentMethods
    **/
    _count?: true | SavedPaymentMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedPaymentMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedPaymentMethodMaxAggregateInputType
  }

  export type GetSavedPaymentMethodAggregateType<T extends SavedPaymentMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedPaymentMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedPaymentMethod[P]>
      : GetScalarType<T[P], AggregateSavedPaymentMethod[P]>
  }




  export type savedPaymentMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: savedPaymentMethodWhereInput
    orderBy?: savedPaymentMethodOrderByWithAggregationInput | savedPaymentMethodOrderByWithAggregationInput[]
    by: SavedPaymentMethodScalarFieldEnum[] | SavedPaymentMethodScalarFieldEnum
    having?: savedPaymentMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedPaymentMethodCountAggregateInputType | true
    _min?: SavedPaymentMethodMinAggregateInputType
    _max?: SavedPaymentMethodMaxAggregateInputType
  }

  export type SavedPaymentMethodGroupByOutputType = {
    id: string
    paymentMethod: string | null
    cardNumber: string | null
    cardHolderName: string | null
    _count: SavedPaymentMethodCountAggregateOutputType | null
    _min: SavedPaymentMethodMinAggregateOutputType | null
    _max: SavedPaymentMethodMaxAggregateOutputType | null
  }

  type GetSavedPaymentMethodGroupByPayload<T extends savedPaymentMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedPaymentMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedPaymentMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedPaymentMethodGroupByOutputType[P]>
            : GetScalarType<T[P], SavedPaymentMethodGroupByOutputType[P]>
        }
      >
    >


  export type savedPaymentMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentMethod?: boolean
    cardNumber?: boolean
    cardHolderName?: boolean
  }, ExtArgs["result"]["savedPaymentMethod"]>



  export type savedPaymentMethodSelectScalar = {
    id?: boolean
    paymentMethod?: boolean
    cardNumber?: boolean
    cardHolderName?: boolean
  }

  export type savedPaymentMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentMethod" | "cardNumber" | "cardHolderName", ExtArgs["result"]["savedPaymentMethod"]>

  export type $savedPaymentMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "savedPaymentMethod"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentMethod: string | null
      cardNumber: string | null
      cardHolderName: string | null
    }, ExtArgs["result"]["savedPaymentMethod"]>
    composites: {}
  }

  type savedPaymentMethodGetPayload<S extends boolean | null | undefined | savedPaymentMethodDefaultArgs> = $Result.GetResult<Prisma.$savedPaymentMethodPayload, S>

  type savedPaymentMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<savedPaymentMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedPaymentMethodCountAggregateInputType | true
    }

  export interface savedPaymentMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['savedPaymentMethod'], meta: { name: 'savedPaymentMethod' } }
    /**
     * Find zero or one SavedPaymentMethod that matches the filter.
     * @param {savedPaymentMethodFindUniqueArgs} args - Arguments to find a SavedPaymentMethod
     * @example
     * // Get one SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends savedPaymentMethodFindUniqueArgs>(args: SelectSubset<T, savedPaymentMethodFindUniqueArgs<ExtArgs>>): Prisma__savedPaymentMethodClient<$Result.GetResult<Prisma.$savedPaymentMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedPaymentMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {savedPaymentMethodFindUniqueOrThrowArgs} args - Arguments to find a SavedPaymentMethod
     * @example
     * // Get one SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends savedPaymentMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, savedPaymentMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__savedPaymentMethodClient<$Result.GetResult<Prisma.$savedPaymentMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedPaymentMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedPaymentMethodFindFirstArgs} args - Arguments to find a SavedPaymentMethod
     * @example
     * // Get one SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends savedPaymentMethodFindFirstArgs>(args?: SelectSubset<T, savedPaymentMethodFindFirstArgs<ExtArgs>>): Prisma__savedPaymentMethodClient<$Result.GetResult<Prisma.$savedPaymentMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedPaymentMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedPaymentMethodFindFirstOrThrowArgs} args - Arguments to find a SavedPaymentMethod
     * @example
     * // Get one SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends savedPaymentMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, savedPaymentMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__savedPaymentMethodClient<$Result.GetResult<Prisma.$savedPaymentMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedPaymentMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedPaymentMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedPaymentMethods
     * const savedPaymentMethods = await prisma.savedPaymentMethod.findMany()
     * 
     * // Get first 10 SavedPaymentMethods
     * const savedPaymentMethods = await prisma.savedPaymentMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedPaymentMethodWithIdOnly = await prisma.savedPaymentMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends savedPaymentMethodFindManyArgs>(args?: SelectSubset<T, savedPaymentMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$savedPaymentMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedPaymentMethod.
     * @param {savedPaymentMethodCreateArgs} args - Arguments to create a SavedPaymentMethod.
     * @example
     * // Create one SavedPaymentMethod
     * const SavedPaymentMethod = await prisma.savedPaymentMethod.create({
     *   data: {
     *     // ... data to create a SavedPaymentMethod
     *   }
     * })
     * 
     */
    create<T extends savedPaymentMethodCreateArgs>(args: SelectSubset<T, savedPaymentMethodCreateArgs<ExtArgs>>): Prisma__savedPaymentMethodClient<$Result.GetResult<Prisma.$savedPaymentMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedPaymentMethods.
     * @param {savedPaymentMethodCreateManyArgs} args - Arguments to create many SavedPaymentMethods.
     * @example
     * // Create many SavedPaymentMethods
     * const savedPaymentMethod = await prisma.savedPaymentMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends savedPaymentMethodCreateManyArgs>(args?: SelectSubset<T, savedPaymentMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SavedPaymentMethod.
     * @param {savedPaymentMethodDeleteArgs} args - Arguments to delete one SavedPaymentMethod.
     * @example
     * // Delete one SavedPaymentMethod
     * const SavedPaymentMethod = await prisma.savedPaymentMethod.delete({
     *   where: {
     *     // ... filter to delete one SavedPaymentMethod
     *   }
     * })
     * 
     */
    delete<T extends savedPaymentMethodDeleteArgs>(args: SelectSubset<T, savedPaymentMethodDeleteArgs<ExtArgs>>): Prisma__savedPaymentMethodClient<$Result.GetResult<Prisma.$savedPaymentMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedPaymentMethod.
     * @param {savedPaymentMethodUpdateArgs} args - Arguments to update one SavedPaymentMethod.
     * @example
     * // Update one SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends savedPaymentMethodUpdateArgs>(args: SelectSubset<T, savedPaymentMethodUpdateArgs<ExtArgs>>): Prisma__savedPaymentMethodClient<$Result.GetResult<Prisma.$savedPaymentMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedPaymentMethods.
     * @param {savedPaymentMethodDeleteManyArgs} args - Arguments to filter SavedPaymentMethods to delete.
     * @example
     * // Delete a few SavedPaymentMethods
     * const { count } = await prisma.savedPaymentMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends savedPaymentMethodDeleteManyArgs>(args?: SelectSubset<T, savedPaymentMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedPaymentMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedPaymentMethods
     * const savedPaymentMethod = await prisma.savedPaymentMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends savedPaymentMethodUpdateManyArgs>(args: SelectSubset<T, savedPaymentMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavedPaymentMethod.
     * @param {savedPaymentMethodUpsertArgs} args - Arguments to update or create a SavedPaymentMethod.
     * @example
     * // Update or create a SavedPaymentMethod
     * const savedPaymentMethod = await prisma.savedPaymentMethod.upsert({
     *   create: {
     *     // ... data to create a SavedPaymentMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedPaymentMethod we want to update
     *   }
     * })
     */
    upsert<T extends savedPaymentMethodUpsertArgs>(args: SelectSubset<T, savedPaymentMethodUpsertArgs<ExtArgs>>): Prisma__savedPaymentMethodClient<$Result.GetResult<Prisma.$savedPaymentMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedPaymentMethods that matches the filter.
     * @param {savedPaymentMethodFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const savedPaymentMethod = await prisma.savedPaymentMethod.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: savedPaymentMethodFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SavedPaymentMethod.
     * @param {savedPaymentMethodAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const savedPaymentMethod = await prisma.savedPaymentMethod.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: savedPaymentMethodAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SavedPaymentMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedPaymentMethodCountArgs} args - Arguments to filter SavedPaymentMethods to count.
     * @example
     * // Count the number of SavedPaymentMethods
     * const count = await prisma.savedPaymentMethod.count({
     *   where: {
     *     // ... the filter for the SavedPaymentMethods we want to count
     *   }
     * })
    **/
    count<T extends savedPaymentMethodCountArgs>(
      args?: Subset<T, savedPaymentMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedPaymentMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedPaymentMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedPaymentMethodAggregateArgs>(args: Subset<T, SavedPaymentMethodAggregateArgs>): Prisma.PrismaPromise<GetSavedPaymentMethodAggregateType<T>>

    /**
     * Group by SavedPaymentMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedPaymentMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends savedPaymentMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: savedPaymentMethodGroupByArgs['orderBy'] }
        : { orderBy?: savedPaymentMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, savedPaymentMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedPaymentMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the savedPaymentMethod model
   */
  readonly fields: savedPaymentMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for savedPaymentMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__savedPaymentMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the savedPaymentMethod model
   */ 
  interface savedPaymentMethodFieldRefs {
    readonly id: FieldRef<"savedPaymentMethod", 'String'>
    readonly paymentMethod: FieldRef<"savedPaymentMethod", 'String'>
    readonly cardNumber: FieldRef<"savedPaymentMethod", 'String'>
    readonly cardHolderName: FieldRef<"savedPaymentMethod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * savedPaymentMethod findUnique
   */
  export type savedPaymentMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedPaymentMethod
     */
    select?: savedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedPaymentMethod
     */
    omit?: savedPaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which savedPaymentMethod to fetch.
     */
    where: savedPaymentMethodWhereUniqueInput
  }

  /**
   * savedPaymentMethod findUniqueOrThrow
   */
  export type savedPaymentMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedPaymentMethod
     */
    select?: savedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedPaymentMethod
     */
    omit?: savedPaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which savedPaymentMethod to fetch.
     */
    where: savedPaymentMethodWhereUniqueInput
  }

  /**
   * savedPaymentMethod findFirst
   */
  export type savedPaymentMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedPaymentMethod
     */
    select?: savedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedPaymentMethod
     */
    omit?: savedPaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which savedPaymentMethod to fetch.
     */
    where?: savedPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of savedPaymentMethods to fetch.
     */
    orderBy?: savedPaymentMethodOrderByWithRelationInput | savedPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for savedPaymentMethods.
     */
    cursor?: savedPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` savedPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` savedPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of savedPaymentMethods.
     */
    distinct?: SavedPaymentMethodScalarFieldEnum | SavedPaymentMethodScalarFieldEnum[]
  }

  /**
   * savedPaymentMethod findFirstOrThrow
   */
  export type savedPaymentMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedPaymentMethod
     */
    select?: savedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedPaymentMethod
     */
    omit?: savedPaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which savedPaymentMethod to fetch.
     */
    where?: savedPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of savedPaymentMethods to fetch.
     */
    orderBy?: savedPaymentMethodOrderByWithRelationInput | savedPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for savedPaymentMethods.
     */
    cursor?: savedPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` savedPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` savedPaymentMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of savedPaymentMethods.
     */
    distinct?: SavedPaymentMethodScalarFieldEnum | SavedPaymentMethodScalarFieldEnum[]
  }

  /**
   * savedPaymentMethod findMany
   */
  export type savedPaymentMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedPaymentMethod
     */
    select?: savedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedPaymentMethod
     */
    omit?: savedPaymentMethodOmit<ExtArgs> | null
    /**
     * Filter, which savedPaymentMethods to fetch.
     */
    where?: savedPaymentMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of savedPaymentMethods to fetch.
     */
    orderBy?: savedPaymentMethodOrderByWithRelationInput | savedPaymentMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing savedPaymentMethods.
     */
    cursor?: savedPaymentMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` savedPaymentMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` savedPaymentMethods.
     */
    skip?: number
    distinct?: SavedPaymentMethodScalarFieldEnum | SavedPaymentMethodScalarFieldEnum[]
  }

  /**
   * savedPaymentMethod create
   */
  export type savedPaymentMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedPaymentMethod
     */
    select?: savedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedPaymentMethod
     */
    omit?: savedPaymentMethodOmit<ExtArgs> | null
    /**
     * The data needed to create a savedPaymentMethod.
     */
    data?: XOR<savedPaymentMethodCreateInput, savedPaymentMethodUncheckedCreateInput>
  }

  /**
   * savedPaymentMethod createMany
   */
  export type savedPaymentMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many savedPaymentMethods.
     */
    data: savedPaymentMethodCreateManyInput | savedPaymentMethodCreateManyInput[]
  }

  /**
   * savedPaymentMethod update
   */
  export type savedPaymentMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedPaymentMethod
     */
    select?: savedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedPaymentMethod
     */
    omit?: savedPaymentMethodOmit<ExtArgs> | null
    /**
     * The data needed to update a savedPaymentMethod.
     */
    data: XOR<savedPaymentMethodUpdateInput, savedPaymentMethodUncheckedUpdateInput>
    /**
     * Choose, which savedPaymentMethod to update.
     */
    where: savedPaymentMethodWhereUniqueInput
  }

  /**
   * savedPaymentMethod updateMany
   */
  export type savedPaymentMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update savedPaymentMethods.
     */
    data: XOR<savedPaymentMethodUpdateManyMutationInput, savedPaymentMethodUncheckedUpdateManyInput>
    /**
     * Filter which savedPaymentMethods to update
     */
    where?: savedPaymentMethodWhereInput
    /**
     * Limit how many savedPaymentMethods to update.
     */
    limit?: number
  }

  /**
   * savedPaymentMethod upsert
   */
  export type savedPaymentMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedPaymentMethod
     */
    select?: savedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedPaymentMethod
     */
    omit?: savedPaymentMethodOmit<ExtArgs> | null
    /**
     * The filter to search for the savedPaymentMethod to update in case it exists.
     */
    where: savedPaymentMethodWhereUniqueInput
    /**
     * In case the savedPaymentMethod found by the `where` argument doesn't exist, create a new savedPaymentMethod with this data.
     */
    create: XOR<savedPaymentMethodCreateInput, savedPaymentMethodUncheckedCreateInput>
    /**
     * In case the savedPaymentMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<savedPaymentMethodUpdateInput, savedPaymentMethodUncheckedUpdateInput>
  }

  /**
   * savedPaymentMethod delete
   */
  export type savedPaymentMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedPaymentMethod
     */
    select?: savedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedPaymentMethod
     */
    omit?: savedPaymentMethodOmit<ExtArgs> | null
    /**
     * Filter which savedPaymentMethod to delete.
     */
    where: savedPaymentMethodWhereUniqueInput
  }

  /**
   * savedPaymentMethod deleteMany
   */
  export type savedPaymentMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which savedPaymentMethods to delete
     */
    where?: savedPaymentMethodWhereInput
    /**
     * Limit how many savedPaymentMethods to delete.
     */
    limit?: number
  }

  /**
   * savedPaymentMethod findRaw
   */
  export type savedPaymentMethodFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * savedPaymentMethod aggregateRaw
   */
  export type savedPaymentMethodAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * savedPaymentMethod without action
   */
  export type savedPaymentMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedPaymentMethod
     */
    select?: savedPaymentMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedPaymentMethod
     */
    omit?: savedPaymentMethodOmit<ExtArgs> | null
  }


  /**
   * Model RefundRequests
   */

  export type AggregateRefundRequests = {
    _count: RefundRequestsCountAggregateOutputType | null
    _avg: RefundRequestsAvgAggregateOutputType | null
    _sum: RefundRequestsSumAggregateOutputType | null
    _min: RefundRequestsMinAggregateOutputType | null
    _max: RefundRequestsMaxAggregateOutputType | null
  }

  export type RefundRequestsAvgAggregateOutputType = {
    amount: number | null
  }

  export type RefundRequestsSumAggregateOutputType = {
    amount: number | null
  }

  export type RefundRequestsMinAggregateOutputType = {
    refundId: string | null
    customerID: string | null
    paymentId: string | null
    amount: number | null
    reason: string | null
    requestAt: Date | null
    status: $Enums.refundStatus | null
  }

  export type RefundRequestsMaxAggregateOutputType = {
    refundId: string | null
    customerID: string | null
    paymentId: string | null
    amount: number | null
    reason: string | null
    requestAt: Date | null
    status: $Enums.refundStatus | null
  }

  export type RefundRequestsCountAggregateOutputType = {
    refundId: number
    customerID: number
    paymentId: number
    amount: number
    reason: number
    requestAt: number
    status: number
    _all: number
  }


  export type RefundRequestsAvgAggregateInputType = {
    amount?: true
  }

  export type RefundRequestsSumAggregateInputType = {
    amount?: true
  }

  export type RefundRequestsMinAggregateInputType = {
    refundId?: true
    customerID?: true
    paymentId?: true
    amount?: true
    reason?: true
    requestAt?: true
    status?: true
  }

  export type RefundRequestsMaxAggregateInputType = {
    refundId?: true
    customerID?: true
    paymentId?: true
    amount?: true
    reason?: true
    requestAt?: true
    status?: true
  }

  export type RefundRequestsCountAggregateInputType = {
    refundId?: true
    customerID?: true
    paymentId?: true
    amount?: true
    reason?: true
    requestAt?: true
    status?: true
    _all?: true
  }

  export type RefundRequestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefundRequests to aggregate.
     */
    where?: RefundRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestsOrderByWithRelationInput | RefundRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefundRequests
    **/
    _count?: true | RefundRequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundRequestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundRequestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundRequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundRequestsMaxAggregateInputType
  }

  export type GetRefundRequestsAggregateType<T extends RefundRequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateRefundRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefundRequests[P]>
      : GetScalarType<T[P], AggregateRefundRequests[P]>
  }




  export type RefundRequestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundRequestsWhereInput
    orderBy?: RefundRequestsOrderByWithAggregationInput | RefundRequestsOrderByWithAggregationInput[]
    by: RefundRequestsScalarFieldEnum[] | RefundRequestsScalarFieldEnum
    having?: RefundRequestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundRequestsCountAggregateInputType | true
    _avg?: RefundRequestsAvgAggregateInputType
    _sum?: RefundRequestsSumAggregateInputType
    _min?: RefundRequestsMinAggregateInputType
    _max?: RefundRequestsMaxAggregateInputType
  }

  export type RefundRequestsGroupByOutputType = {
    refundId: string
    customerID: string
    paymentId: string
    amount: number | null
    reason: string | null
    requestAt: Date
    status: $Enums.refundStatus
    _count: RefundRequestsCountAggregateOutputType | null
    _avg: RefundRequestsAvgAggregateOutputType | null
    _sum: RefundRequestsSumAggregateOutputType | null
    _min: RefundRequestsMinAggregateOutputType | null
    _max: RefundRequestsMaxAggregateOutputType | null
  }

  type GetRefundRequestsGroupByPayload<T extends RefundRequestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundRequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundRequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundRequestsGroupByOutputType[P]>
            : GetScalarType<T[P], RefundRequestsGroupByOutputType[P]>
        }
      >
    >


  export type RefundRequestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    refundId?: boolean
    customerID?: boolean
    paymentId?: boolean
    amount?: boolean
    reason?: boolean
    requestAt?: boolean
    status?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refundRequests"]>



  export type RefundRequestsSelectScalar = {
    refundId?: boolean
    customerID?: boolean
    paymentId?: boolean
    amount?: boolean
    reason?: boolean
    requestAt?: boolean
    status?: boolean
  }

  export type RefundRequestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"refundId" | "customerID" | "paymentId" | "amount" | "reason" | "requestAt" | "status", ExtArgs["result"]["refundRequests"]>
  export type RefundRequestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $RefundRequestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefundRequests"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      refundId: string
      customerID: string
      paymentId: string
      amount: number | null
      reason: string | null
      requestAt: Date
      status: $Enums.refundStatus
    }, ExtArgs["result"]["refundRequests"]>
    composites: {}
  }

  type RefundRequestsGetPayload<S extends boolean | null | undefined | RefundRequestsDefaultArgs> = $Result.GetResult<Prisma.$RefundRequestsPayload, S>

  type RefundRequestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefundRequestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefundRequestsCountAggregateInputType | true
    }

  export interface RefundRequestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefundRequests'], meta: { name: 'RefundRequests' } }
    /**
     * Find zero or one RefundRequests that matches the filter.
     * @param {RefundRequestsFindUniqueArgs} args - Arguments to find a RefundRequests
     * @example
     * // Get one RefundRequests
     * const refundRequests = await prisma.refundRequests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundRequestsFindUniqueArgs>(args: SelectSubset<T, RefundRequestsFindUniqueArgs<ExtArgs>>): Prisma__RefundRequestsClient<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefundRequests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefundRequestsFindUniqueOrThrowArgs} args - Arguments to find a RefundRequests
     * @example
     * // Get one RefundRequests
     * const refundRequests = await prisma.refundRequests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundRequestsFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundRequestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundRequestsClient<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefundRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestsFindFirstArgs} args - Arguments to find a RefundRequests
     * @example
     * // Get one RefundRequests
     * const refundRequests = await prisma.refundRequests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundRequestsFindFirstArgs>(args?: SelectSubset<T, RefundRequestsFindFirstArgs<ExtArgs>>): Prisma__RefundRequestsClient<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefundRequests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestsFindFirstOrThrowArgs} args - Arguments to find a RefundRequests
     * @example
     * // Get one RefundRequests
     * const refundRequests = await prisma.refundRequests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundRequestsFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundRequestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundRequestsClient<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefundRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefundRequests
     * const refundRequests = await prisma.refundRequests.findMany()
     * 
     * // Get first 10 RefundRequests
     * const refundRequests = await prisma.refundRequests.findMany({ take: 10 })
     * 
     * // Only select the `refundId`
     * const refundRequestsWithRefundIdOnly = await prisma.refundRequests.findMany({ select: { refundId: true } })
     * 
     */
    findMany<T extends RefundRequestsFindManyArgs>(args?: SelectSubset<T, RefundRequestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefundRequests.
     * @param {RefundRequestsCreateArgs} args - Arguments to create a RefundRequests.
     * @example
     * // Create one RefundRequests
     * const RefundRequests = await prisma.refundRequests.create({
     *   data: {
     *     // ... data to create a RefundRequests
     *   }
     * })
     * 
     */
    create<T extends RefundRequestsCreateArgs>(args: SelectSubset<T, RefundRequestsCreateArgs<ExtArgs>>): Prisma__RefundRequestsClient<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefundRequests.
     * @param {RefundRequestsCreateManyArgs} args - Arguments to create many RefundRequests.
     * @example
     * // Create many RefundRequests
     * const refundRequests = await prisma.refundRequests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundRequestsCreateManyArgs>(args?: SelectSubset<T, RefundRequestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RefundRequests.
     * @param {RefundRequestsDeleteArgs} args - Arguments to delete one RefundRequests.
     * @example
     * // Delete one RefundRequests
     * const RefundRequests = await prisma.refundRequests.delete({
     *   where: {
     *     // ... filter to delete one RefundRequests
     *   }
     * })
     * 
     */
    delete<T extends RefundRequestsDeleteArgs>(args: SelectSubset<T, RefundRequestsDeleteArgs<ExtArgs>>): Prisma__RefundRequestsClient<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefundRequests.
     * @param {RefundRequestsUpdateArgs} args - Arguments to update one RefundRequests.
     * @example
     * // Update one RefundRequests
     * const refundRequests = await prisma.refundRequests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundRequestsUpdateArgs>(args: SelectSubset<T, RefundRequestsUpdateArgs<ExtArgs>>): Prisma__RefundRequestsClient<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefundRequests.
     * @param {RefundRequestsDeleteManyArgs} args - Arguments to filter RefundRequests to delete.
     * @example
     * // Delete a few RefundRequests
     * const { count } = await prisma.refundRequests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundRequestsDeleteManyArgs>(args?: SelectSubset<T, RefundRequestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefundRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefundRequests
     * const refundRequests = await prisma.refundRequests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundRequestsUpdateManyArgs>(args: SelectSubset<T, RefundRequestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefundRequests.
     * @param {RefundRequestsUpsertArgs} args - Arguments to update or create a RefundRequests.
     * @example
     * // Update or create a RefundRequests
     * const refundRequests = await prisma.refundRequests.upsert({
     *   create: {
     *     // ... data to create a RefundRequests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefundRequests we want to update
     *   }
     * })
     */
    upsert<T extends RefundRequestsUpsertArgs>(args: SelectSubset<T, RefundRequestsUpsertArgs<ExtArgs>>): Prisma__RefundRequestsClient<$Result.GetResult<Prisma.$RefundRequestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefundRequests that matches the filter.
     * @param {RefundRequestsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const refundRequests = await prisma.refundRequests.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RefundRequestsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RefundRequests.
     * @param {RefundRequestsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const refundRequests = await prisma.refundRequests.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RefundRequestsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of RefundRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestsCountArgs} args - Arguments to filter RefundRequests to count.
     * @example
     * // Count the number of RefundRequests
     * const count = await prisma.refundRequests.count({
     *   where: {
     *     // ... the filter for the RefundRequests we want to count
     *   }
     * })
    **/
    count<T extends RefundRequestsCountArgs>(
      args?: Subset<T, RefundRequestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundRequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefundRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundRequestsAggregateArgs>(args: Subset<T, RefundRequestsAggregateArgs>): Prisma.PrismaPromise<GetRefundRequestsAggregateType<T>>

    /**
     * Group by RefundRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundRequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundRequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundRequestsGroupByArgs['orderBy'] }
        : { orderBy?: RefundRequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundRequestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundRequestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefundRequests model
   */
  readonly fields: RefundRequestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefundRequests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundRequestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefundRequests model
   */ 
  interface RefundRequestsFieldRefs {
    readonly refundId: FieldRef<"RefundRequests", 'String'>
    readonly customerID: FieldRef<"RefundRequests", 'String'>
    readonly paymentId: FieldRef<"RefundRequests", 'String'>
    readonly amount: FieldRef<"RefundRequests", 'Float'>
    readonly reason: FieldRef<"RefundRequests", 'String'>
    readonly requestAt: FieldRef<"RefundRequests", 'DateTime'>
    readonly status: FieldRef<"RefundRequests", 'refundStatus'>
  }
    

  // Custom InputTypes
  /**
   * RefundRequests findUnique
   */
  export type RefundRequestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequests to fetch.
     */
    where: RefundRequestsWhereUniqueInput
  }

  /**
   * RefundRequests findUniqueOrThrow
   */
  export type RefundRequestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequests to fetch.
     */
    where: RefundRequestsWhereUniqueInput
  }

  /**
   * RefundRequests findFirst
   */
  export type RefundRequestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequests to fetch.
     */
    where?: RefundRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestsOrderByWithRelationInput | RefundRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefundRequests.
     */
    cursor?: RefundRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefundRequests.
     */
    distinct?: RefundRequestsScalarFieldEnum | RefundRequestsScalarFieldEnum[]
  }

  /**
   * RefundRequests findFirstOrThrow
   */
  export type RefundRequestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequests to fetch.
     */
    where?: RefundRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestsOrderByWithRelationInput | RefundRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefundRequests.
     */
    cursor?: RefundRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefundRequests.
     */
    distinct?: RefundRequestsScalarFieldEnum | RefundRequestsScalarFieldEnum[]
  }

  /**
   * RefundRequests findMany
   */
  export type RefundRequestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    /**
     * Filter, which RefundRequests to fetch.
     */
    where?: RefundRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefundRequests to fetch.
     */
    orderBy?: RefundRequestsOrderByWithRelationInput | RefundRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefundRequests.
     */
    cursor?: RefundRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefundRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefundRequests.
     */
    skip?: number
    distinct?: RefundRequestsScalarFieldEnum | RefundRequestsScalarFieldEnum[]
  }

  /**
   * RefundRequests create
   */
  export type RefundRequestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    /**
     * The data needed to create a RefundRequests.
     */
    data: XOR<RefundRequestsCreateInput, RefundRequestsUncheckedCreateInput>
  }

  /**
   * RefundRequests createMany
   */
  export type RefundRequestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefundRequests.
     */
    data: RefundRequestsCreateManyInput | RefundRequestsCreateManyInput[]
  }

  /**
   * RefundRequests update
   */
  export type RefundRequestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    /**
     * The data needed to update a RefundRequests.
     */
    data: XOR<RefundRequestsUpdateInput, RefundRequestsUncheckedUpdateInput>
    /**
     * Choose, which RefundRequests to update.
     */
    where: RefundRequestsWhereUniqueInput
  }

  /**
   * RefundRequests updateMany
   */
  export type RefundRequestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefundRequests.
     */
    data: XOR<RefundRequestsUpdateManyMutationInput, RefundRequestsUncheckedUpdateManyInput>
    /**
     * Filter which RefundRequests to update
     */
    where?: RefundRequestsWhereInput
    /**
     * Limit how many RefundRequests to update.
     */
    limit?: number
  }

  /**
   * RefundRequests upsert
   */
  export type RefundRequestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    /**
     * The filter to search for the RefundRequests to update in case it exists.
     */
    where: RefundRequestsWhereUniqueInput
    /**
     * In case the RefundRequests found by the `where` argument doesn't exist, create a new RefundRequests with this data.
     */
    create: XOR<RefundRequestsCreateInput, RefundRequestsUncheckedCreateInput>
    /**
     * In case the RefundRequests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundRequestsUpdateInput, RefundRequestsUncheckedUpdateInput>
  }

  /**
   * RefundRequests delete
   */
  export type RefundRequestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
    /**
     * Filter which RefundRequests to delete.
     */
    where: RefundRequestsWhereUniqueInput
  }

  /**
   * RefundRequests deleteMany
   */
  export type RefundRequestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefundRequests to delete
     */
    where?: RefundRequestsWhereInput
    /**
     * Limit how many RefundRequests to delete.
     */
    limit?: number
  }

  /**
   * RefundRequests findRaw
   */
  export type RefundRequestsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RefundRequests aggregateRaw
   */
  export type RefundRequestsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RefundRequests without action
   */
  export type RefundRequestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefundRequests
     */
    select?: RefundRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefundRequests
     */
    omit?: RefundRequestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundRequestsInclude<ExtArgs> | null
  }


  /**
   * Model deductionRate
   */

  export type AggregateDeductionRate = {
    _count: DeductionRateCountAggregateOutputType | null
    _avg: DeductionRateAvgAggregateOutputType | null
    _sum: DeductionRateSumAggregateOutputType | null
    _min: DeductionRateMinAggregateOutputType | null
    _max: DeductionRateMaxAggregateOutputType | null
  }

  export type DeductionRateAvgAggregateOutputType = {
    rate: number | null
  }

  export type DeductionRateSumAggregateOutputType = {
    rate: number | null
  }

  export type DeductionRateMinAggregateOutputType = {
    id: string | null
    type: string | null
    rate: number | null
  }

  export type DeductionRateMaxAggregateOutputType = {
    id: string | null
    type: string | null
    rate: number | null
  }

  export type DeductionRateCountAggregateOutputType = {
    id: number
    type: number
    rate: number
    _all: number
  }


  export type DeductionRateAvgAggregateInputType = {
    rate?: true
  }

  export type DeductionRateSumAggregateInputType = {
    rate?: true
  }

  export type DeductionRateMinAggregateInputType = {
    id?: true
    type?: true
    rate?: true
  }

  export type DeductionRateMaxAggregateInputType = {
    id?: true
    type?: true
    rate?: true
  }

  export type DeductionRateCountAggregateInputType = {
    id?: true
    type?: true
    rate?: true
    _all?: true
  }

  export type DeductionRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deductionRate to aggregate.
     */
    where?: deductionRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deductionRates to fetch.
     */
    orderBy?: deductionRateOrderByWithRelationInput | deductionRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: deductionRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deductionRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deductionRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned deductionRates
    **/
    _count?: true | DeductionRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeductionRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeductionRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeductionRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeductionRateMaxAggregateInputType
  }

  export type GetDeductionRateAggregateType<T extends DeductionRateAggregateArgs> = {
        [P in keyof T & keyof AggregateDeductionRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeductionRate[P]>
      : GetScalarType<T[P], AggregateDeductionRate[P]>
  }




  export type deductionRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: deductionRateWhereInput
    orderBy?: deductionRateOrderByWithAggregationInput | deductionRateOrderByWithAggregationInput[]
    by: DeductionRateScalarFieldEnum[] | DeductionRateScalarFieldEnum
    having?: deductionRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeductionRateCountAggregateInputType | true
    _avg?: DeductionRateAvgAggregateInputType
    _sum?: DeductionRateSumAggregateInputType
    _min?: DeductionRateMinAggregateInputType
    _max?: DeductionRateMaxAggregateInputType
  }

  export type DeductionRateGroupByOutputType = {
    id: string
    type: string | null
    rate: number | null
    _count: DeductionRateCountAggregateOutputType | null
    _avg: DeductionRateAvgAggregateOutputType | null
    _sum: DeductionRateSumAggregateOutputType | null
    _min: DeductionRateMinAggregateOutputType | null
    _max: DeductionRateMaxAggregateOutputType | null
  }

  type GetDeductionRateGroupByPayload<T extends deductionRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeductionRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeductionRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeductionRateGroupByOutputType[P]>
            : GetScalarType<T[P], DeductionRateGroupByOutputType[P]>
        }
      >
    >


  export type deductionRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    rate?: boolean
  }, ExtArgs["result"]["deductionRate"]>



  export type deductionRateSelectScalar = {
    id?: boolean
    type?: boolean
    rate?: boolean
  }

  export type deductionRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "rate", ExtArgs["result"]["deductionRate"]>

  export type $deductionRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "deductionRate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string | null
      rate: number | null
    }, ExtArgs["result"]["deductionRate"]>
    composites: {}
  }

  type deductionRateGetPayload<S extends boolean | null | undefined | deductionRateDefaultArgs> = $Result.GetResult<Prisma.$deductionRatePayload, S>

  type deductionRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<deductionRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeductionRateCountAggregateInputType | true
    }

  export interface deductionRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['deductionRate'], meta: { name: 'deductionRate' } }
    /**
     * Find zero or one DeductionRate that matches the filter.
     * @param {deductionRateFindUniqueArgs} args - Arguments to find a DeductionRate
     * @example
     * // Get one DeductionRate
     * const deductionRate = await prisma.deductionRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends deductionRateFindUniqueArgs>(args: SelectSubset<T, deductionRateFindUniqueArgs<ExtArgs>>): Prisma__deductionRateClient<$Result.GetResult<Prisma.$deductionRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeductionRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {deductionRateFindUniqueOrThrowArgs} args - Arguments to find a DeductionRate
     * @example
     * // Get one DeductionRate
     * const deductionRate = await prisma.deductionRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends deductionRateFindUniqueOrThrowArgs>(args: SelectSubset<T, deductionRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__deductionRateClient<$Result.GetResult<Prisma.$deductionRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeductionRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionRateFindFirstArgs} args - Arguments to find a DeductionRate
     * @example
     * // Get one DeductionRate
     * const deductionRate = await prisma.deductionRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends deductionRateFindFirstArgs>(args?: SelectSubset<T, deductionRateFindFirstArgs<ExtArgs>>): Prisma__deductionRateClient<$Result.GetResult<Prisma.$deductionRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeductionRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionRateFindFirstOrThrowArgs} args - Arguments to find a DeductionRate
     * @example
     * // Get one DeductionRate
     * const deductionRate = await prisma.deductionRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends deductionRateFindFirstOrThrowArgs>(args?: SelectSubset<T, deductionRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__deductionRateClient<$Result.GetResult<Prisma.$deductionRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeductionRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeductionRates
     * const deductionRates = await prisma.deductionRate.findMany()
     * 
     * // Get first 10 DeductionRates
     * const deductionRates = await prisma.deductionRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deductionRateWithIdOnly = await prisma.deductionRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends deductionRateFindManyArgs>(args?: SelectSubset<T, deductionRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$deductionRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeductionRate.
     * @param {deductionRateCreateArgs} args - Arguments to create a DeductionRate.
     * @example
     * // Create one DeductionRate
     * const DeductionRate = await prisma.deductionRate.create({
     *   data: {
     *     // ... data to create a DeductionRate
     *   }
     * })
     * 
     */
    create<T extends deductionRateCreateArgs>(args: SelectSubset<T, deductionRateCreateArgs<ExtArgs>>): Prisma__deductionRateClient<$Result.GetResult<Prisma.$deductionRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeductionRates.
     * @param {deductionRateCreateManyArgs} args - Arguments to create many DeductionRates.
     * @example
     * // Create many DeductionRates
     * const deductionRate = await prisma.deductionRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends deductionRateCreateManyArgs>(args?: SelectSubset<T, deductionRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeductionRate.
     * @param {deductionRateDeleteArgs} args - Arguments to delete one DeductionRate.
     * @example
     * // Delete one DeductionRate
     * const DeductionRate = await prisma.deductionRate.delete({
     *   where: {
     *     // ... filter to delete one DeductionRate
     *   }
     * })
     * 
     */
    delete<T extends deductionRateDeleteArgs>(args: SelectSubset<T, deductionRateDeleteArgs<ExtArgs>>): Prisma__deductionRateClient<$Result.GetResult<Prisma.$deductionRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeductionRate.
     * @param {deductionRateUpdateArgs} args - Arguments to update one DeductionRate.
     * @example
     * // Update one DeductionRate
     * const deductionRate = await prisma.deductionRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends deductionRateUpdateArgs>(args: SelectSubset<T, deductionRateUpdateArgs<ExtArgs>>): Prisma__deductionRateClient<$Result.GetResult<Prisma.$deductionRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeductionRates.
     * @param {deductionRateDeleteManyArgs} args - Arguments to filter DeductionRates to delete.
     * @example
     * // Delete a few DeductionRates
     * const { count } = await prisma.deductionRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends deductionRateDeleteManyArgs>(args?: SelectSubset<T, deductionRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeductionRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeductionRates
     * const deductionRate = await prisma.deductionRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends deductionRateUpdateManyArgs>(args: SelectSubset<T, deductionRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeductionRate.
     * @param {deductionRateUpsertArgs} args - Arguments to update or create a DeductionRate.
     * @example
     * // Update or create a DeductionRate
     * const deductionRate = await prisma.deductionRate.upsert({
     *   create: {
     *     // ... data to create a DeductionRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeductionRate we want to update
     *   }
     * })
     */
    upsert<T extends deductionRateUpsertArgs>(args: SelectSubset<T, deductionRateUpsertArgs<ExtArgs>>): Prisma__deductionRateClient<$Result.GetResult<Prisma.$deductionRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeductionRates that matches the filter.
     * @param {deductionRateFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const deductionRate = await prisma.deductionRate.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: deductionRateFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DeductionRate.
     * @param {deductionRateAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const deductionRate = await prisma.deductionRate.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: deductionRateAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DeductionRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionRateCountArgs} args - Arguments to filter DeductionRates to count.
     * @example
     * // Count the number of DeductionRates
     * const count = await prisma.deductionRate.count({
     *   where: {
     *     // ... the filter for the DeductionRates we want to count
     *   }
     * })
    **/
    count<T extends deductionRateCountArgs>(
      args?: Subset<T, deductionRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeductionRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeductionRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeductionRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeductionRateAggregateArgs>(args: Subset<T, DeductionRateAggregateArgs>): Prisma.PrismaPromise<GetDeductionRateAggregateType<T>>

    /**
     * Group by DeductionRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {deductionRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends deductionRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: deductionRateGroupByArgs['orderBy'] }
        : { orderBy?: deductionRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, deductionRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeductionRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the deductionRate model
   */
  readonly fields: deductionRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for deductionRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__deductionRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the deductionRate model
   */ 
  interface deductionRateFieldRefs {
    readonly id: FieldRef<"deductionRate", 'String'>
    readonly type: FieldRef<"deductionRate", 'String'>
    readonly rate: FieldRef<"deductionRate", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * deductionRate findUnique
   */
  export type deductionRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deductionRate
     */
    select?: deductionRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deductionRate
     */
    omit?: deductionRateOmit<ExtArgs> | null
    /**
     * Filter, which deductionRate to fetch.
     */
    where: deductionRateWhereUniqueInput
  }

  /**
   * deductionRate findUniqueOrThrow
   */
  export type deductionRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deductionRate
     */
    select?: deductionRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deductionRate
     */
    omit?: deductionRateOmit<ExtArgs> | null
    /**
     * Filter, which deductionRate to fetch.
     */
    where: deductionRateWhereUniqueInput
  }

  /**
   * deductionRate findFirst
   */
  export type deductionRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deductionRate
     */
    select?: deductionRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deductionRate
     */
    omit?: deductionRateOmit<ExtArgs> | null
    /**
     * Filter, which deductionRate to fetch.
     */
    where?: deductionRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deductionRates to fetch.
     */
    orderBy?: deductionRateOrderByWithRelationInput | deductionRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deductionRates.
     */
    cursor?: deductionRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deductionRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deductionRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deductionRates.
     */
    distinct?: DeductionRateScalarFieldEnum | DeductionRateScalarFieldEnum[]
  }

  /**
   * deductionRate findFirstOrThrow
   */
  export type deductionRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deductionRate
     */
    select?: deductionRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deductionRate
     */
    omit?: deductionRateOmit<ExtArgs> | null
    /**
     * Filter, which deductionRate to fetch.
     */
    where?: deductionRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deductionRates to fetch.
     */
    orderBy?: deductionRateOrderByWithRelationInput | deductionRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for deductionRates.
     */
    cursor?: deductionRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deductionRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deductionRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of deductionRates.
     */
    distinct?: DeductionRateScalarFieldEnum | DeductionRateScalarFieldEnum[]
  }

  /**
   * deductionRate findMany
   */
  export type deductionRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deductionRate
     */
    select?: deductionRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deductionRate
     */
    omit?: deductionRateOmit<ExtArgs> | null
    /**
     * Filter, which deductionRates to fetch.
     */
    where?: deductionRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of deductionRates to fetch.
     */
    orderBy?: deductionRateOrderByWithRelationInput | deductionRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing deductionRates.
     */
    cursor?: deductionRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` deductionRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` deductionRates.
     */
    skip?: number
    distinct?: DeductionRateScalarFieldEnum | DeductionRateScalarFieldEnum[]
  }

  /**
   * deductionRate create
   */
  export type deductionRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deductionRate
     */
    select?: deductionRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deductionRate
     */
    omit?: deductionRateOmit<ExtArgs> | null
    /**
     * The data needed to create a deductionRate.
     */
    data?: XOR<deductionRateCreateInput, deductionRateUncheckedCreateInput>
  }

  /**
   * deductionRate createMany
   */
  export type deductionRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many deductionRates.
     */
    data: deductionRateCreateManyInput | deductionRateCreateManyInput[]
  }

  /**
   * deductionRate update
   */
  export type deductionRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deductionRate
     */
    select?: deductionRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deductionRate
     */
    omit?: deductionRateOmit<ExtArgs> | null
    /**
     * The data needed to update a deductionRate.
     */
    data: XOR<deductionRateUpdateInput, deductionRateUncheckedUpdateInput>
    /**
     * Choose, which deductionRate to update.
     */
    where: deductionRateWhereUniqueInput
  }

  /**
   * deductionRate updateMany
   */
  export type deductionRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update deductionRates.
     */
    data: XOR<deductionRateUpdateManyMutationInput, deductionRateUncheckedUpdateManyInput>
    /**
     * Filter which deductionRates to update
     */
    where?: deductionRateWhereInput
    /**
     * Limit how many deductionRates to update.
     */
    limit?: number
  }

  /**
   * deductionRate upsert
   */
  export type deductionRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deductionRate
     */
    select?: deductionRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deductionRate
     */
    omit?: deductionRateOmit<ExtArgs> | null
    /**
     * The filter to search for the deductionRate to update in case it exists.
     */
    where: deductionRateWhereUniqueInput
    /**
     * In case the deductionRate found by the `where` argument doesn't exist, create a new deductionRate with this data.
     */
    create: XOR<deductionRateCreateInput, deductionRateUncheckedCreateInput>
    /**
     * In case the deductionRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<deductionRateUpdateInput, deductionRateUncheckedUpdateInput>
  }

  /**
   * deductionRate delete
   */
  export type deductionRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deductionRate
     */
    select?: deductionRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deductionRate
     */
    omit?: deductionRateOmit<ExtArgs> | null
    /**
     * Filter which deductionRate to delete.
     */
    where: deductionRateWhereUniqueInput
  }

  /**
   * deductionRate deleteMany
   */
  export type deductionRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which deductionRates to delete
     */
    where?: deductionRateWhereInput
    /**
     * Limit how many deductionRates to delete.
     */
    limit?: number
  }

  /**
   * deductionRate findRaw
   */
  export type deductionRateFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * deductionRate aggregateRaw
   */
  export type deductionRateAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * deductionRate without action
   */
  export type deductionRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the deductionRate
     */
    select?: deductionRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the deductionRate
     */
    omit?: deductionRateOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const CustomerScalarFieldEnum: {
    id: 'id',
    FirstName: 'FirstName',
    LastName: 'LastName',
    Gender: 'Gender',
    Email: 'Email',
    Password: 'Password',
    MobileNumber: 'MobileNumber',
    NIC: 'NIC',
    Address: 'Address'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    CategoryID: 'CategoryID',
    Type: 'Type'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const EducationScalarFieldEnum: {
    EducationId: 'EducationId',
    deliveryMode: 'deliveryMode',
    categoryID: 'categoryID'
  };

  export type EducationScalarFieldEnum = (typeof EducationScalarFieldEnum)[keyof typeof EducationScalarFieldEnum]


  export const SyllabusScalarFieldEnum: {
    SyllabusID: 'SyllabusID',
    Title: 'Title',
    Description: 'Description',
    educationID: 'educationID'
  };

  export type SyllabusScalarFieldEnum = (typeof SyllabusScalarFieldEnum)[keyof typeof SyllabusScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    SubjectID: 'SubjectID',
    Name: 'Name'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const SyllabusSubjectScalarFieldEnum: {
    id: 'id',
    syllabusID: 'syllabusID',
    subjectID: 'subjectID'
  };

  export type SyllabusSubjectScalarFieldEnum = (typeof SyllabusSubjectScalarFieldEnum)[keyof typeof SyllabusSubjectScalarFieldEnum]


  export const ComplainScalarFieldEnum: {
    complainId: 'complainId',
    Reason: 'Reason',
    Status: 'Status',
    CustomerId: 'CustomerId'
  };

  export type ComplainScalarFieldEnum = (typeof ComplainScalarFieldEnum)[keyof typeof ComplainScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    ServiceID: 'ServiceID',
    ServiceName: 'ServiceName',
    Category: 'Category',
    CommisionRate: 'CommisionRate',
    Description: 'Description'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const AdministratorScalarFieldEnum: {
    AdminID: 'AdminID',
    Name: 'Name',
    Email: 'Email',
    Password: 'Password',
    MobileNumber: 'MobileNumber'
  };

  export type AdministratorScalarFieldEnum = (typeof AdministratorScalarFieldEnum)[keyof typeof AdministratorScalarFieldEnum]


  export const ServiceProviderScalarFieldEnum: {
    ProviderID: 'ProviderID',
    FirstName: 'FirstName',
    LastName: 'LastName',
    MobileNumber: 'MobileNumber',
    NIC: 'NIC',
    Address: 'Address',
    email: 'email',
    password: 'password',
    Availability: 'Availability',
    ServiceType: 'ServiceType'
  };

  export type ServiceProviderScalarFieldEnum = (typeof ServiceProviderScalarFieldEnum)[keyof typeof ServiceProviderScalarFieldEnum]


  export const Customer_ProviderScalarFieldEnum: {
    id: 'id',
    customer: 'customer',
    provider: 'provider'
  };

  export type Customer_ProviderScalarFieldEnum = (typeof Customer_ProviderScalarFieldEnum)[keyof typeof Customer_ProviderScalarFieldEnum]


  export const ServiceProvider_ReportsScalarFieldEnum: {
    ReportID: 'ReportID',
    Provider: 'Provider',
    BirthCertificate: 'BirthCertificate',
    PoliceReport: 'PoliceReport',
    NIC_Copy: 'NIC_Copy'
  };

  export type ServiceProvider_ReportsScalarFieldEnum = (typeof ServiceProvider_ReportsScalarFieldEnum)[keyof typeof ServiceProvider_ReportsScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    BookingID: 'BookingID',
    AgreementDuration: 'AgreementDuration',
    Booking_Service: 'Booking_Service',
    Provider: 'Provider',
    MonthlyPayment: 'MonthlyPayment',
    BookingDate: 'BookingDate',
    Status: 'Status',
    CustomerID: 'CustomerID'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PaymentMethodScalarFieldEnum: {
    MethodId: 'MethodId',
    PaymentType: 'PaymentType',
    Description: 'Description'
  };

  export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    paymentID: 'paymentID',
    PaymentDate: 'PaymentDate',
    Amount: 'Amount',
    PaymentMethod: 'PaymentMethod',
    BookingId: 'BookingId',
    Status: 'Status'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    scheduleId: 'scheduleId',
    scheduleDate: 'scheduleDate',
    AgreementTime: 'AgreementTime',
    startDate: 'startDate',
    provider: 'provider'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const FeedbackRatingScalarFieldEnum: {
    feedbackID: 'feedbackID',
    feedback: 'feedback',
    Rating: 'Rating',
    RatingCustomer: 'RatingCustomer'
  };

  export type FeedbackRatingScalarFieldEnum = (typeof FeedbackRatingScalarFieldEnum)[keyof typeof FeedbackRatingScalarFieldEnum]


  export const ProviderSalaryScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    EPF: 'EPF',
    ETF: 'ETF',
    totSalary: 'totSalary'
  };

  export type ProviderSalaryScalarFieldEnum = (typeof ProviderSalaryScalarFieldEnum)[keyof typeof ProviderSalaryScalarFieldEnum]


  export const InFlowScalarFieldEnum: {
    id: 'id',
    flowDate: 'flowDate',
    inflowItem: 'inflowItem',
    Amount: 'Amount'
  };

  export type InFlowScalarFieldEnum = (typeof InFlowScalarFieldEnum)[keyof typeof InFlowScalarFieldEnum]


  export const OutFlowScalarFieldEnum: {
    id: 'id',
    OutDate: 'OutDate',
    outFlowItem: 'outFlowItem',
    Amount: 'Amount'
  };

  export type OutFlowScalarFieldEnum = (typeof OutFlowScalarFieldEnum)[keyof typeof OutFlowScalarFieldEnum]


  export const RevenueScalarFieldEnum: {
    id: 'id',
    Date: 'Date',
    Description: 'Description',
    Amount: 'Amount'
  };

  export type RevenueScalarFieldEnum = (typeof RevenueScalarFieldEnum)[keyof typeof RevenueScalarFieldEnum]


  export const ExpensesScalarFieldEnum: {
    id: 'id',
    Date: 'Date',
    Expense: 'Expense',
    Amount: 'Amount'
  };

  export type ExpensesScalarFieldEnum = (typeof ExpensesScalarFieldEnum)[keyof typeof ExpensesScalarFieldEnum]


  export const AssestsScalarFieldEnum: {
    id: 'id',
    Assests: 'Assests',
    Amount: 'Amount'
  };

  export type AssestsScalarFieldEnum = (typeof AssestsScalarFieldEnum)[keyof typeof AssestsScalarFieldEnum]


  export const LiabilityScalarFieldEnum: {
    id: 'id',
    Liability: 'Liability',
    Amount: 'Amount'
  };

  export type LiabilityScalarFieldEnum = (typeof LiabilityScalarFieldEnum)[keyof typeof LiabilityScalarFieldEnum]


  export const ProfitLossScalarFieldEnum: {
    id: 'id',
    month: 'month',
    totalrevenue: 'totalrevenue',
    totalExpence: 'totalExpence',
    NetAmount: 'NetAmount'
  };

  export type ProfitLossScalarFieldEnum = (typeof ProfitLossScalarFieldEnum)[keyof typeof ProfitLossScalarFieldEnum]


  export const SavedPaymentMethodScalarFieldEnum: {
    id: 'id',
    paymentMethod: 'paymentMethod',
    cardNumber: 'cardNumber',
    cardHolderName: 'cardHolderName'
  };

  export type SavedPaymentMethodScalarFieldEnum = (typeof SavedPaymentMethodScalarFieldEnum)[keyof typeof SavedPaymentMethodScalarFieldEnum]


  export const RefundRequestsScalarFieldEnum: {
    refundId: 'refundId',
    customerID: 'customerID',
    paymentId: 'paymentId',
    amount: 'amount',
    reason: 'reason',
    requestAt: 'requestAt',
    status: 'status'
  };

  export type RefundRequestsScalarFieldEnum = (typeof RefundRequestsScalarFieldEnum)[keyof typeof RefundRequestsScalarFieldEnum]


  export const DeductionRateScalarFieldEnum: {
    id: 'id',
    type: 'type',
    rate: 'rate'
  };

  export type DeductionRateScalarFieldEnum = (typeof DeductionRateScalarFieldEnum)[keyof typeof DeductionRateScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'complianStatus'
   */
  export type EnumcomplianStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'complianStatus'>
    


  /**
   * Reference to a field of type 'complianStatus[]'
   */
  export type ListEnumcomplianStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'complianStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'refundStatus'
   */
  export type EnumrefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'refundStatus'>
    


  /**
   * Reference to a field of type 'refundStatus[]'
   */
  export type ListEnumrefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'refundStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    FirstName?: StringNullableFilter<"Customer"> | string | null
    LastName?: StringNullableFilter<"Customer"> | string | null
    Gender?: StringNullableFilter<"Customer"> | string | null
    Email?: StringNullableFilter<"Customer"> | string | null
    Password?: StringNullableFilter<"Customer"> | string | null
    MobileNumber?: StringNullableFilter<"Customer"> | string | null
    NIC?: StringNullableFilter<"Customer"> | string | null
    Address?: StringNullableFilter<"Customer"> | string | null
    BookingID?: BookingListRelationFilter
    Complains?: ComplainListRelationFilter
    ServiceProvider?: Customer_ProviderListRelationFilter
    feedbackRating?: FeedbackRatingListRelationFilter
    refundRequests?: RefundRequestsListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    NIC?: SortOrder
    Address?: SortOrder
    BookingID?: BookingOrderByRelationAggregateInput
    Complains?: ComplainOrderByRelationAggregateInput
    ServiceProvider?: Customer_ProviderOrderByRelationAggregateInput
    feedbackRating?: FeedbackRatingOrderByRelationAggregateInput
    refundRequests?: RefundRequestsOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    Email?: string
    MobileNumber?: string
    NIC?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    FirstName?: StringNullableFilter<"Customer"> | string | null
    LastName?: StringNullableFilter<"Customer"> | string | null
    Gender?: StringNullableFilter<"Customer"> | string | null
    Password?: StringNullableFilter<"Customer"> | string | null
    Address?: StringNullableFilter<"Customer"> | string | null
    BookingID?: BookingListRelationFilter
    Complains?: ComplainListRelationFilter
    ServiceProvider?: Customer_ProviderListRelationFilter
    feedbackRating?: FeedbackRatingListRelationFilter
    refundRequests?: RefundRequestsListRelationFilter
  }, "id" | "Email" | "MobileNumber" | "NIC">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    NIC?: SortOrder
    Address?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    FirstName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    LastName?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Gender?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Password?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    MobileNumber?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    NIC?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    Address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    CategoryID?: StringFilter<"Category"> | string
    Type?: StringNullableFilter<"Category"> | string | null
    service?: ServiceListRelationFilter
    education?: EducationListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    CategoryID?: SortOrder
    Type?: SortOrder
    service?: ServiceOrderByRelationAggregateInput
    education?: EducationOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    CategoryID?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    Type?: StringNullableFilter<"Category"> | string | null
    service?: ServiceListRelationFilter
    education?: EducationListRelationFilter
  }, "CategoryID">

  export type CategoryOrderByWithAggregationInput = {
    CategoryID?: SortOrder
    Type?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    CategoryID?: StringWithAggregatesFilter<"Category"> | string
    Type?: StringNullableWithAggregatesFilter<"Category"> | string | null
  }

  export type EducationWhereInput = {
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    EducationId?: StringFilter<"Education"> | string
    deliveryMode?: StringNullableFilter<"Education"> | string | null
    categoryID?: StringFilter<"Education"> | string
    syllabus?: SyllabusListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type EducationOrderByWithRelationInput = {
    EducationId?: SortOrder
    deliveryMode?: SortOrder
    categoryID?: SortOrder
    syllabus?: SyllabusOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
  }

  export type EducationWhereUniqueInput = Prisma.AtLeast<{
    EducationId?: string
    AND?: EducationWhereInput | EducationWhereInput[]
    OR?: EducationWhereInput[]
    NOT?: EducationWhereInput | EducationWhereInput[]
    deliveryMode?: StringNullableFilter<"Education"> | string | null
    categoryID?: StringFilter<"Education"> | string
    syllabus?: SyllabusListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "EducationId">

  export type EducationOrderByWithAggregationInput = {
    EducationId?: SortOrder
    deliveryMode?: SortOrder
    categoryID?: SortOrder
    _count?: EducationCountOrderByAggregateInput
    _max?: EducationMaxOrderByAggregateInput
    _min?: EducationMinOrderByAggregateInput
  }

  export type EducationScalarWhereWithAggregatesInput = {
    AND?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    OR?: EducationScalarWhereWithAggregatesInput[]
    NOT?: EducationScalarWhereWithAggregatesInput | EducationScalarWhereWithAggregatesInput[]
    EducationId?: StringWithAggregatesFilter<"Education"> | string
    deliveryMode?: StringNullableWithAggregatesFilter<"Education"> | string | null
    categoryID?: StringWithAggregatesFilter<"Education"> | string
  }

  export type SyllabusWhereInput = {
    AND?: SyllabusWhereInput | SyllabusWhereInput[]
    OR?: SyllabusWhereInput[]
    NOT?: SyllabusWhereInput | SyllabusWhereInput[]
    SyllabusID?: StringFilter<"Syllabus"> | string
    Title?: StringNullableFilter<"Syllabus"> | string | null
    Description?: StringNullableFilter<"Syllabus"> | string | null
    educationID?: StringFilter<"Syllabus"> | string
    education?: XOR<EducationScalarRelationFilter, EducationWhereInput>
    subjects?: SyllabusSubjectListRelationFilter
  }

  export type SyllabusOrderByWithRelationInput = {
    SyllabusID?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    educationID?: SortOrder
    education?: EducationOrderByWithRelationInput
    subjects?: SyllabusSubjectOrderByRelationAggregateInput
  }

  export type SyllabusWhereUniqueInput = Prisma.AtLeast<{
    SyllabusID?: string
    AND?: SyllabusWhereInput | SyllabusWhereInput[]
    OR?: SyllabusWhereInput[]
    NOT?: SyllabusWhereInput | SyllabusWhereInput[]
    Title?: StringNullableFilter<"Syllabus"> | string | null
    Description?: StringNullableFilter<"Syllabus"> | string | null
    educationID?: StringFilter<"Syllabus"> | string
    education?: XOR<EducationScalarRelationFilter, EducationWhereInput>
    subjects?: SyllabusSubjectListRelationFilter
  }, "SyllabusID">

  export type SyllabusOrderByWithAggregationInput = {
    SyllabusID?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    educationID?: SortOrder
    _count?: SyllabusCountOrderByAggregateInput
    _max?: SyllabusMaxOrderByAggregateInput
    _min?: SyllabusMinOrderByAggregateInput
  }

  export type SyllabusScalarWhereWithAggregatesInput = {
    AND?: SyllabusScalarWhereWithAggregatesInput | SyllabusScalarWhereWithAggregatesInput[]
    OR?: SyllabusScalarWhereWithAggregatesInput[]
    NOT?: SyllabusScalarWhereWithAggregatesInput | SyllabusScalarWhereWithAggregatesInput[]
    SyllabusID?: StringWithAggregatesFilter<"Syllabus"> | string
    Title?: StringNullableWithAggregatesFilter<"Syllabus"> | string | null
    Description?: StringNullableWithAggregatesFilter<"Syllabus"> | string | null
    educationID?: StringWithAggregatesFilter<"Syllabus"> | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    SubjectID?: StringFilter<"Subject"> | string
    Name?: StringFilter<"Subject"> | string
    syllabuses?: SyllabusSubjectListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    SubjectID?: SortOrder
    Name?: SortOrder
    syllabuses?: SyllabusSubjectOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    SubjectID?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    Name?: StringFilter<"Subject"> | string
    syllabuses?: SyllabusSubjectListRelationFilter
  }, "SubjectID">

  export type SubjectOrderByWithAggregationInput = {
    SubjectID?: SortOrder
    Name?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    SubjectID?: StringWithAggregatesFilter<"Subject"> | string
    Name?: StringWithAggregatesFilter<"Subject"> | string
  }

  export type SyllabusSubjectWhereInput = {
    AND?: SyllabusSubjectWhereInput | SyllabusSubjectWhereInput[]
    OR?: SyllabusSubjectWhereInput[]
    NOT?: SyllabusSubjectWhereInput | SyllabusSubjectWhereInput[]
    id?: StringFilter<"SyllabusSubject"> | string
    syllabusID?: StringFilter<"SyllabusSubject"> | string
    subjectID?: StringFilter<"SyllabusSubject"> | string
    syllabus?: XOR<SyllabusScalarRelationFilter, SyllabusWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }

  export type SyllabusSubjectOrderByWithRelationInput = {
    id?: SortOrder
    syllabusID?: SortOrder
    subjectID?: SortOrder
    syllabus?: SyllabusOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type SyllabusSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syllabusID_subjectID?: SyllabusSubjectSyllabusIDSubjectIDCompoundUniqueInput
    AND?: SyllabusSubjectWhereInput | SyllabusSubjectWhereInput[]
    OR?: SyllabusSubjectWhereInput[]
    NOT?: SyllabusSubjectWhereInput | SyllabusSubjectWhereInput[]
    syllabusID?: StringFilter<"SyllabusSubject"> | string
    subjectID?: StringFilter<"SyllabusSubject"> | string
    syllabus?: XOR<SyllabusScalarRelationFilter, SyllabusWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }, "id" | "syllabusID_subjectID">

  export type SyllabusSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    syllabusID?: SortOrder
    subjectID?: SortOrder
    _count?: SyllabusSubjectCountOrderByAggregateInput
    _max?: SyllabusSubjectMaxOrderByAggregateInput
    _min?: SyllabusSubjectMinOrderByAggregateInput
  }

  export type SyllabusSubjectScalarWhereWithAggregatesInput = {
    AND?: SyllabusSubjectScalarWhereWithAggregatesInput | SyllabusSubjectScalarWhereWithAggregatesInput[]
    OR?: SyllabusSubjectScalarWhereWithAggregatesInput[]
    NOT?: SyllabusSubjectScalarWhereWithAggregatesInput | SyllabusSubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyllabusSubject"> | string
    syllabusID?: StringWithAggregatesFilter<"SyllabusSubject"> | string
    subjectID?: StringWithAggregatesFilter<"SyllabusSubject"> | string
  }

  export type ComplainWhereInput = {
    AND?: ComplainWhereInput | ComplainWhereInput[]
    OR?: ComplainWhereInput[]
    NOT?: ComplainWhereInput | ComplainWhereInput[]
    complainId?: StringFilter<"Complain"> | string
    Reason?: StringNullableFilter<"Complain"> | string | null
    Status?: EnumcomplianStatusFilter<"Complain"> | $Enums.complianStatus
    CustomerId?: StringFilter<"Complain"> | string
    Customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type ComplainOrderByWithRelationInput = {
    complainId?: SortOrder
    Reason?: SortOrder
    Status?: SortOrder
    CustomerId?: SortOrder
    Customers?: CustomerOrderByWithRelationInput
  }

  export type ComplainWhereUniqueInput = Prisma.AtLeast<{
    complainId?: string
    AND?: ComplainWhereInput | ComplainWhereInput[]
    OR?: ComplainWhereInput[]
    NOT?: ComplainWhereInput | ComplainWhereInput[]
    Reason?: StringNullableFilter<"Complain"> | string | null
    Status?: EnumcomplianStatusFilter<"Complain"> | $Enums.complianStatus
    CustomerId?: StringFilter<"Complain"> | string
    Customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "complainId">

  export type ComplainOrderByWithAggregationInput = {
    complainId?: SortOrder
    Reason?: SortOrder
    Status?: SortOrder
    CustomerId?: SortOrder
    _count?: ComplainCountOrderByAggregateInput
    _max?: ComplainMaxOrderByAggregateInput
    _min?: ComplainMinOrderByAggregateInput
  }

  export type ComplainScalarWhereWithAggregatesInput = {
    AND?: ComplainScalarWhereWithAggregatesInput | ComplainScalarWhereWithAggregatesInput[]
    OR?: ComplainScalarWhereWithAggregatesInput[]
    NOT?: ComplainScalarWhereWithAggregatesInput | ComplainScalarWhereWithAggregatesInput[]
    complainId?: StringWithAggregatesFilter<"Complain"> | string
    Reason?: StringNullableWithAggregatesFilter<"Complain"> | string | null
    Status?: EnumcomplianStatusWithAggregatesFilter<"Complain"> | $Enums.complianStatus
    CustomerId?: StringWithAggregatesFilter<"Complain"> | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    ServiceID?: StringFilter<"Service"> | string
    ServiceName?: StringFilter<"Service"> | string
    Category?: StringFilter<"Service"> | string
    CommisionRate?: IntFilter<"Service"> | number
    Description?: StringFilter<"Service"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    serviceProvider?: ServiceProviderListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    ServiceID?: SortOrder
    ServiceName?: SortOrder
    Category?: SortOrder
    CommisionRate?: SortOrder
    Description?: SortOrder
    category?: CategoryOrderByWithRelationInput
    serviceProvider?: ServiceProviderOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    ServiceID?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    ServiceName?: StringFilter<"Service"> | string
    Category?: StringFilter<"Service"> | string
    CommisionRate?: IntFilter<"Service"> | number
    Description?: StringFilter<"Service"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    serviceProvider?: ServiceProviderListRelationFilter
  }, "ServiceID">

  export type ServiceOrderByWithAggregationInput = {
    ServiceID?: SortOrder
    ServiceName?: SortOrder
    Category?: SortOrder
    CommisionRate?: SortOrder
    Description?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    ServiceID?: StringWithAggregatesFilter<"Service"> | string
    ServiceName?: StringWithAggregatesFilter<"Service"> | string
    Category?: StringWithAggregatesFilter<"Service"> | string
    CommisionRate?: IntWithAggregatesFilter<"Service"> | number
    Description?: StringWithAggregatesFilter<"Service"> | string
  }

  export type AdministratorWhereInput = {
    AND?: AdministratorWhereInput | AdministratorWhereInput[]
    OR?: AdministratorWhereInput[]
    NOT?: AdministratorWhereInput | AdministratorWhereInput[]
    AdminID?: StringFilter<"Administrator"> | string
    Name?: StringNullableFilter<"Administrator"> | string | null
    Email?: StringNullableFilter<"Administrator"> | string | null
    Password?: StringNullableFilter<"Administrator"> | string | null
    MobileNumber?: StringNullableFilter<"Administrator"> | string | null
  }

  export type AdministratorOrderByWithRelationInput = {
    AdminID?: SortOrder
    Name?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
  }

  export type AdministratorWhereUniqueInput = Prisma.AtLeast<{
    AdminID?: string
    Email?: string
    Password?: string
    MobileNumber?: string
    AND?: AdministratorWhereInput | AdministratorWhereInput[]
    OR?: AdministratorWhereInput[]
    NOT?: AdministratorWhereInput | AdministratorWhereInput[]
    Name?: StringNullableFilter<"Administrator"> | string | null
  }, "AdminID" | "Email" | "Password" | "MobileNumber">

  export type AdministratorOrderByWithAggregationInput = {
    AdminID?: SortOrder
    Name?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    _count?: AdministratorCountOrderByAggregateInput
    _max?: AdministratorMaxOrderByAggregateInput
    _min?: AdministratorMinOrderByAggregateInput
  }

  export type AdministratorScalarWhereWithAggregatesInput = {
    AND?: AdministratorScalarWhereWithAggregatesInput | AdministratorScalarWhereWithAggregatesInput[]
    OR?: AdministratorScalarWhereWithAggregatesInput[]
    NOT?: AdministratorScalarWhereWithAggregatesInput | AdministratorScalarWhereWithAggregatesInput[]
    AdminID?: StringWithAggregatesFilter<"Administrator"> | string
    Name?: StringNullableWithAggregatesFilter<"Administrator"> | string | null
    Email?: StringNullableWithAggregatesFilter<"Administrator"> | string | null
    Password?: StringNullableWithAggregatesFilter<"Administrator"> | string | null
    MobileNumber?: StringNullableWithAggregatesFilter<"Administrator"> | string | null
  }

  export type ServiceProviderWhereInput = {
    AND?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    OR?: ServiceProviderWhereInput[]
    NOT?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    ProviderID?: StringFilter<"ServiceProvider"> | string
    FirstName?: StringNullableFilter<"ServiceProvider"> | string | null
    LastName?: StringNullableFilter<"ServiceProvider"> | string | null
    MobileNumber?: StringNullableFilter<"ServiceProvider"> | string | null
    NIC?: StringNullableFilter<"ServiceProvider"> | string | null
    Address?: StringNullableFilter<"ServiceProvider"> | string | null
    email?: StringNullableFilter<"ServiceProvider"> | string | null
    password?: StringFilter<"ServiceProvider"> | string
    Availability?: BoolFilter<"ServiceProvider"> | boolean
    ServiceType?: StringFilter<"ServiceProvider"> | string
    bookings?: BookingListRelationFilter
    serviceProvider_Reports?: XOR<ServiceProvider_ReportsNullableScalarRelationFilter, ServiceProvider_ReportsWhereInput> | null
    schedule?: XOR<ScheduleNullableScalarRelationFilter, ScheduleWhereInput> | null
    customer?: Customer_ProviderListRelationFilter
    providerSalary?: XOR<ProviderSalaryNullableScalarRelationFilter, ProviderSalaryWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ServiceProviderOrderByWithRelationInput = {
    ProviderID?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    MobileNumber?: SortOrder
    NIC?: SortOrder
    Address?: SortOrder
    email?: SortOrder
    password?: SortOrder
    Availability?: SortOrder
    ServiceType?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    serviceProvider_Reports?: ServiceProvider_ReportsOrderByWithRelationInput
    schedule?: ScheduleOrderByWithRelationInput
    customer?: Customer_ProviderOrderByRelationAggregateInput
    providerSalary?: ProviderSalaryOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type ServiceProviderWhereUniqueInput = Prisma.AtLeast<{
    ProviderID?: string
    MobileNumber?: string
    NIC?: string
    email?: string
    password?: string
    AND?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    OR?: ServiceProviderWhereInput[]
    NOT?: ServiceProviderWhereInput | ServiceProviderWhereInput[]
    FirstName?: StringNullableFilter<"ServiceProvider"> | string | null
    LastName?: StringNullableFilter<"ServiceProvider"> | string | null
    Address?: StringNullableFilter<"ServiceProvider"> | string | null
    Availability?: BoolFilter<"ServiceProvider"> | boolean
    ServiceType?: StringFilter<"ServiceProvider"> | string
    bookings?: BookingListRelationFilter
    serviceProvider_Reports?: XOR<ServiceProvider_ReportsNullableScalarRelationFilter, ServiceProvider_ReportsWhereInput> | null
    schedule?: XOR<ScheduleNullableScalarRelationFilter, ScheduleWhereInput> | null
    customer?: Customer_ProviderListRelationFilter
    providerSalary?: XOR<ProviderSalaryNullableScalarRelationFilter, ProviderSalaryWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "ProviderID" | "MobileNumber" | "NIC" | "email" | "password">

  export type ServiceProviderOrderByWithAggregationInput = {
    ProviderID?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    MobileNumber?: SortOrder
    NIC?: SortOrder
    Address?: SortOrder
    email?: SortOrder
    password?: SortOrder
    Availability?: SortOrder
    ServiceType?: SortOrder
    _count?: ServiceProviderCountOrderByAggregateInput
    _max?: ServiceProviderMaxOrderByAggregateInput
    _min?: ServiceProviderMinOrderByAggregateInput
  }

  export type ServiceProviderScalarWhereWithAggregatesInput = {
    AND?: ServiceProviderScalarWhereWithAggregatesInput | ServiceProviderScalarWhereWithAggregatesInput[]
    OR?: ServiceProviderScalarWhereWithAggregatesInput[]
    NOT?: ServiceProviderScalarWhereWithAggregatesInput | ServiceProviderScalarWhereWithAggregatesInput[]
    ProviderID?: StringWithAggregatesFilter<"ServiceProvider"> | string
    FirstName?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    LastName?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    MobileNumber?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    NIC?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    Address?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    email?: StringNullableWithAggregatesFilter<"ServiceProvider"> | string | null
    password?: StringWithAggregatesFilter<"ServiceProvider"> | string
    Availability?: BoolWithAggregatesFilter<"ServiceProvider"> | boolean
    ServiceType?: StringWithAggregatesFilter<"ServiceProvider"> | string
  }

  export type Customer_ProviderWhereInput = {
    AND?: Customer_ProviderWhereInput | Customer_ProviderWhereInput[]
    OR?: Customer_ProviderWhereInput[]
    NOT?: Customer_ProviderWhereInput | Customer_ProviderWhereInput[]
    id?: StringFilter<"Customer_Provider"> | string
    customer?: StringFilter<"Customer_Provider"> | string
    provider?: StringFilter<"Customer_Provider"> | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type Customer_ProviderOrderByWithRelationInput = {
    id?: SortOrder
    customer?: SortOrder
    provider?: SortOrder
    serviceProvider?: ServiceProviderOrderByWithRelationInput
    customers?: CustomerOrderByWithRelationInput
  }

  export type Customer_ProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customer_provider?: Customer_ProviderCustomerProviderCompoundUniqueInput
    AND?: Customer_ProviderWhereInput | Customer_ProviderWhereInput[]
    OR?: Customer_ProviderWhereInput[]
    NOT?: Customer_ProviderWhereInput | Customer_ProviderWhereInput[]
    customer?: StringFilter<"Customer_Provider"> | string
    provider?: StringFilter<"Customer_Provider"> | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
    customers?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id" | "customer_provider">

  export type Customer_ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    customer?: SortOrder
    provider?: SortOrder
    _count?: Customer_ProviderCountOrderByAggregateInput
    _max?: Customer_ProviderMaxOrderByAggregateInput
    _min?: Customer_ProviderMinOrderByAggregateInput
  }

  export type Customer_ProviderScalarWhereWithAggregatesInput = {
    AND?: Customer_ProviderScalarWhereWithAggregatesInput | Customer_ProviderScalarWhereWithAggregatesInput[]
    OR?: Customer_ProviderScalarWhereWithAggregatesInput[]
    NOT?: Customer_ProviderScalarWhereWithAggregatesInput | Customer_ProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer_Provider"> | string
    customer?: StringWithAggregatesFilter<"Customer_Provider"> | string
    provider?: StringWithAggregatesFilter<"Customer_Provider"> | string
  }

  export type ServiceProvider_ReportsWhereInput = {
    AND?: ServiceProvider_ReportsWhereInput | ServiceProvider_ReportsWhereInput[]
    OR?: ServiceProvider_ReportsWhereInput[]
    NOT?: ServiceProvider_ReportsWhereInput | ServiceProvider_ReportsWhereInput[]
    ReportID?: StringFilter<"ServiceProvider_Reports"> | string
    Provider?: StringFilter<"ServiceProvider_Reports"> | string
    BirthCertificate?: StringNullableFilter<"ServiceProvider_Reports"> | string | null
    PoliceReport?: StringNullableFilter<"ServiceProvider_Reports"> | string | null
    NIC_Copy?: StringNullableFilter<"ServiceProvider_Reports"> | string | null
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }

  export type ServiceProvider_ReportsOrderByWithRelationInput = {
    ReportID?: SortOrder
    Provider?: SortOrder
    BirthCertificate?: SortOrder
    PoliceReport?: SortOrder
    NIC_Copy?: SortOrder
    serviceProvider?: ServiceProviderOrderByWithRelationInput
  }

  export type ServiceProvider_ReportsWhereUniqueInput = Prisma.AtLeast<{
    ReportID?: string
    Provider?: string
    AND?: ServiceProvider_ReportsWhereInput | ServiceProvider_ReportsWhereInput[]
    OR?: ServiceProvider_ReportsWhereInput[]
    NOT?: ServiceProvider_ReportsWhereInput | ServiceProvider_ReportsWhereInput[]
    BirthCertificate?: StringNullableFilter<"ServiceProvider_Reports"> | string | null
    PoliceReport?: StringNullableFilter<"ServiceProvider_Reports"> | string | null
    NIC_Copy?: StringNullableFilter<"ServiceProvider_Reports"> | string | null
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }, "ReportID" | "Provider">

  export type ServiceProvider_ReportsOrderByWithAggregationInput = {
    ReportID?: SortOrder
    Provider?: SortOrder
    BirthCertificate?: SortOrder
    PoliceReport?: SortOrder
    NIC_Copy?: SortOrder
    _count?: ServiceProvider_ReportsCountOrderByAggregateInput
    _max?: ServiceProvider_ReportsMaxOrderByAggregateInput
    _min?: ServiceProvider_ReportsMinOrderByAggregateInput
  }

  export type ServiceProvider_ReportsScalarWhereWithAggregatesInput = {
    AND?: ServiceProvider_ReportsScalarWhereWithAggregatesInput | ServiceProvider_ReportsScalarWhereWithAggregatesInput[]
    OR?: ServiceProvider_ReportsScalarWhereWithAggregatesInput[]
    NOT?: ServiceProvider_ReportsScalarWhereWithAggregatesInput | ServiceProvider_ReportsScalarWhereWithAggregatesInput[]
    ReportID?: StringWithAggregatesFilter<"ServiceProvider_Reports"> | string
    Provider?: StringWithAggregatesFilter<"ServiceProvider_Reports"> | string
    BirthCertificate?: StringNullableWithAggregatesFilter<"ServiceProvider_Reports"> | string | null
    PoliceReport?: StringNullableWithAggregatesFilter<"ServiceProvider_Reports"> | string | null
    NIC_Copy?: StringNullableWithAggregatesFilter<"ServiceProvider_Reports"> | string | null
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    BookingID?: StringFilter<"Booking"> | string
    AgreementDuration?: StringNullableFilter<"Booking"> | string | null
    Booking_Service?: StringNullableFilter<"Booking"> | string | null
    Provider?: StringFilter<"Booking"> | string
    MonthlyPayment?: FloatNullableFilter<"Booking"> | number | null
    BookingDate?: DateTimeFilter<"Booking"> | Date | string
    Status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    CustomerID?: StringFilter<"Booking"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
    payment?: PaymentListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    BookingID?: SortOrder
    AgreementDuration?: SortOrder
    Booking_Service?: SortOrder
    Provider?: SortOrder
    MonthlyPayment?: SortOrder
    BookingDate?: SortOrder
    Status?: SortOrder
    CustomerID?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    serviceProvider?: ServiceProviderOrderByWithRelationInput
    payment?: PaymentOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    BookingID?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    AgreementDuration?: StringNullableFilter<"Booking"> | string | null
    Booking_Service?: StringNullableFilter<"Booking"> | string | null
    Provider?: StringFilter<"Booking"> | string
    MonthlyPayment?: FloatNullableFilter<"Booking"> | number | null
    BookingDate?: DateTimeFilter<"Booking"> | Date | string
    Status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    CustomerID?: StringFilter<"Booking"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
    payment?: PaymentListRelationFilter
  }, "BookingID">

  export type BookingOrderByWithAggregationInput = {
    BookingID?: SortOrder
    AgreementDuration?: SortOrder
    Booking_Service?: SortOrder
    Provider?: SortOrder
    MonthlyPayment?: SortOrder
    BookingDate?: SortOrder
    Status?: SortOrder
    CustomerID?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    BookingID?: StringWithAggregatesFilter<"Booking"> | string
    AgreementDuration?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    Booking_Service?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    Provider?: StringWithAggregatesFilter<"Booking"> | string
    MonthlyPayment?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    BookingDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    Status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    CustomerID?: StringWithAggregatesFilter<"Booking"> | string
  }

  export type PaymentMethodWhereInput = {
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    MethodId?: StringFilter<"PaymentMethod"> | string
    PaymentType?: StringNullableFilter<"PaymentMethod"> | string | null
    Description?: StringNullableFilter<"PaymentMethod"> | string | null
    payment?: PaymentListRelationFilter
  }

  export type PaymentMethodOrderByWithRelationInput = {
    MethodId?: SortOrder
    PaymentType?: SortOrder
    Description?: SortOrder
    payment?: PaymentOrderByRelationAggregateInput
  }

  export type PaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    MethodId?: string
    AND?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    OR?: PaymentMethodWhereInput[]
    NOT?: PaymentMethodWhereInput | PaymentMethodWhereInput[]
    PaymentType?: StringNullableFilter<"PaymentMethod"> | string | null
    Description?: StringNullableFilter<"PaymentMethod"> | string | null
    payment?: PaymentListRelationFilter
  }, "MethodId">

  export type PaymentMethodOrderByWithAggregationInput = {
    MethodId?: SortOrder
    PaymentType?: SortOrder
    Description?: SortOrder
    _count?: PaymentMethodCountOrderByAggregateInput
    _max?: PaymentMethodMaxOrderByAggregateInput
    _min?: PaymentMethodMinOrderByAggregateInput
  }

  export type PaymentMethodScalarWhereWithAggregatesInput = {
    AND?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    OR?: PaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: PaymentMethodScalarWhereWithAggregatesInput | PaymentMethodScalarWhereWithAggregatesInput[]
    MethodId?: StringWithAggregatesFilter<"PaymentMethod"> | string
    PaymentType?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
    Description?: StringNullableWithAggregatesFilter<"PaymentMethod"> | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    paymentID?: StringFilter<"Payment"> | string
    PaymentDate?: DateTimeFilter<"Payment"> | Date | string
    Amount?: FloatNullableFilter<"Payment"> | number | null
    PaymentMethod?: StringFilter<"Payment"> | string
    BookingId?: StringFilter<"Payment"> | string
    Status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    refundRequests?: XOR<RefundRequestsNullableScalarRelationFilter, RefundRequestsWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    paymentID?: SortOrder
    PaymentDate?: SortOrder
    Amount?: SortOrder
    PaymentMethod?: SortOrder
    BookingId?: SortOrder
    Status?: SortOrder
    paymentMethod?: PaymentMethodOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    refundRequests?: RefundRequestsOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    paymentID?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    PaymentDate?: DateTimeFilter<"Payment"> | Date | string
    Amount?: FloatNullableFilter<"Payment"> | number | null
    PaymentMethod?: StringFilter<"Payment"> | string
    BookingId?: StringFilter<"Payment"> | string
    Status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: XOR<PaymentMethodScalarRelationFilter, PaymentMethodWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    refundRequests?: XOR<RefundRequestsNullableScalarRelationFilter, RefundRequestsWhereInput> | null
  }, "paymentID">

  export type PaymentOrderByWithAggregationInput = {
    paymentID?: SortOrder
    PaymentDate?: SortOrder
    Amount?: SortOrder
    PaymentMethod?: SortOrder
    BookingId?: SortOrder
    Status?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    paymentID?: StringWithAggregatesFilter<"Payment"> | string
    PaymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    Amount?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    PaymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    BookingId?: StringWithAggregatesFilter<"Payment"> | string
    Status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    scheduleId?: StringFilter<"Schedule"> | string
    scheduleDate?: DateTimeFilter<"Schedule"> | Date | string
    AgreementTime?: StringNullableFilter<"Schedule"> | string | null
    startDate?: StringNullableFilter<"Schedule"> | string | null
    provider?: StringFilter<"Schedule"> | string
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }

  export type ScheduleOrderByWithRelationInput = {
    scheduleId?: SortOrder
    scheduleDate?: SortOrder
    AgreementTime?: SortOrder
    startDate?: SortOrder
    provider?: SortOrder
    serviceProvider?: ServiceProviderOrderByWithRelationInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    scheduleId?: string
    provider?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    scheduleDate?: DateTimeFilter<"Schedule"> | Date | string
    AgreementTime?: StringNullableFilter<"Schedule"> | string | null
    startDate?: StringNullableFilter<"Schedule"> | string | null
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }, "scheduleId" | "provider">

  export type ScheduleOrderByWithAggregationInput = {
    scheduleId?: SortOrder
    scheduleDate?: SortOrder
    AgreementTime?: SortOrder
    startDate?: SortOrder
    provider?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    scheduleId?: StringWithAggregatesFilter<"Schedule"> | string
    scheduleDate?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    AgreementTime?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    startDate?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    provider?: StringWithAggregatesFilter<"Schedule"> | string
  }

  export type FeedbackRatingWhereInput = {
    AND?: FeedbackRatingWhereInput | FeedbackRatingWhereInput[]
    OR?: FeedbackRatingWhereInput[]
    NOT?: FeedbackRatingWhereInput | FeedbackRatingWhereInput[]
    feedbackID?: StringFilter<"FeedbackRating"> | string
    feedback?: StringNullableFilter<"FeedbackRating"> | string | null
    Rating?: IntNullableFilter<"FeedbackRating"> | number | null
    RatingCustomer?: StringFilter<"FeedbackRating"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type FeedbackRatingOrderByWithRelationInput = {
    feedbackID?: SortOrder
    feedback?: SortOrder
    Rating?: SortOrder
    RatingCustomer?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type FeedbackRatingWhereUniqueInput = Prisma.AtLeast<{
    feedbackID?: string
    AND?: FeedbackRatingWhereInput | FeedbackRatingWhereInput[]
    OR?: FeedbackRatingWhereInput[]
    NOT?: FeedbackRatingWhereInput | FeedbackRatingWhereInput[]
    feedback?: StringNullableFilter<"FeedbackRating"> | string | null
    Rating?: IntNullableFilter<"FeedbackRating"> | number | null
    RatingCustomer?: StringFilter<"FeedbackRating"> | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "feedbackID">

  export type FeedbackRatingOrderByWithAggregationInput = {
    feedbackID?: SortOrder
    feedback?: SortOrder
    Rating?: SortOrder
    RatingCustomer?: SortOrder
    _count?: FeedbackRatingCountOrderByAggregateInput
    _avg?: FeedbackRatingAvgOrderByAggregateInput
    _max?: FeedbackRatingMaxOrderByAggregateInput
    _min?: FeedbackRatingMinOrderByAggregateInput
    _sum?: FeedbackRatingSumOrderByAggregateInput
  }

  export type FeedbackRatingScalarWhereWithAggregatesInput = {
    AND?: FeedbackRatingScalarWhereWithAggregatesInput | FeedbackRatingScalarWhereWithAggregatesInput[]
    OR?: FeedbackRatingScalarWhereWithAggregatesInput[]
    NOT?: FeedbackRatingScalarWhereWithAggregatesInput | FeedbackRatingScalarWhereWithAggregatesInput[]
    feedbackID?: StringWithAggregatesFilter<"FeedbackRating"> | string
    feedback?: StringNullableWithAggregatesFilter<"FeedbackRating"> | string | null
    Rating?: IntNullableWithAggregatesFilter<"FeedbackRating"> | number | null
    RatingCustomer?: StringWithAggregatesFilter<"FeedbackRating"> | string
  }

  export type ProviderSalaryWhereInput = {
    AND?: ProviderSalaryWhereInput | ProviderSalaryWhereInput[]
    OR?: ProviderSalaryWhereInput[]
    NOT?: ProviderSalaryWhereInput | ProviderSalaryWhereInput[]
    id?: StringFilter<"ProviderSalary"> | string
    provider?: StringFilter<"ProviderSalary"> | string
    EPF?: FloatNullableFilter<"ProviderSalary"> | number | null
    ETF?: FloatNullableFilter<"ProviderSalary"> | number | null
    totSalary?: FloatNullableFilter<"ProviderSalary"> | number | null
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }

  export type ProviderSalaryOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    EPF?: SortOrder
    ETF?: SortOrder
    totSalary?: SortOrder
    serviceProvider?: ServiceProviderOrderByWithRelationInput
  }

  export type ProviderSalaryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider?: string
    AND?: ProviderSalaryWhereInput | ProviderSalaryWhereInput[]
    OR?: ProviderSalaryWhereInput[]
    NOT?: ProviderSalaryWhereInput | ProviderSalaryWhereInput[]
    EPF?: FloatNullableFilter<"ProviderSalary"> | number | null
    ETF?: FloatNullableFilter<"ProviderSalary"> | number | null
    totSalary?: FloatNullableFilter<"ProviderSalary"> | number | null
    serviceProvider?: XOR<ServiceProviderScalarRelationFilter, ServiceProviderWhereInput>
  }, "id" | "provider">

  export type ProviderSalaryOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    EPF?: SortOrder
    ETF?: SortOrder
    totSalary?: SortOrder
    _count?: ProviderSalaryCountOrderByAggregateInput
    _avg?: ProviderSalaryAvgOrderByAggregateInput
    _max?: ProviderSalaryMaxOrderByAggregateInput
    _min?: ProviderSalaryMinOrderByAggregateInput
    _sum?: ProviderSalarySumOrderByAggregateInput
  }

  export type ProviderSalaryScalarWhereWithAggregatesInput = {
    AND?: ProviderSalaryScalarWhereWithAggregatesInput | ProviderSalaryScalarWhereWithAggregatesInput[]
    OR?: ProviderSalaryScalarWhereWithAggregatesInput[]
    NOT?: ProviderSalaryScalarWhereWithAggregatesInput | ProviderSalaryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProviderSalary"> | string
    provider?: StringWithAggregatesFilter<"ProviderSalary"> | string
    EPF?: FloatNullableWithAggregatesFilter<"ProviderSalary"> | number | null
    ETF?: FloatNullableWithAggregatesFilter<"ProviderSalary"> | number | null
    totSalary?: FloatNullableWithAggregatesFilter<"ProviderSalary"> | number | null
  }

  export type InFlowWhereInput = {
    AND?: InFlowWhereInput | InFlowWhereInput[]
    OR?: InFlowWhereInput[]
    NOT?: InFlowWhereInput | InFlowWhereInput[]
    id?: StringFilter<"InFlow"> | string
    flowDate?: DateTimeNullableFilter<"InFlow"> | Date | string | null
    inflowItem?: StringNullableFilter<"InFlow"> | string | null
    Amount?: FloatNullableFilter<"InFlow"> | number | null
  }

  export type InFlowOrderByWithRelationInput = {
    id?: SortOrder
    flowDate?: SortOrder
    inflowItem?: SortOrder
    Amount?: SortOrder
  }

  export type InFlowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InFlowWhereInput | InFlowWhereInput[]
    OR?: InFlowWhereInput[]
    NOT?: InFlowWhereInput | InFlowWhereInput[]
    flowDate?: DateTimeNullableFilter<"InFlow"> | Date | string | null
    inflowItem?: StringNullableFilter<"InFlow"> | string | null
    Amount?: FloatNullableFilter<"InFlow"> | number | null
  }, "id">

  export type InFlowOrderByWithAggregationInput = {
    id?: SortOrder
    flowDate?: SortOrder
    inflowItem?: SortOrder
    Amount?: SortOrder
    _count?: InFlowCountOrderByAggregateInput
    _avg?: InFlowAvgOrderByAggregateInput
    _max?: InFlowMaxOrderByAggregateInput
    _min?: InFlowMinOrderByAggregateInput
    _sum?: InFlowSumOrderByAggregateInput
  }

  export type InFlowScalarWhereWithAggregatesInput = {
    AND?: InFlowScalarWhereWithAggregatesInput | InFlowScalarWhereWithAggregatesInput[]
    OR?: InFlowScalarWhereWithAggregatesInput[]
    NOT?: InFlowScalarWhereWithAggregatesInput | InFlowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InFlow"> | string
    flowDate?: DateTimeNullableWithAggregatesFilter<"InFlow"> | Date | string | null
    inflowItem?: StringNullableWithAggregatesFilter<"InFlow"> | string | null
    Amount?: FloatNullableWithAggregatesFilter<"InFlow"> | number | null
  }

  export type OutFlowWhereInput = {
    AND?: OutFlowWhereInput | OutFlowWhereInput[]
    OR?: OutFlowWhereInput[]
    NOT?: OutFlowWhereInput | OutFlowWhereInput[]
    id?: StringFilter<"OutFlow"> | string
    OutDate?: DateTimeNullableFilter<"OutFlow"> | Date | string | null
    outFlowItem?: StringNullableFilter<"OutFlow"> | string | null
    Amount?: FloatNullableFilter<"OutFlow"> | number | null
  }

  export type OutFlowOrderByWithRelationInput = {
    id?: SortOrder
    OutDate?: SortOrder
    outFlowItem?: SortOrder
    Amount?: SortOrder
  }

  export type OutFlowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutFlowWhereInput | OutFlowWhereInput[]
    OR?: OutFlowWhereInput[]
    NOT?: OutFlowWhereInput | OutFlowWhereInput[]
    OutDate?: DateTimeNullableFilter<"OutFlow"> | Date | string | null
    outFlowItem?: StringNullableFilter<"OutFlow"> | string | null
    Amount?: FloatNullableFilter<"OutFlow"> | number | null
  }, "id">

  export type OutFlowOrderByWithAggregationInput = {
    id?: SortOrder
    OutDate?: SortOrder
    outFlowItem?: SortOrder
    Amount?: SortOrder
    _count?: OutFlowCountOrderByAggregateInput
    _avg?: OutFlowAvgOrderByAggregateInput
    _max?: OutFlowMaxOrderByAggregateInput
    _min?: OutFlowMinOrderByAggregateInput
    _sum?: OutFlowSumOrderByAggregateInput
  }

  export type OutFlowScalarWhereWithAggregatesInput = {
    AND?: OutFlowScalarWhereWithAggregatesInput | OutFlowScalarWhereWithAggregatesInput[]
    OR?: OutFlowScalarWhereWithAggregatesInput[]
    NOT?: OutFlowScalarWhereWithAggregatesInput | OutFlowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutFlow"> | string
    OutDate?: DateTimeNullableWithAggregatesFilter<"OutFlow"> | Date | string | null
    outFlowItem?: StringNullableWithAggregatesFilter<"OutFlow"> | string | null
    Amount?: FloatNullableWithAggregatesFilter<"OutFlow"> | number | null
  }

  export type RevenueWhereInput = {
    AND?: RevenueWhereInput | RevenueWhereInput[]
    OR?: RevenueWhereInput[]
    NOT?: RevenueWhereInput | RevenueWhereInput[]
    id?: StringFilter<"Revenue"> | string
    Date?: DateTimeFilter<"Revenue"> | Date | string
    Description?: StringNullableFilter<"Revenue"> | string | null
    Amount?: FloatNullableFilter<"Revenue"> | number | null
  }

  export type RevenueOrderByWithRelationInput = {
    id?: SortOrder
    Date?: SortOrder
    Description?: SortOrder
    Amount?: SortOrder
  }

  export type RevenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RevenueWhereInput | RevenueWhereInput[]
    OR?: RevenueWhereInput[]
    NOT?: RevenueWhereInput | RevenueWhereInput[]
    Date?: DateTimeFilter<"Revenue"> | Date | string
    Description?: StringNullableFilter<"Revenue"> | string | null
    Amount?: FloatNullableFilter<"Revenue"> | number | null
  }, "id">

  export type RevenueOrderByWithAggregationInput = {
    id?: SortOrder
    Date?: SortOrder
    Description?: SortOrder
    Amount?: SortOrder
    _count?: RevenueCountOrderByAggregateInput
    _avg?: RevenueAvgOrderByAggregateInput
    _max?: RevenueMaxOrderByAggregateInput
    _min?: RevenueMinOrderByAggregateInput
    _sum?: RevenueSumOrderByAggregateInput
  }

  export type RevenueScalarWhereWithAggregatesInput = {
    AND?: RevenueScalarWhereWithAggregatesInput | RevenueScalarWhereWithAggregatesInput[]
    OR?: RevenueScalarWhereWithAggregatesInput[]
    NOT?: RevenueScalarWhereWithAggregatesInput | RevenueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Revenue"> | string
    Date?: DateTimeWithAggregatesFilter<"Revenue"> | Date | string
    Description?: StringNullableWithAggregatesFilter<"Revenue"> | string | null
    Amount?: FloatNullableWithAggregatesFilter<"Revenue"> | number | null
  }

  export type ExpensesWhereInput = {
    AND?: ExpensesWhereInput | ExpensesWhereInput[]
    OR?: ExpensesWhereInput[]
    NOT?: ExpensesWhereInput | ExpensesWhereInput[]
    id?: StringFilter<"Expenses"> | string
    Date?: DateTimeFilter<"Expenses"> | Date | string
    Expense?: StringNullableFilter<"Expenses"> | string | null
    Amount?: FloatNullableFilter<"Expenses"> | number | null
  }

  export type ExpensesOrderByWithRelationInput = {
    id?: SortOrder
    Date?: SortOrder
    Expense?: SortOrder
    Amount?: SortOrder
  }

  export type ExpensesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExpensesWhereInput | ExpensesWhereInput[]
    OR?: ExpensesWhereInput[]
    NOT?: ExpensesWhereInput | ExpensesWhereInput[]
    Date?: DateTimeFilter<"Expenses"> | Date | string
    Expense?: StringNullableFilter<"Expenses"> | string | null
    Amount?: FloatNullableFilter<"Expenses"> | number | null
  }, "id">

  export type ExpensesOrderByWithAggregationInput = {
    id?: SortOrder
    Date?: SortOrder
    Expense?: SortOrder
    Amount?: SortOrder
    _count?: ExpensesCountOrderByAggregateInput
    _avg?: ExpensesAvgOrderByAggregateInput
    _max?: ExpensesMaxOrderByAggregateInput
    _min?: ExpensesMinOrderByAggregateInput
    _sum?: ExpensesSumOrderByAggregateInput
  }

  export type ExpensesScalarWhereWithAggregatesInput = {
    AND?: ExpensesScalarWhereWithAggregatesInput | ExpensesScalarWhereWithAggregatesInput[]
    OR?: ExpensesScalarWhereWithAggregatesInput[]
    NOT?: ExpensesScalarWhereWithAggregatesInput | ExpensesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expenses"> | string
    Date?: DateTimeWithAggregatesFilter<"Expenses"> | Date | string
    Expense?: StringNullableWithAggregatesFilter<"Expenses"> | string | null
    Amount?: FloatNullableWithAggregatesFilter<"Expenses"> | number | null
  }

  export type AssestsWhereInput = {
    AND?: AssestsWhereInput | AssestsWhereInput[]
    OR?: AssestsWhereInput[]
    NOT?: AssestsWhereInput | AssestsWhereInput[]
    id?: StringFilter<"Assests"> | string
    Assests?: StringNullableFilter<"Assests"> | string | null
    Amount?: FloatNullableFilter<"Assests"> | number | null
  }

  export type AssestsOrderByWithRelationInput = {
    id?: SortOrder
    Assests?: SortOrder
    Amount?: SortOrder
  }

  export type AssestsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssestsWhereInput | AssestsWhereInput[]
    OR?: AssestsWhereInput[]
    NOT?: AssestsWhereInput | AssestsWhereInput[]
    Assests?: StringNullableFilter<"Assests"> | string | null
    Amount?: FloatNullableFilter<"Assests"> | number | null
  }, "id">

  export type AssestsOrderByWithAggregationInput = {
    id?: SortOrder
    Assests?: SortOrder
    Amount?: SortOrder
    _count?: AssestsCountOrderByAggregateInput
    _avg?: AssestsAvgOrderByAggregateInput
    _max?: AssestsMaxOrderByAggregateInput
    _min?: AssestsMinOrderByAggregateInput
    _sum?: AssestsSumOrderByAggregateInput
  }

  export type AssestsScalarWhereWithAggregatesInput = {
    AND?: AssestsScalarWhereWithAggregatesInput | AssestsScalarWhereWithAggregatesInput[]
    OR?: AssestsScalarWhereWithAggregatesInput[]
    NOT?: AssestsScalarWhereWithAggregatesInput | AssestsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assests"> | string
    Assests?: StringNullableWithAggregatesFilter<"Assests"> | string | null
    Amount?: FloatNullableWithAggregatesFilter<"Assests"> | number | null
  }

  export type LiabilityWhereInput = {
    AND?: LiabilityWhereInput | LiabilityWhereInput[]
    OR?: LiabilityWhereInput[]
    NOT?: LiabilityWhereInput | LiabilityWhereInput[]
    id?: StringFilter<"Liability"> | string
    Liability?: StringNullableFilter<"Liability"> | string | null
    Amount?: FloatNullableFilter<"Liability"> | number | null
  }

  export type LiabilityOrderByWithRelationInput = {
    id?: SortOrder
    Liability?: SortOrder
    Amount?: SortOrder
  }

  export type LiabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LiabilityWhereInput | LiabilityWhereInput[]
    OR?: LiabilityWhereInput[]
    NOT?: LiabilityWhereInput | LiabilityWhereInput[]
    Liability?: StringNullableFilter<"Liability"> | string | null
    Amount?: FloatNullableFilter<"Liability"> | number | null
  }, "id">

  export type LiabilityOrderByWithAggregationInput = {
    id?: SortOrder
    Liability?: SortOrder
    Amount?: SortOrder
    _count?: LiabilityCountOrderByAggregateInput
    _avg?: LiabilityAvgOrderByAggregateInput
    _max?: LiabilityMaxOrderByAggregateInput
    _min?: LiabilityMinOrderByAggregateInput
    _sum?: LiabilitySumOrderByAggregateInput
  }

  export type LiabilityScalarWhereWithAggregatesInput = {
    AND?: LiabilityScalarWhereWithAggregatesInput | LiabilityScalarWhereWithAggregatesInput[]
    OR?: LiabilityScalarWhereWithAggregatesInput[]
    NOT?: LiabilityScalarWhereWithAggregatesInput | LiabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Liability"> | string
    Liability?: StringNullableWithAggregatesFilter<"Liability"> | string | null
    Amount?: FloatNullableWithAggregatesFilter<"Liability"> | number | null
  }

  export type profitLossWhereInput = {
    AND?: profitLossWhereInput | profitLossWhereInput[]
    OR?: profitLossWhereInput[]
    NOT?: profitLossWhereInput | profitLossWhereInput[]
    id?: StringFilter<"profitLoss"> | string
    month?: DateTimeNullableFilter<"profitLoss"> | Date | string | null
    totalrevenue?: FloatNullableFilter<"profitLoss"> | number | null
    totalExpence?: FloatNullableFilter<"profitLoss"> | number | null
    NetAmount?: FloatNullableFilter<"profitLoss"> | number | null
  }

  export type profitLossOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrder
    totalrevenue?: SortOrder
    totalExpence?: SortOrder
    NetAmount?: SortOrder
  }

  export type profitLossWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: profitLossWhereInput | profitLossWhereInput[]
    OR?: profitLossWhereInput[]
    NOT?: profitLossWhereInput | profitLossWhereInput[]
    month?: DateTimeNullableFilter<"profitLoss"> | Date | string | null
    totalrevenue?: FloatNullableFilter<"profitLoss"> | number | null
    totalExpence?: FloatNullableFilter<"profitLoss"> | number | null
    NetAmount?: FloatNullableFilter<"profitLoss"> | number | null
  }, "id">

  export type profitLossOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrder
    totalrevenue?: SortOrder
    totalExpence?: SortOrder
    NetAmount?: SortOrder
    _count?: profitLossCountOrderByAggregateInput
    _avg?: profitLossAvgOrderByAggregateInput
    _max?: profitLossMaxOrderByAggregateInput
    _min?: profitLossMinOrderByAggregateInput
    _sum?: profitLossSumOrderByAggregateInput
  }

  export type profitLossScalarWhereWithAggregatesInput = {
    AND?: profitLossScalarWhereWithAggregatesInput | profitLossScalarWhereWithAggregatesInput[]
    OR?: profitLossScalarWhereWithAggregatesInput[]
    NOT?: profitLossScalarWhereWithAggregatesInput | profitLossScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"profitLoss"> | string
    month?: DateTimeNullableWithAggregatesFilter<"profitLoss"> | Date | string | null
    totalrevenue?: FloatNullableWithAggregatesFilter<"profitLoss"> | number | null
    totalExpence?: FloatNullableWithAggregatesFilter<"profitLoss"> | number | null
    NetAmount?: FloatNullableWithAggregatesFilter<"profitLoss"> | number | null
  }

  export type savedPaymentMethodWhereInput = {
    AND?: savedPaymentMethodWhereInput | savedPaymentMethodWhereInput[]
    OR?: savedPaymentMethodWhereInput[]
    NOT?: savedPaymentMethodWhereInput | savedPaymentMethodWhereInput[]
    id?: StringFilter<"savedPaymentMethod"> | string
    paymentMethod?: StringNullableFilter<"savedPaymentMethod"> | string | null
    cardNumber?: StringNullableFilter<"savedPaymentMethod"> | string | null
    cardHolderName?: StringNullableFilter<"savedPaymentMethod"> | string | null
  }

  export type savedPaymentMethodOrderByWithRelationInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    cardNumber?: SortOrder
    cardHolderName?: SortOrder
  }

  export type savedPaymentMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: savedPaymentMethodWhereInput | savedPaymentMethodWhereInput[]
    OR?: savedPaymentMethodWhereInput[]
    NOT?: savedPaymentMethodWhereInput | savedPaymentMethodWhereInput[]
    paymentMethod?: StringNullableFilter<"savedPaymentMethod"> | string | null
    cardNumber?: StringNullableFilter<"savedPaymentMethod"> | string | null
    cardHolderName?: StringNullableFilter<"savedPaymentMethod"> | string | null
  }, "id">

  export type savedPaymentMethodOrderByWithAggregationInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    cardNumber?: SortOrder
    cardHolderName?: SortOrder
    _count?: savedPaymentMethodCountOrderByAggregateInput
    _max?: savedPaymentMethodMaxOrderByAggregateInput
    _min?: savedPaymentMethodMinOrderByAggregateInput
  }

  export type savedPaymentMethodScalarWhereWithAggregatesInput = {
    AND?: savedPaymentMethodScalarWhereWithAggregatesInput | savedPaymentMethodScalarWhereWithAggregatesInput[]
    OR?: savedPaymentMethodScalarWhereWithAggregatesInput[]
    NOT?: savedPaymentMethodScalarWhereWithAggregatesInput | savedPaymentMethodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"savedPaymentMethod"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"savedPaymentMethod"> | string | null
    cardNumber?: StringNullableWithAggregatesFilter<"savedPaymentMethod"> | string | null
    cardHolderName?: StringNullableWithAggregatesFilter<"savedPaymentMethod"> | string | null
  }

  export type RefundRequestsWhereInput = {
    AND?: RefundRequestsWhereInput | RefundRequestsWhereInput[]
    OR?: RefundRequestsWhereInput[]
    NOT?: RefundRequestsWhereInput | RefundRequestsWhereInput[]
    refundId?: StringFilter<"RefundRequests"> | string
    customerID?: StringFilter<"RefundRequests"> | string
    paymentId?: StringFilter<"RefundRequests"> | string
    amount?: FloatNullableFilter<"RefundRequests"> | number | null
    reason?: StringNullableFilter<"RefundRequests"> | string | null
    requestAt?: DateTimeFilter<"RefundRequests"> | Date | string
    status?: EnumrefundStatusFilter<"RefundRequests"> | $Enums.refundStatus
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }

  export type RefundRequestsOrderByWithRelationInput = {
    refundId?: SortOrder
    customerID?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    requestAt?: SortOrder
    status?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
  }

  export type RefundRequestsWhereUniqueInput = Prisma.AtLeast<{
    refundId?: string
    paymentId?: string
    AND?: RefundRequestsWhereInput | RefundRequestsWhereInput[]
    OR?: RefundRequestsWhereInput[]
    NOT?: RefundRequestsWhereInput | RefundRequestsWhereInput[]
    customerID?: StringFilter<"RefundRequests"> | string
    amount?: FloatNullableFilter<"RefundRequests"> | number | null
    reason?: StringNullableFilter<"RefundRequests"> | string | null
    requestAt?: DateTimeFilter<"RefundRequests"> | Date | string
    status?: EnumrefundStatusFilter<"RefundRequests"> | $Enums.refundStatus
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }, "refundId" | "paymentId">

  export type RefundRequestsOrderByWithAggregationInput = {
    refundId?: SortOrder
    customerID?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    requestAt?: SortOrder
    status?: SortOrder
    _count?: RefundRequestsCountOrderByAggregateInput
    _avg?: RefundRequestsAvgOrderByAggregateInput
    _max?: RefundRequestsMaxOrderByAggregateInput
    _min?: RefundRequestsMinOrderByAggregateInput
    _sum?: RefundRequestsSumOrderByAggregateInput
  }

  export type RefundRequestsScalarWhereWithAggregatesInput = {
    AND?: RefundRequestsScalarWhereWithAggregatesInput | RefundRequestsScalarWhereWithAggregatesInput[]
    OR?: RefundRequestsScalarWhereWithAggregatesInput[]
    NOT?: RefundRequestsScalarWhereWithAggregatesInput | RefundRequestsScalarWhereWithAggregatesInput[]
    refundId?: StringWithAggregatesFilter<"RefundRequests"> | string
    customerID?: StringWithAggregatesFilter<"RefundRequests"> | string
    paymentId?: StringWithAggregatesFilter<"RefundRequests"> | string
    amount?: FloatNullableWithAggregatesFilter<"RefundRequests"> | number | null
    reason?: StringNullableWithAggregatesFilter<"RefundRequests"> | string | null
    requestAt?: DateTimeWithAggregatesFilter<"RefundRequests"> | Date | string
    status?: EnumrefundStatusWithAggregatesFilter<"RefundRequests"> | $Enums.refundStatus
  }

  export type deductionRateWhereInput = {
    AND?: deductionRateWhereInput | deductionRateWhereInput[]
    OR?: deductionRateWhereInput[]
    NOT?: deductionRateWhereInput | deductionRateWhereInput[]
    id?: StringFilter<"deductionRate"> | string
    type?: StringNullableFilter<"deductionRate"> | string | null
    rate?: FloatNullableFilter<"deductionRate"> | number | null
  }

  export type deductionRateOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    rate?: SortOrder
  }

  export type deductionRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: deductionRateWhereInput | deductionRateWhereInput[]
    OR?: deductionRateWhereInput[]
    NOT?: deductionRateWhereInput | deductionRateWhereInput[]
    type?: StringNullableFilter<"deductionRate"> | string | null
    rate?: FloatNullableFilter<"deductionRate"> | number | null
  }, "id">

  export type deductionRateOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    rate?: SortOrder
    _count?: deductionRateCountOrderByAggregateInput
    _avg?: deductionRateAvgOrderByAggregateInput
    _max?: deductionRateMaxOrderByAggregateInput
    _min?: deductionRateMinOrderByAggregateInput
    _sum?: deductionRateSumOrderByAggregateInput
  }

  export type deductionRateScalarWhereWithAggregatesInput = {
    AND?: deductionRateScalarWhereWithAggregatesInput | deductionRateScalarWhereWithAggregatesInput[]
    OR?: deductionRateScalarWhereWithAggregatesInput[]
    NOT?: deductionRateScalarWhereWithAggregatesInput | deductionRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"deductionRate"> | string
    type?: StringNullableWithAggregatesFilter<"deductionRate"> | string | null
    rate?: FloatNullableWithAggregatesFilter<"deductionRate"> | number | null
  }

  export type CustomerCreateInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    BookingID?: BookingCreateNestedManyWithoutCustomerInput
    Complains?: ComplainCreateNestedManyWithoutCustomersInput
    ServiceProvider?: Customer_ProviderCreateNestedManyWithoutCustomersInput
    feedbackRating?: FeedbackRatingCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    BookingID?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    Complains?: ComplainUncheckedCreateNestedManyWithoutCustomersInput
    ServiceProvider?: Customer_ProviderUncheckedCreateNestedManyWithoutCustomersInput
    feedbackRating?: FeedbackRatingUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    BookingID?: BookingUpdateManyWithoutCustomerNestedInput
    Complains?: ComplainUpdateManyWithoutCustomersNestedInput
    ServiceProvider?: Customer_ProviderUpdateManyWithoutCustomersNestedInput
    feedbackRating?: FeedbackRatingUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    BookingID?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    Complains?: ComplainUncheckedUpdateManyWithoutCustomersNestedInput
    ServiceProvider?: Customer_ProviderUncheckedUpdateManyWithoutCustomersNestedInput
    feedbackRating?: FeedbackRatingUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateInput = {
    CategoryID?: string
    Type?: string | null
    service?: ServiceCreateNestedManyWithoutCategoryInput
    education?: EducationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    CategoryID?: string
    Type?: string | null
    service?: ServiceUncheckedCreateNestedManyWithoutCategoryInput
    education?: EducationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateManyWithoutCategoryNestedInput
    education?: EducationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput
    education?: EducationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    CategoryID?: string
    Type?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    Type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationCreateInput = {
    EducationId?: string
    deliveryMode?: string | null
    syllabus?: SyllabusCreateNestedManyWithoutEducationInput
    category: CategoryCreateNestedOneWithoutEducationInput
  }

  export type EducationUncheckedCreateInput = {
    EducationId?: string
    deliveryMode?: string | null
    categoryID: string
    syllabus?: SyllabusUncheckedCreateNestedManyWithoutEducationInput
  }

  export type EducationUpdateInput = {
    deliveryMode?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus?: SyllabusUpdateManyWithoutEducationNestedInput
    category?: CategoryUpdateOneRequiredWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateInput = {
    deliveryMode?: NullableStringFieldUpdateOperationsInput | string | null
    categoryID?: StringFieldUpdateOperationsInput | string
    syllabus?: SyllabusUncheckedUpdateManyWithoutEducationNestedInput
  }

  export type EducationCreateManyInput = {
    EducationId?: string
    deliveryMode?: string | null
    categoryID: string
  }

  export type EducationUpdateManyMutationInput = {
    deliveryMode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationUncheckedUpdateManyInput = {
    deliveryMode?: NullableStringFieldUpdateOperationsInput | string | null
    categoryID?: StringFieldUpdateOperationsInput | string
  }

  export type SyllabusCreateInput = {
    SyllabusID?: string
    Title?: string | null
    Description?: string | null
    education: EducationCreateNestedOneWithoutSyllabusInput
    subjects?: SyllabusSubjectCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusUncheckedCreateInput = {
    SyllabusID?: string
    Title?: string | null
    Description?: string | null
    educationID: string
    subjects?: SyllabusSubjectUncheckedCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusUpdateInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    education?: EducationUpdateOneRequiredWithoutSyllabusNestedInput
    subjects?: SyllabusSubjectUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    educationID?: StringFieldUpdateOperationsInput | string
    subjects?: SyllabusSubjectUncheckedUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusCreateManyInput = {
    SyllabusID?: string
    Title?: string | null
    Description?: string | null
    educationID: string
  }

  export type SyllabusUpdateManyMutationInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyllabusUncheckedUpdateManyInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    educationID?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectCreateInput = {
    SubjectID?: string
    Name: string
    syllabuses?: SyllabusSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    SubjectID?: string
    Name: string
    syllabuses?: SyllabusSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    syllabuses?: SyllabusSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    syllabuses?: SyllabusSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    SubjectID?: string
    Name: string
  }

  export type SubjectUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type SyllabusSubjectCreateInput = {
    id?: string
    syllabus: SyllabusCreateNestedOneWithoutSubjectsInput
    subject: SubjectCreateNestedOneWithoutSyllabusesInput
  }

  export type SyllabusSubjectUncheckedCreateInput = {
    id?: string
    syllabusID: string
    subjectID: string
  }

  export type SyllabusSubjectUpdateInput = {
    syllabus?: SyllabusUpdateOneRequiredWithoutSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutSyllabusesNestedInput
  }

  export type SyllabusSubjectUncheckedUpdateInput = {
    syllabusID?: StringFieldUpdateOperationsInput | string
    subjectID?: StringFieldUpdateOperationsInput | string
  }

  export type SyllabusSubjectCreateManyInput = {
    id?: string
    syllabusID: string
    subjectID: string
  }

  export type SyllabusSubjectUpdateManyMutationInput = {

  }

  export type SyllabusSubjectUncheckedUpdateManyInput = {
    syllabusID?: StringFieldUpdateOperationsInput | string
    subjectID?: StringFieldUpdateOperationsInput | string
  }

  export type ComplainCreateInput = {
    complainId?: string
    Reason?: string | null
    Status?: $Enums.complianStatus
    Customers: CustomerCreateNestedOneWithoutComplainsInput
  }

  export type ComplainUncheckedCreateInput = {
    complainId?: string
    Reason?: string | null
    Status?: $Enums.complianStatus
    CustomerId: string
  }

  export type ComplainUpdateInput = {
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: EnumcomplianStatusFieldUpdateOperationsInput | $Enums.complianStatus
    Customers?: CustomerUpdateOneRequiredWithoutComplainsNestedInput
  }

  export type ComplainUncheckedUpdateInput = {
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: EnumcomplianStatusFieldUpdateOperationsInput | $Enums.complianStatus
    CustomerId?: StringFieldUpdateOperationsInput | string
  }

  export type ComplainCreateManyInput = {
    complainId?: string
    Reason?: string | null
    Status?: $Enums.complianStatus
    CustomerId: string
  }

  export type ComplainUpdateManyMutationInput = {
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: EnumcomplianStatusFieldUpdateOperationsInput | $Enums.complianStatus
  }

  export type ComplainUncheckedUpdateManyInput = {
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: EnumcomplianStatusFieldUpdateOperationsInput | $Enums.complianStatus
    CustomerId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateInput = {
    ServiceID?: string
    ServiceName: string
    CommisionRate: number
    Description: string
    category: CategoryCreateNestedOneWithoutServiceInput
    serviceProvider?: ServiceProviderCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    ServiceID?: string
    ServiceName: string
    Category: string
    CommisionRate: number
    Description: string
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    CommisionRate?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutServiceNestedInput
    serviceProvider?: ServiceProviderUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    CommisionRate?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    ServiceID?: string
    ServiceName: string
    Category: string
    CommisionRate: number
    Description: string
  }

  export type ServiceUpdateManyMutationInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    CommisionRate?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    CommisionRate?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type AdministratorCreateInput = {
    AdminID?: string
    Name?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
  }

  export type AdministratorUncheckedCreateInput = {
    AdminID?: string
    Name?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
  }

  export type AdministratorUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdministratorUncheckedUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdministratorCreateManyInput = {
    AdminID?: string
    Name?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
  }

  export type AdministratorUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdministratorUncheckedUpdateManyInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceProviderCreateInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    bookings?: BookingCreateNestedManyWithoutServiceProviderInput
    serviceProvider_Reports?: ServiceProvider_ReportsCreateNestedOneWithoutServiceProviderInput
    schedule?: ScheduleCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderCreateNestedManyWithoutServiceProviderInput
    providerSalary?: ProviderSalaryCreateNestedOneWithoutServiceProviderInput
    service: ServiceCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    ServiceType: string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedCreateNestedOneWithoutServiceProviderInput
    schedule?: ScheduleUncheckedCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderUncheckedCreateNestedManyWithoutServiceProviderInput
    providerSalary?: ProviderSalaryUncheckedCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUpdateInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUpdateManyWithoutServiceProviderNestedInput
    serviceProvider_Reports?: ServiceProvider_ReportsUpdateOneWithoutServiceProviderNestedInput
    schedule?: ScheduleUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUpdateManyWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUpdateOneWithoutServiceProviderNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    ServiceType?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedUpdateOneWithoutServiceProviderNestedInput
    schedule?: ScheduleUncheckedUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUncheckedUpdateManyWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUncheckedUpdateOneWithoutServiceProviderNestedInput
  }

  export type ServiceProviderCreateManyInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    ServiceType: string
  }

  export type ServiceProviderUpdateManyMutationInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceProviderUncheckedUpdateManyInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    ServiceType?: StringFieldUpdateOperationsInput | string
  }

  export type Customer_ProviderCreateInput = {
    id?: string
    serviceProvider: ServiceProviderCreateNestedOneWithoutCustomerInput
    customers: CustomerCreateNestedOneWithoutServiceProviderInput
  }

  export type Customer_ProviderUncheckedCreateInput = {
    id?: string
    customer: string
    provider: string
  }

  export type Customer_ProviderUpdateInput = {
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutCustomerNestedInput
    customers?: CustomerUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type Customer_ProviderUncheckedUpdateInput = {
    customer?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type Customer_ProviderCreateManyInput = {
    id?: string
    customer: string
    provider: string
  }

  export type Customer_ProviderUpdateManyMutationInput = {

  }

  export type Customer_ProviderUncheckedUpdateManyInput = {
    customer?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceProvider_ReportsCreateInput = {
    ReportID?: string
    BirthCertificate?: string | null
    PoliceReport?: string | null
    NIC_Copy?: string | null
    serviceProvider: ServiceProviderCreateNestedOneWithoutServiceProvider_ReportsInput
  }

  export type ServiceProvider_ReportsUncheckedCreateInput = {
    ReportID?: string
    Provider: string
    BirthCertificate?: string | null
    PoliceReport?: string | null
    NIC_Copy?: string | null
  }

  export type ServiceProvider_ReportsUpdateInput = {
    BirthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    PoliceReport?: NullableStringFieldUpdateOperationsInput | string | null
    NIC_Copy?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutServiceProvider_ReportsNestedInput
  }

  export type ServiceProvider_ReportsUncheckedUpdateInput = {
    Provider?: StringFieldUpdateOperationsInput | string
    BirthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    PoliceReport?: NullableStringFieldUpdateOperationsInput | string | null
    NIC_Copy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceProvider_ReportsCreateManyInput = {
    ReportID?: string
    Provider: string
    BirthCertificate?: string | null
    PoliceReport?: string | null
    NIC_Copy?: string | null
  }

  export type ServiceProvider_ReportsUpdateManyMutationInput = {
    BirthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    PoliceReport?: NullableStringFieldUpdateOperationsInput | string | null
    NIC_Copy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceProvider_ReportsUncheckedUpdateManyInput = {
    Provider?: StringFieldUpdateOperationsInput | string
    BirthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    PoliceReport?: NullableStringFieldUpdateOperationsInput | string | null
    NIC_Copy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingCreateInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
    customer: CustomerCreateNestedOneWithoutBookingIDInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    Provider: string
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
    CustomerID: string
    payment?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    customer?: CustomerUpdateOneRequiredWithoutBookingIDNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: StringFieldUpdateOperationsInput | string
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    CustomerID?: StringFieldUpdateOperationsInput | string
    payment?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    Provider: string
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
    CustomerID: string
  }

  export type BookingUpdateManyMutationInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
  }

  export type BookingUncheckedUpdateManyInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: StringFieldUpdateOperationsInput | string
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    CustomerID?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentMethodCreateInput = {
    MethodId?: string
    PaymentType?: string | null
    Description?: string | null
    payment?: PaymentCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUncheckedCreateInput = {
    MethodId?: string
    PaymentType?: string | null
    Description?: string | null
    payment?: PaymentUncheckedCreateNestedManyWithoutPaymentMethodInput
  }

  export type PaymentMethodUpdateInput = {
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodUncheckedUpdateInput = {
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    payment?: PaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput
  }

  export type PaymentMethodCreateManyInput = {
    MethodId?: string
    PaymentType?: string | null
    Description?: string | null
  }

  export type PaymentMethodUpdateManyMutationInput = {
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodUncheckedUpdateManyInput = {
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    Status?: $Enums.PaymentStatus
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentInput
    booking: BookingCreateNestedOneWithoutPaymentInput
    refundRequests?: RefundRequestsCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    PaymentMethod: string
    BookingId: string
    Status?: $Enums.PaymentStatus
    refundRequests?: RefundRequestsUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentNestedInput
    booking?: BookingUpdateOneRequiredWithoutPaymentNestedInput
    refundRequests?: RefundRequestsUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentMethod?: StringFieldUpdateOperationsInput | string
    BookingId?: StringFieldUpdateOperationsInput | string
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    refundRequests?: RefundRequestsUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    PaymentMethod: string
    BookingId: string
    Status?: $Enums.PaymentStatus
  }

  export type PaymentUpdateManyMutationInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
  }

  export type PaymentUncheckedUpdateManyInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentMethod?: StringFieldUpdateOperationsInput | string
    BookingId?: StringFieldUpdateOperationsInput | string
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
  }

  export type ScheduleCreateInput = {
    scheduleId?: string
    scheduleDate?: Date | string
    AgreementTime?: string | null
    startDate?: string | null
    serviceProvider: ServiceProviderCreateNestedOneWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateInput = {
    scheduleId?: string
    scheduleDate?: Date | string
    AgreementTime?: string | null
    startDate?: string | null
    provider: string
  }

  export type ScheduleUpdateInput = {
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    AgreementTime?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    AgreementTime?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleCreateManyInput = {
    scheduleId?: string
    scheduleDate?: Date | string
    AgreementTime?: string | null
    startDate?: string | null
    provider: string
  }

  export type ScheduleUpdateManyMutationInput = {
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    AgreementTime?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleUncheckedUpdateManyInput = {
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    AgreementTime?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackRatingCreateInput = {
    feedbackID?: string
    feedback?: string | null
    Rating?: number | null
    customer: CustomerCreateNestedOneWithoutFeedbackRatingInput
  }

  export type FeedbackRatingUncheckedCreateInput = {
    feedbackID?: string
    feedback?: string | null
    Rating?: number | null
    RatingCustomer: string
  }

  export type FeedbackRatingUpdateInput = {
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    Rating?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: CustomerUpdateOneRequiredWithoutFeedbackRatingNestedInput
  }

  export type FeedbackRatingUncheckedUpdateInput = {
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    Rating?: NullableIntFieldUpdateOperationsInput | number | null
    RatingCustomer?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackRatingCreateManyInput = {
    feedbackID?: string
    feedback?: string | null
    Rating?: number | null
    RatingCustomer: string
  }

  export type FeedbackRatingUpdateManyMutationInput = {
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    Rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FeedbackRatingUncheckedUpdateManyInput = {
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    Rating?: NullableIntFieldUpdateOperationsInput | number | null
    RatingCustomer?: StringFieldUpdateOperationsInput | string
  }

  export type ProviderSalaryCreateInput = {
    id?: string
    EPF?: number | null
    ETF?: number | null
    totSalary?: number | null
    serviceProvider: ServiceProviderCreateNestedOneWithoutProviderSalaryInput
  }

  export type ProviderSalaryUncheckedCreateInput = {
    id?: string
    provider: string
    EPF?: number | null
    ETF?: number | null
    totSalary?: number | null
  }

  export type ProviderSalaryUpdateInput = {
    EPF?: NullableFloatFieldUpdateOperationsInput | number | null
    ETF?: NullableFloatFieldUpdateOperationsInput | number | null
    totSalary?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutProviderSalaryNestedInput
  }

  export type ProviderSalaryUncheckedUpdateInput = {
    provider?: StringFieldUpdateOperationsInput | string
    EPF?: NullableFloatFieldUpdateOperationsInput | number | null
    ETF?: NullableFloatFieldUpdateOperationsInput | number | null
    totSalary?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProviderSalaryCreateManyInput = {
    id?: string
    provider: string
    EPF?: number | null
    ETF?: number | null
    totSalary?: number | null
  }

  export type ProviderSalaryUpdateManyMutationInput = {
    EPF?: NullableFloatFieldUpdateOperationsInput | number | null
    ETF?: NullableFloatFieldUpdateOperationsInput | number | null
    totSalary?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProviderSalaryUncheckedUpdateManyInput = {
    provider?: StringFieldUpdateOperationsInput | string
    EPF?: NullableFloatFieldUpdateOperationsInput | number | null
    ETF?: NullableFloatFieldUpdateOperationsInput | number | null
    totSalary?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type InFlowCreateInput = {
    id?: string
    flowDate?: Date | string | null
    inflowItem?: string | null
    Amount?: number | null
  }

  export type InFlowUncheckedCreateInput = {
    id?: string
    flowDate?: Date | string | null
    inflowItem?: string | null
    Amount?: number | null
  }

  export type InFlowUpdateInput = {
    flowDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inflowItem?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type InFlowUncheckedUpdateInput = {
    flowDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inflowItem?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type InFlowCreateManyInput = {
    id?: string
    flowDate?: Date | string | null
    inflowItem?: string | null
    Amount?: number | null
  }

  export type InFlowUpdateManyMutationInput = {
    flowDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inflowItem?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type InFlowUncheckedUpdateManyInput = {
    flowDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inflowItem?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OutFlowCreateInput = {
    id?: string
    OutDate?: Date | string | null
    outFlowItem?: string | null
    Amount?: number | null
  }

  export type OutFlowUncheckedCreateInput = {
    id?: string
    OutDate?: Date | string | null
    outFlowItem?: string | null
    Amount?: number | null
  }

  export type OutFlowUpdateInput = {
    OutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outFlowItem?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OutFlowUncheckedUpdateInput = {
    OutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outFlowItem?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OutFlowCreateManyInput = {
    id?: string
    OutDate?: Date | string | null
    outFlowItem?: string | null
    Amount?: number | null
  }

  export type OutFlowUpdateManyMutationInput = {
    OutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outFlowItem?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type OutFlowUncheckedUpdateManyInput = {
    OutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    outFlowItem?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RevenueCreateInput = {
    id?: string
    Date?: Date | string
    Description?: string | null
    Amount?: number | null
  }

  export type RevenueUncheckedCreateInput = {
    id?: string
    Date?: Date | string
    Description?: string | null
    Amount?: number | null
  }

  export type RevenueUpdateInput = {
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RevenueUncheckedUpdateInput = {
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RevenueCreateManyInput = {
    id?: string
    Date?: Date | string
    Description?: string | null
    Amount?: number | null
  }

  export type RevenueUpdateManyMutationInput = {
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type RevenueUncheckedUpdateManyInput = {
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ExpensesCreateInput = {
    id?: string
    Date?: Date | string
    Expense?: string | null
    Amount?: number | null
  }

  export type ExpensesUncheckedCreateInput = {
    id?: string
    Date?: Date | string
    Expense?: string | null
    Amount?: number | null
  }

  export type ExpensesUpdateInput = {
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Expense?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ExpensesUncheckedUpdateInput = {
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Expense?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ExpensesCreateManyInput = {
    id?: string
    Date?: Date | string
    Expense?: string | null
    Amount?: number | null
  }

  export type ExpensesUpdateManyMutationInput = {
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Expense?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ExpensesUncheckedUpdateManyInput = {
    Date?: DateTimeFieldUpdateOperationsInput | Date | string
    Expense?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AssestsCreateInput = {
    id?: string
    Assests?: string | null
    Amount?: number | null
  }

  export type AssestsUncheckedCreateInput = {
    id?: string
    Assests?: string | null
    Amount?: number | null
  }

  export type AssestsUpdateInput = {
    Assests?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AssestsUncheckedUpdateInput = {
    Assests?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AssestsCreateManyInput = {
    id?: string
    Assests?: string | null
    Amount?: number | null
  }

  export type AssestsUpdateManyMutationInput = {
    Assests?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AssestsUncheckedUpdateManyInput = {
    Assests?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LiabilityCreateInput = {
    id?: string
    Liability?: string | null
    Amount?: number | null
  }

  export type LiabilityUncheckedCreateInput = {
    id?: string
    Liability?: string | null
    Amount?: number | null
  }

  export type LiabilityUpdateInput = {
    Liability?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LiabilityUncheckedUpdateInput = {
    Liability?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LiabilityCreateManyInput = {
    id?: string
    Liability?: string | null
    Amount?: number | null
  }

  export type LiabilityUpdateManyMutationInput = {
    Liability?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LiabilityUncheckedUpdateManyInput = {
    Liability?: NullableStringFieldUpdateOperationsInput | string | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type profitLossCreateInput = {
    id?: string
    month?: Date | string | null
    totalrevenue?: number | null
    totalExpence?: number | null
    NetAmount?: number | null
  }

  export type profitLossUncheckedCreateInput = {
    id?: string
    month?: Date | string | null
    totalrevenue?: number | null
    totalExpence?: number | null
    NetAmount?: number | null
  }

  export type profitLossUpdateInput = {
    month?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalrevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    totalExpence?: NullableFloatFieldUpdateOperationsInput | number | null
    NetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type profitLossUncheckedUpdateInput = {
    month?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalrevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    totalExpence?: NullableFloatFieldUpdateOperationsInput | number | null
    NetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type profitLossCreateManyInput = {
    id?: string
    month?: Date | string | null
    totalrevenue?: number | null
    totalExpence?: number | null
    NetAmount?: number | null
  }

  export type profitLossUpdateManyMutationInput = {
    month?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalrevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    totalExpence?: NullableFloatFieldUpdateOperationsInput | number | null
    NetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type profitLossUncheckedUpdateManyInput = {
    month?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalrevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    totalExpence?: NullableFloatFieldUpdateOperationsInput | number | null
    NetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type savedPaymentMethodCreateInput = {
    id?: string
    paymentMethod?: string | null
    cardNumber?: string | null
    cardHolderName?: string | null
  }

  export type savedPaymentMethodUncheckedCreateInput = {
    id?: string
    paymentMethod?: string | null
    cardNumber?: string | null
    cardHolderName?: string | null
  }

  export type savedPaymentMethodUpdateInput = {
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type savedPaymentMethodUncheckedUpdateInput = {
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type savedPaymentMethodCreateManyInput = {
    id?: string
    paymentMethod?: string | null
    cardNumber?: string | null
    cardHolderName?: string | null
  }

  export type savedPaymentMethodUpdateManyMutationInput = {
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type savedPaymentMethodUncheckedUpdateManyInput = {
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    cardHolderName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefundRequestsCreateInput = {
    refundId?: string
    amount?: number | null
    reason?: string | null
    requestAt?: Date | string
    status?: $Enums.refundStatus
    customer: CustomerCreateNestedOneWithoutRefundRequestsInput
    payment: PaymentCreateNestedOneWithoutRefundRequestsInput
  }

  export type RefundRequestsUncheckedCreateInput = {
    refundId?: string
    customerID: string
    paymentId: string
    amount?: number | null
    reason?: string | null
    requestAt?: Date | string
    status?: $Enums.refundStatus
  }

  export type RefundRequestsUpdateInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumrefundStatusFieldUpdateOperationsInput | $Enums.refundStatus
    customer?: CustomerUpdateOneRequiredWithoutRefundRequestsNestedInput
    payment?: PaymentUpdateOneRequiredWithoutRefundRequestsNestedInput
  }

  export type RefundRequestsUncheckedUpdateInput = {
    customerID?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumrefundStatusFieldUpdateOperationsInput | $Enums.refundStatus
  }

  export type RefundRequestsCreateManyInput = {
    refundId?: string
    customerID: string
    paymentId: string
    amount?: number | null
    reason?: string | null
    requestAt?: Date | string
    status?: $Enums.refundStatus
  }

  export type RefundRequestsUpdateManyMutationInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumrefundStatusFieldUpdateOperationsInput | $Enums.refundStatus
  }

  export type RefundRequestsUncheckedUpdateManyInput = {
    customerID?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumrefundStatusFieldUpdateOperationsInput | $Enums.refundStatus
  }

  export type deductionRateCreateInput = {
    id?: string
    type?: string | null
    rate?: number | null
  }

  export type deductionRateUncheckedCreateInput = {
    id?: string
    type?: string | null
    rate?: number | null
  }

  export type deductionRateUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deductionRateUncheckedUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deductionRateCreateManyInput = {
    id?: string
    type?: string | null
    rate?: number | null
  }

  export type deductionRateUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type deductionRateUncheckedUpdateManyInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ComplainListRelationFilter = {
    every?: ComplainWhereInput
    some?: ComplainWhereInput
    none?: ComplainWhereInput
  }

  export type Customer_ProviderListRelationFilter = {
    every?: Customer_ProviderWhereInput
    some?: Customer_ProviderWhereInput
    none?: Customer_ProviderWhereInput
  }

  export type FeedbackRatingListRelationFilter = {
    every?: FeedbackRatingWhereInput
    some?: FeedbackRatingWhereInput
    none?: FeedbackRatingWhereInput
  }

  export type RefundRequestsListRelationFilter = {
    every?: RefundRequestsWhereInput
    some?: RefundRequestsWhereInput
    none?: RefundRequestsWhereInput
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplainOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Customer_ProviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefundRequestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    NIC?: SortOrder
    Address?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    NIC?: SortOrder
    Address?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    Gender?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
    NIC?: SortOrder
    Address?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type EducationListRelationFilter = {
    every?: EducationWhereInput
    some?: EducationWhereInput
    none?: EducationWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    CategoryID?: SortOrder
    Type?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    CategoryID?: SortOrder
    Type?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    CategoryID?: SortOrder
    Type?: SortOrder
  }

  export type SyllabusListRelationFilter = {
    every?: SyllabusWhereInput
    some?: SyllabusWhereInput
    none?: SyllabusWhereInput
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type SyllabusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationCountOrderByAggregateInput = {
    EducationId?: SortOrder
    deliveryMode?: SortOrder
    categoryID?: SortOrder
  }

  export type EducationMaxOrderByAggregateInput = {
    EducationId?: SortOrder
    deliveryMode?: SortOrder
    categoryID?: SortOrder
  }

  export type EducationMinOrderByAggregateInput = {
    EducationId?: SortOrder
    deliveryMode?: SortOrder
    categoryID?: SortOrder
  }

  export type EducationScalarRelationFilter = {
    is?: EducationWhereInput
    isNot?: EducationWhereInput
  }

  export type SyllabusSubjectListRelationFilter = {
    every?: SyllabusSubjectWhereInput
    some?: SyllabusSubjectWhereInput
    none?: SyllabusSubjectWhereInput
  }

  export type SyllabusSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyllabusCountOrderByAggregateInput = {
    SyllabusID?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    educationID?: SortOrder
  }

  export type SyllabusMaxOrderByAggregateInput = {
    SyllabusID?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    educationID?: SortOrder
  }

  export type SyllabusMinOrderByAggregateInput = {
    SyllabusID?: SortOrder
    Title?: SortOrder
    Description?: SortOrder
    educationID?: SortOrder
  }

  export type SubjectCountOrderByAggregateInput = {
    SubjectID?: SortOrder
    Name?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    SubjectID?: SortOrder
    Name?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    SubjectID?: SortOrder
    Name?: SortOrder
  }

  export type SyllabusScalarRelationFilter = {
    is?: SyllabusWhereInput
    isNot?: SyllabusWhereInput
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type SyllabusSubjectSyllabusIDSubjectIDCompoundUniqueInput = {
    syllabusID: string
    subjectID: string
  }

  export type SyllabusSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    syllabusID?: SortOrder
    subjectID?: SortOrder
  }

  export type SyllabusSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    syllabusID?: SortOrder
    subjectID?: SortOrder
  }

  export type SyllabusSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    syllabusID?: SortOrder
    subjectID?: SortOrder
  }

  export type EnumcomplianStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.complianStatus | EnumcomplianStatusFieldRefInput<$PrismaModel>
    in?: $Enums.complianStatus[] | ListEnumcomplianStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.complianStatus[] | ListEnumcomplianStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumcomplianStatusFilter<$PrismaModel> | $Enums.complianStatus
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type ComplainCountOrderByAggregateInput = {
    complainId?: SortOrder
    Reason?: SortOrder
    Status?: SortOrder
    CustomerId?: SortOrder
  }

  export type ComplainMaxOrderByAggregateInput = {
    complainId?: SortOrder
    Reason?: SortOrder
    Status?: SortOrder
    CustomerId?: SortOrder
  }

  export type ComplainMinOrderByAggregateInput = {
    complainId?: SortOrder
    Reason?: SortOrder
    Status?: SortOrder
    CustomerId?: SortOrder
  }

  export type EnumcomplianStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.complianStatus | EnumcomplianStatusFieldRefInput<$PrismaModel>
    in?: $Enums.complianStatus[] | ListEnumcomplianStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.complianStatus[] | ListEnumcomplianStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumcomplianStatusWithAggregatesFilter<$PrismaModel> | $Enums.complianStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcomplianStatusFilter<$PrismaModel>
    _max?: NestedEnumcomplianStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ServiceProviderListRelationFilter = {
    every?: ServiceProviderWhereInput
    some?: ServiceProviderWhereInput
    none?: ServiceProviderWhereInput
  }

  export type ServiceProviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    ServiceID?: SortOrder
    ServiceName?: SortOrder
    Category?: SortOrder
    CommisionRate?: SortOrder
    Description?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    CommisionRate?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    ServiceID?: SortOrder
    ServiceName?: SortOrder
    Category?: SortOrder
    CommisionRate?: SortOrder
    Description?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    ServiceID?: SortOrder
    ServiceName?: SortOrder
    Category?: SortOrder
    CommisionRate?: SortOrder
    Description?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    CommisionRate?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AdministratorCountOrderByAggregateInput = {
    AdminID?: SortOrder
    Name?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
  }

  export type AdministratorMaxOrderByAggregateInput = {
    AdminID?: SortOrder
    Name?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
  }

  export type AdministratorMinOrderByAggregateInput = {
    AdminID?: SortOrder
    Name?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    MobileNumber?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ServiceProvider_ReportsNullableScalarRelationFilter = {
    is?: ServiceProvider_ReportsWhereInput | null
    isNot?: ServiceProvider_ReportsWhereInput | null
  }

  export type ScheduleNullableScalarRelationFilter = {
    is?: ScheduleWhereInput | null
    isNot?: ScheduleWhereInput | null
  }

  export type ProviderSalaryNullableScalarRelationFilter = {
    is?: ProviderSalaryWhereInput | null
    isNot?: ProviderSalaryWhereInput | null
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceProviderCountOrderByAggregateInput = {
    ProviderID?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    MobileNumber?: SortOrder
    NIC?: SortOrder
    Address?: SortOrder
    email?: SortOrder
    password?: SortOrder
    Availability?: SortOrder
    ServiceType?: SortOrder
  }

  export type ServiceProviderMaxOrderByAggregateInput = {
    ProviderID?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    MobileNumber?: SortOrder
    NIC?: SortOrder
    Address?: SortOrder
    email?: SortOrder
    password?: SortOrder
    Availability?: SortOrder
    ServiceType?: SortOrder
  }

  export type ServiceProviderMinOrderByAggregateInput = {
    ProviderID?: SortOrder
    FirstName?: SortOrder
    LastName?: SortOrder
    MobileNumber?: SortOrder
    NIC?: SortOrder
    Address?: SortOrder
    email?: SortOrder
    password?: SortOrder
    Availability?: SortOrder
    ServiceType?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ServiceProviderScalarRelationFilter = {
    is?: ServiceProviderWhereInput
    isNot?: ServiceProviderWhereInput
  }

  export type Customer_ProviderCustomerProviderCompoundUniqueInput = {
    customer: string
    provider: string
  }

  export type Customer_ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    customer?: SortOrder
    provider?: SortOrder
  }

  export type Customer_ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    customer?: SortOrder
    provider?: SortOrder
  }

  export type Customer_ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    customer?: SortOrder
    provider?: SortOrder
  }

  export type ServiceProvider_ReportsCountOrderByAggregateInput = {
    ReportID?: SortOrder
    Provider?: SortOrder
    BirthCertificate?: SortOrder
    PoliceReport?: SortOrder
    NIC_Copy?: SortOrder
  }

  export type ServiceProvider_ReportsMaxOrderByAggregateInput = {
    ReportID?: SortOrder
    Provider?: SortOrder
    BirthCertificate?: SortOrder
    PoliceReport?: SortOrder
    NIC_Copy?: SortOrder
  }

  export type ServiceProvider_ReportsMinOrderByAggregateInput = {
    ReportID?: SortOrder
    Provider?: SortOrder
    BirthCertificate?: SortOrder
    PoliceReport?: SortOrder
    NIC_Copy?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    BookingID?: SortOrder
    AgreementDuration?: SortOrder
    Booking_Service?: SortOrder
    Provider?: SortOrder
    MonthlyPayment?: SortOrder
    BookingDate?: SortOrder
    Status?: SortOrder
    CustomerID?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    MonthlyPayment?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    BookingID?: SortOrder
    AgreementDuration?: SortOrder
    Booking_Service?: SortOrder
    Provider?: SortOrder
    MonthlyPayment?: SortOrder
    BookingDate?: SortOrder
    Status?: SortOrder
    CustomerID?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    BookingID?: SortOrder
    AgreementDuration?: SortOrder
    Booking_Service?: SortOrder
    Provider?: SortOrder
    MonthlyPayment?: SortOrder
    BookingDate?: SortOrder
    Status?: SortOrder
    CustomerID?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    MonthlyPayment?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type PaymentMethodCountOrderByAggregateInput = {
    MethodId?: SortOrder
    PaymentType?: SortOrder
    Description?: SortOrder
  }

  export type PaymentMethodMaxOrderByAggregateInput = {
    MethodId?: SortOrder
    PaymentType?: SortOrder
    Description?: SortOrder
  }

  export type PaymentMethodMinOrderByAggregateInput = {
    MethodId?: SortOrder
    PaymentType?: SortOrder
    Description?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentMethodScalarRelationFilter = {
    is?: PaymentMethodWhereInput
    isNot?: PaymentMethodWhereInput
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type RefundRequestsNullableScalarRelationFilter = {
    is?: RefundRequestsWhereInput | null
    isNot?: RefundRequestsWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    paymentID?: SortOrder
    PaymentDate?: SortOrder
    Amount?: SortOrder
    PaymentMethod?: SortOrder
    BookingId?: SortOrder
    Status?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    paymentID?: SortOrder
    PaymentDate?: SortOrder
    Amount?: SortOrder
    PaymentMethod?: SortOrder
    BookingId?: SortOrder
    Status?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    paymentID?: SortOrder
    PaymentDate?: SortOrder
    Amount?: SortOrder
    PaymentMethod?: SortOrder
    BookingId?: SortOrder
    Status?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type ScheduleCountOrderByAggregateInput = {
    scheduleId?: SortOrder
    scheduleDate?: SortOrder
    AgreementTime?: SortOrder
    startDate?: SortOrder
    provider?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    scheduleId?: SortOrder
    scheduleDate?: SortOrder
    AgreementTime?: SortOrder
    startDate?: SortOrder
    provider?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    scheduleId?: SortOrder
    scheduleDate?: SortOrder
    AgreementTime?: SortOrder
    startDate?: SortOrder
    provider?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type FeedbackRatingCountOrderByAggregateInput = {
    feedbackID?: SortOrder
    feedback?: SortOrder
    Rating?: SortOrder
    RatingCustomer?: SortOrder
  }

  export type FeedbackRatingAvgOrderByAggregateInput = {
    Rating?: SortOrder
  }

  export type FeedbackRatingMaxOrderByAggregateInput = {
    feedbackID?: SortOrder
    feedback?: SortOrder
    Rating?: SortOrder
    RatingCustomer?: SortOrder
  }

  export type FeedbackRatingMinOrderByAggregateInput = {
    feedbackID?: SortOrder
    feedback?: SortOrder
    Rating?: SortOrder
    RatingCustomer?: SortOrder
  }

  export type FeedbackRatingSumOrderByAggregateInput = {
    Rating?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ProviderSalaryCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    EPF?: SortOrder
    ETF?: SortOrder
    totSalary?: SortOrder
  }

  export type ProviderSalaryAvgOrderByAggregateInput = {
    EPF?: SortOrder
    ETF?: SortOrder
    totSalary?: SortOrder
  }

  export type ProviderSalaryMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    EPF?: SortOrder
    ETF?: SortOrder
    totSalary?: SortOrder
  }

  export type ProviderSalaryMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    EPF?: SortOrder
    ETF?: SortOrder
    totSalary?: SortOrder
  }

  export type ProviderSalarySumOrderByAggregateInput = {
    EPF?: SortOrder
    ETF?: SortOrder
    totSalary?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type InFlowCountOrderByAggregateInput = {
    id?: SortOrder
    flowDate?: SortOrder
    inflowItem?: SortOrder
    Amount?: SortOrder
  }

  export type InFlowAvgOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type InFlowMaxOrderByAggregateInput = {
    id?: SortOrder
    flowDate?: SortOrder
    inflowItem?: SortOrder
    Amount?: SortOrder
  }

  export type InFlowMinOrderByAggregateInput = {
    id?: SortOrder
    flowDate?: SortOrder
    inflowItem?: SortOrder
    Amount?: SortOrder
  }

  export type InFlowSumOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type OutFlowCountOrderByAggregateInput = {
    id?: SortOrder
    OutDate?: SortOrder
    outFlowItem?: SortOrder
    Amount?: SortOrder
  }

  export type OutFlowAvgOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type OutFlowMaxOrderByAggregateInput = {
    id?: SortOrder
    OutDate?: SortOrder
    outFlowItem?: SortOrder
    Amount?: SortOrder
  }

  export type OutFlowMinOrderByAggregateInput = {
    id?: SortOrder
    OutDate?: SortOrder
    outFlowItem?: SortOrder
    Amount?: SortOrder
  }

  export type OutFlowSumOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type RevenueCountOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    Description?: SortOrder
    Amount?: SortOrder
  }

  export type RevenueAvgOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type RevenueMaxOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    Description?: SortOrder
    Amount?: SortOrder
  }

  export type RevenueMinOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    Description?: SortOrder
    Amount?: SortOrder
  }

  export type RevenueSumOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type ExpensesCountOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    Expense?: SortOrder
    Amount?: SortOrder
  }

  export type ExpensesAvgOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type ExpensesMaxOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    Expense?: SortOrder
    Amount?: SortOrder
  }

  export type ExpensesMinOrderByAggregateInput = {
    id?: SortOrder
    Date?: SortOrder
    Expense?: SortOrder
    Amount?: SortOrder
  }

  export type ExpensesSumOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type AssestsCountOrderByAggregateInput = {
    id?: SortOrder
    Assests?: SortOrder
    Amount?: SortOrder
  }

  export type AssestsAvgOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type AssestsMaxOrderByAggregateInput = {
    id?: SortOrder
    Assests?: SortOrder
    Amount?: SortOrder
  }

  export type AssestsMinOrderByAggregateInput = {
    id?: SortOrder
    Assests?: SortOrder
    Amount?: SortOrder
  }

  export type AssestsSumOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type LiabilityCountOrderByAggregateInput = {
    id?: SortOrder
    Liability?: SortOrder
    Amount?: SortOrder
  }

  export type LiabilityAvgOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type LiabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    Liability?: SortOrder
    Amount?: SortOrder
  }

  export type LiabilityMinOrderByAggregateInput = {
    id?: SortOrder
    Liability?: SortOrder
    Amount?: SortOrder
  }

  export type LiabilitySumOrderByAggregateInput = {
    Amount?: SortOrder
  }

  export type profitLossCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    totalrevenue?: SortOrder
    totalExpence?: SortOrder
    NetAmount?: SortOrder
  }

  export type profitLossAvgOrderByAggregateInput = {
    totalrevenue?: SortOrder
    totalExpence?: SortOrder
    NetAmount?: SortOrder
  }

  export type profitLossMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    totalrevenue?: SortOrder
    totalExpence?: SortOrder
    NetAmount?: SortOrder
  }

  export type profitLossMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    totalrevenue?: SortOrder
    totalExpence?: SortOrder
    NetAmount?: SortOrder
  }

  export type profitLossSumOrderByAggregateInput = {
    totalrevenue?: SortOrder
    totalExpence?: SortOrder
    NetAmount?: SortOrder
  }

  export type savedPaymentMethodCountOrderByAggregateInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    cardNumber?: SortOrder
    cardHolderName?: SortOrder
  }

  export type savedPaymentMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    cardNumber?: SortOrder
    cardHolderName?: SortOrder
  }

  export type savedPaymentMethodMinOrderByAggregateInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    cardNumber?: SortOrder
    cardHolderName?: SortOrder
  }

  export type EnumrefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.refundStatus | EnumrefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.refundStatus[] | ListEnumrefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.refundStatus[] | ListEnumrefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumrefundStatusFilter<$PrismaModel> | $Enums.refundStatus
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type RefundRequestsCountOrderByAggregateInput = {
    refundId?: SortOrder
    customerID?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    requestAt?: SortOrder
    status?: SortOrder
  }

  export type RefundRequestsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RefundRequestsMaxOrderByAggregateInput = {
    refundId?: SortOrder
    customerID?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    requestAt?: SortOrder
    status?: SortOrder
  }

  export type RefundRequestsMinOrderByAggregateInput = {
    refundId?: SortOrder
    customerID?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    requestAt?: SortOrder
    status?: SortOrder
  }

  export type RefundRequestsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumrefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.refundStatus | EnumrefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.refundStatus[] | ListEnumrefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.refundStatus[] | ListEnumrefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumrefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.refundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrefundStatusFilter<$PrismaModel>
    _max?: NestedEnumrefundStatusFilter<$PrismaModel>
  }

  export type deductionRateCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    rate?: SortOrder
  }

  export type deductionRateAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type deductionRateMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    rate?: SortOrder
  }

  export type deductionRateMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    rate?: SortOrder
  }

  export type deductionRateSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type BookingCreateNestedManyWithoutCustomerInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ComplainCreateNestedManyWithoutCustomersInput = {
    create?: XOR<ComplainCreateWithoutCustomersInput, ComplainUncheckedCreateWithoutCustomersInput> | ComplainCreateWithoutCustomersInput[] | ComplainUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ComplainCreateOrConnectWithoutCustomersInput | ComplainCreateOrConnectWithoutCustomersInput[]
    createMany?: ComplainCreateManyCustomersInputEnvelope
    connect?: ComplainWhereUniqueInput | ComplainWhereUniqueInput[]
  }

  export type Customer_ProviderCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Customer_ProviderCreateWithoutCustomersInput, Customer_ProviderUncheckedCreateWithoutCustomersInput> | Customer_ProviderCreateWithoutCustomersInput[] | Customer_ProviderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: Customer_ProviderCreateOrConnectWithoutCustomersInput | Customer_ProviderCreateOrConnectWithoutCustomersInput[]
    createMany?: Customer_ProviderCreateManyCustomersInputEnvelope
    connect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
  }

  export type FeedbackRatingCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FeedbackRatingCreateWithoutCustomerInput, FeedbackRatingUncheckedCreateWithoutCustomerInput> | FeedbackRatingCreateWithoutCustomerInput[] | FeedbackRatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FeedbackRatingCreateOrConnectWithoutCustomerInput | FeedbackRatingCreateOrConnectWithoutCustomerInput[]
    createMany?: FeedbackRatingCreateManyCustomerInputEnvelope
    connect?: FeedbackRatingWhereUniqueInput | FeedbackRatingWhereUniqueInput[]
  }

  export type RefundRequestsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RefundRequestsCreateWithoutCustomerInput, RefundRequestsUncheckedCreateWithoutCustomerInput> | RefundRequestsCreateWithoutCustomerInput[] | RefundRequestsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RefundRequestsCreateOrConnectWithoutCustomerInput | RefundRequestsCreateOrConnectWithoutCustomerInput[]
    createMany?: RefundRequestsCreateManyCustomerInputEnvelope
    connect?: RefundRequestsWhereUniqueInput | RefundRequestsWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ComplainUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<ComplainCreateWithoutCustomersInput, ComplainUncheckedCreateWithoutCustomersInput> | ComplainCreateWithoutCustomersInput[] | ComplainUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ComplainCreateOrConnectWithoutCustomersInput | ComplainCreateOrConnectWithoutCustomersInput[]
    createMany?: ComplainCreateManyCustomersInputEnvelope
    connect?: ComplainWhereUniqueInput | ComplainWhereUniqueInput[]
  }

  export type Customer_ProviderUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<Customer_ProviderCreateWithoutCustomersInput, Customer_ProviderUncheckedCreateWithoutCustomersInput> | Customer_ProviderCreateWithoutCustomersInput[] | Customer_ProviderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: Customer_ProviderCreateOrConnectWithoutCustomersInput | Customer_ProviderCreateOrConnectWithoutCustomersInput[]
    createMany?: Customer_ProviderCreateManyCustomersInputEnvelope
    connect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
  }

  export type FeedbackRatingUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<FeedbackRatingCreateWithoutCustomerInput, FeedbackRatingUncheckedCreateWithoutCustomerInput> | FeedbackRatingCreateWithoutCustomerInput[] | FeedbackRatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FeedbackRatingCreateOrConnectWithoutCustomerInput | FeedbackRatingCreateOrConnectWithoutCustomerInput[]
    createMany?: FeedbackRatingCreateManyCustomerInputEnvelope
    connect?: FeedbackRatingWhereUniqueInput | FeedbackRatingWhereUniqueInput[]
  }

  export type RefundRequestsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<RefundRequestsCreateWithoutCustomerInput, RefundRequestsUncheckedCreateWithoutCustomerInput> | RefundRequestsCreateWithoutCustomerInput[] | RefundRequestsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RefundRequestsCreateOrConnectWithoutCustomerInput | RefundRequestsCreateOrConnectWithoutCustomerInput[]
    createMany?: RefundRequestsCreateManyCustomerInputEnvelope
    connect?: RefundRequestsWhereUniqueInput | RefundRequestsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BookingUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCustomerInput | BookingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCustomerInput | BookingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCustomerInput | BookingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ComplainUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<ComplainCreateWithoutCustomersInput, ComplainUncheckedCreateWithoutCustomersInput> | ComplainCreateWithoutCustomersInput[] | ComplainUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ComplainCreateOrConnectWithoutCustomersInput | ComplainCreateOrConnectWithoutCustomersInput[]
    upsert?: ComplainUpsertWithWhereUniqueWithoutCustomersInput | ComplainUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: ComplainCreateManyCustomersInputEnvelope
    set?: ComplainWhereUniqueInput | ComplainWhereUniqueInput[]
    disconnect?: ComplainWhereUniqueInput | ComplainWhereUniqueInput[]
    delete?: ComplainWhereUniqueInput | ComplainWhereUniqueInput[]
    connect?: ComplainWhereUniqueInput | ComplainWhereUniqueInput[]
    update?: ComplainUpdateWithWhereUniqueWithoutCustomersInput | ComplainUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: ComplainUpdateManyWithWhereWithoutCustomersInput | ComplainUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: ComplainScalarWhereInput | ComplainScalarWhereInput[]
  }

  export type Customer_ProviderUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Customer_ProviderCreateWithoutCustomersInput, Customer_ProviderUncheckedCreateWithoutCustomersInput> | Customer_ProviderCreateWithoutCustomersInput[] | Customer_ProviderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: Customer_ProviderCreateOrConnectWithoutCustomersInput | Customer_ProviderCreateOrConnectWithoutCustomersInput[]
    upsert?: Customer_ProviderUpsertWithWhereUniqueWithoutCustomersInput | Customer_ProviderUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: Customer_ProviderCreateManyCustomersInputEnvelope
    set?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    disconnect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    delete?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    connect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    update?: Customer_ProviderUpdateWithWhereUniqueWithoutCustomersInput | Customer_ProviderUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: Customer_ProviderUpdateManyWithWhereWithoutCustomersInput | Customer_ProviderUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: Customer_ProviderScalarWhereInput | Customer_ProviderScalarWhereInput[]
  }

  export type FeedbackRatingUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FeedbackRatingCreateWithoutCustomerInput, FeedbackRatingUncheckedCreateWithoutCustomerInput> | FeedbackRatingCreateWithoutCustomerInput[] | FeedbackRatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FeedbackRatingCreateOrConnectWithoutCustomerInput | FeedbackRatingCreateOrConnectWithoutCustomerInput[]
    upsert?: FeedbackRatingUpsertWithWhereUniqueWithoutCustomerInput | FeedbackRatingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FeedbackRatingCreateManyCustomerInputEnvelope
    set?: FeedbackRatingWhereUniqueInput | FeedbackRatingWhereUniqueInput[]
    disconnect?: FeedbackRatingWhereUniqueInput | FeedbackRatingWhereUniqueInput[]
    delete?: FeedbackRatingWhereUniqueInput | FeedbackRatingWhereUniqueInput[]
    connect?: FeedbackRatingWhereUniqueInput | FeedbackRatingWhereUniqueInput[]
    update?: FeedbackRatingUpdateWithWhereUniqueWithoutCustomerInput | FeedbackRatingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FeedbackRatingUpdateManyWithWhereWithoutCustomerInput | FeedbackRatingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FeedbackRatingScalarWhereInput | FeedbackRatingScalarWhereInput[]
  }

  export type RefundRequestsUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RefundRequestsCreateWithoutCustomerInput, RefundRequestsUncheckedCreateWithoutCustomerInput> | RefundRequestsCreateWithoutCustomerInput[] | RefundRequestsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RefundRequestsCreateOrConnectWithoutCustomerInput | RefundRequestsCreateOrConnectWithoutCustomerInput[]
    upsert?: RefundRequestsUpsertWithWhereUniqueWithoutCustomerInput | RefundRequestsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RefundRequestsCreateManyCustomerInputEnvelope
    set?: RefundRequestsWhereUniqueInput | RefundRequestsWhereUniqueInput[]
    disconnect?: RefundRequestsWhereUniqueInput | RefundRequestsWhereUniqueInput[]
    delete?: RefundRequestsWhereUniqueInput | RefundRequestsWhereUniqueInput[]
    connect?: RefundRequestsWhereUniqueInput | RefundRequestsWhereUniqueInput[]
    update?: RefundRequestsUpdateWithWhereUniqueWithoutCustomerInput | RefundRequestsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RefundRequestsUpdateManyWithWhereWithoutCustomerInput | RefundRequestsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RefundRequestsScalarWhereInput | RefundRequestsScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput> | BookingCreateWithoutCustomerInput[] | BookingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerInput | BookingCreateOrConnectWithoutCustomerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCustomerInput | BookingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: BookingCreateManyCustomerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCustomerInput | BookingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCustomerInput | BookingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ComplainUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<ComplainCreateWithoutCustomersInput, ComplainUncheckedCreateWithoutCustomersInput> | ComplainCreateWithoutCustomersInput[] | ComplainUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: ComplainCreateOrConnectWithoutCustomersInput | ComplainCreateOrConnectWithoutCustomersInput[]
    upsert?: ComplainUpsertWithWhereUniqueWithoutCustomersInput | ComplainUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: ComplainCreateManyCustomersInputEnvelope
    set?: ComplainWhereUniqueInput | ComplainWhereUniqueInput[]
    disconnect?: ComplainWhereUniqueInput | ComplainWhereUniqueInput[]
    delete?: ComplainWhereUniqueInput | ComplainWhereUniqueInput[]
    connect?: ComplainWhereUniqueInput | ComplainWhereUniqueInput[]
    update?: ComplainUpdateWithWhereUniqueWithoutCustomersInput | ComplainUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: ComplainUpdateManyWithWhereWithoutCustomersInput | ComplainUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: ComplainScalarWhereInput | ComplainScalarWhereInput[]
  }

  export type Customer_ProviderUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<Customer_ProviderCreateWithoutCustomersInput, Customer_ProviderUncheckedCreateWithoutCustomersInput> | Customer_ProviderCreateWithoutCustomersInput[] | Customer_ProviderUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: Customer_ProviderCreateOrConnectWithoutCustomersInput | Customer_ProviderCreateOrConnectWithoutCustomersInput[]
    upsert?: Customer_ProviderUpsertWithWhereUniqueWithoutCustomersInput | Customer_ProviderUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: Customer_ProviderCreateManyCustomersInputEnvelope
    set?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    disconnect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    delete?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    connect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    update?: Customer_ProviderUpdateWithWhereUniqueWithoutCustomersInput | Customer_ProviderUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: Customer_ProviderUpdateManyWithWhereWithoutCustomersInput | Customer_ProviderUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: Customer_ProviderScalarWhereInput | Customer_ProviderScalarWhereInput[]
  }

  export type FeedbackRatingUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<FeedbackRatingCreateWithoutCustomerInput, FeedbackRatingUncheckedCreateWithoutCustomerInput> | FeedbackRatingCreateWithoutCustomerInput[] | FeedbackRatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: FeedbackRatingCreateOrConnectWithoutCustomerInput | FeedbackRatingCreateOrConnectWithoutCustomerInput[]
    upsert?: FeedbackRatingUpsertWithWhereUniqueWithoutCustomerInput | FeedbackRatingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: FeedbackRatingCreateManyCustomerInputEnvelope
    set?: FeedbackRatingWhereUniqueInput | FeedbackRatingWhereUniqueInput[]
    disconnect?: FeedbackRatingWhereUniqueInput | FeedbackRatingWhereUniqueInput[]
    delete?: FeedbackRatingWhereUniqueInput | FeedbackRatingWhereUniqueInput[]
    connect?: FeedbackRatingWhereUniqueInput | FeedbackRatingWhereUniqueInput[]
    update?: FeedbackRatingUpdateWithWhereUniqueWithoutCustomerInput | FeedbackRatingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: FeedbackRatingUpdateManyWithWhereWithoutCustomerInput | FeedbackRatingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: FeedbackRatingScalarWhereInput | FeedbackRatingScalarWhereInput[]
  }

  export type RefundRequestsUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<RefundRequestsCreateWithoutCustomerInput, RefundRequestsUncheckedCreateWithoutCustomerInput> | RefundRequestsCreateWithoutCustomerInput[] | RefundRequestsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: RefundRequestsCreateOrConnectWithoutCustomerInput | RefundRequestsCreateOrConnectWithoutCustomerInput[]
    upsert?: RefundRequestsUpsertWithWhereUniqueWithoutCustomerInput | RefundRequestsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: RefundRequestsCreateManyCustomerInputEnvelope
    set?: RefundRequestsWhereUniqueInput | RefundRequestsWhereUniqueInput[]
    disconnect?: RefundRequestsWhereUniqueInput | RefundRequestsWhereUniqueInput[]
    delete?: RefundRequestsWhereUniqueInput | RefundRequestsWhereUniqueInput[]
    connect?: RefundRequestsWhereUniqueInput | RefundRequestsWhereUniqueInput[]
    update?: RefundRequestsUpdateWithWhereUniqueWithoutCustomerInput | RefundRequestsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: RefundRequestsUpdateManyWithWhereWithoutCustomerInput | RefundRequestsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: RefundRequestsScalarWhereInput | RefundRequestsScalarWhereInput[]
  }

  export type ServiceCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type EducationCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EducationCreateWithoutCategoryInput, EducationUncheckedCreateWithoutCategoryInput> | EducationCreateWithoutCategoryInput[] | EducationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutCategoryInput | EducationCreateOrConnectWithoutCategoryInput[]
    createMany?: EducationCreateManyCategoryInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type EducationUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EducationCreateWithoutCategoryInput, EducationUncheckedCreateWithoutCategoryInput> | EducationCreateWithoutCategoryInput[] | EducationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutCategoryInput | EducationCreateOrConnectWithoutCategoryInput[]
    createMany?: EducationCreateManyCategoryInputEnvelope
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type EducationUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EducationCreateWithoutCategoryInput, EducationUncheckedCreateWithoutCategoryInput> | EducationCreateWithoutCategoryInput[] | EducationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutCategoryInput | EducationCreateOrConnectWithoutCategoryInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutCategoryInput | EducationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EducationCreateManyCategoryInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutCategoryInput | EducationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutCategoryInput | EducationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput> | ServiceCreateWithoutCategoryInput[] | ServiceUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutCategoryInput | ServiceCreateOrConnectWithoutCategoryInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutCategoryInput | ServiceUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ServiceCreateManyCategoryInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutCategoryInput | ServiceUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutCategoryInput | ServiceUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type EducationUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EducationCreateWithoutCategoryInput, EducationUncheckedCreateWithoutCategoryInput> | EducationCreateWithoutCategoryInput[] | EducationUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EducationCreateOrConnectWithoutCategoryInput | EducationCreateOrConnectWithoutCategoryInput[]
    upsert?: EducationUpsertWithWhereUniqueWithoutCategoryInput | EducationUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EducationCreateManyCategoryInputEnvelope
    set?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    disconnect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    delete?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    connect?: EducationWhereUniqueInput | EducationWhereUniqueInput[]
    update?: EducationUpdateWithWhereUniqueWithoutCategoryInput | EducationUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EducationUpdateManyWithWhereWithoutCategoryInput | EducationUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EducationScalarWhereInput | EducationScalarWhereInput[]
  }

  export type SyllabusCreateNestedManyWithoutEducationInput = {
    create?: XOR<SyllabusCreateWithoutEducationInput, SyllabusUncheckedCreateWithoutEducationInput> | SyllabusCreateWithoutEducationInput[] | SyllabusUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: SyllabusCreateOrConnectWithoutEducationInput | SyllabusCreateOrConnectWithoutEducationInput[]
    createMany?: SyllabusCreateManyEducationInputEnvelope
    connect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutEducationInput = {
    create?: XOR<CategoryCreateWithoutEducationInput, CategoryUncheckedCreateWithoutEducationInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutEducationInput
    connect?: CategoryWhereUniqueInput
  }

  export type SyllabusUncheckedCreateNestedManyWithoutEducationInput = {
    create?: XOR<SyllabusCreateWithoutEducationInput, SyllabusUncheckedCreateWithoutEducationInput> | SyllabusCreateWithoutEducationInput[] | SyllabusUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: SyllabusCreateOrConnectWithoutEducationInput | SyllabusCreateOrConnectWithoutEducationInput[]
    createMany?: SyllabusCreateManyEducationInputEnvelope
    connect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
  }

  export type SyllabusUpdateManyWithoutEducationNestedInput = {
    create?: XOR<SyllabusCreateWithoutEducationInput, SyllabusUncheckedCreateWithoutEducationInput> | SyllabusCreateWithoutEducationInput[] | SyllabusUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: SyllabusCreateOrConnectWithoutEducationInput | SyllabusCreateOrConnectWithoutEducationInput[]
    upsert?: SyllabusUpsertWithWhereUniqueWithoutEducationInput | SyllabusUpsertWithWhereUniqueWithoutEducationInput[]
    createMany?: SyllabusCreateManyEducationInputEnvelope
    set?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    disconnect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    delete?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    connect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    update?: SyllabusUpdateWithWhereUniqueWithoutEducationInput | SyllabusUpdateWithWhereUniqueWithoutEducationInput[]
    updateMany?: SyllabusUpdateManyWithWhereWithoutEducationInput | SyllabusUpdateManyWithWhereWithoutEducationInput[]
    deleteMany?: SyllabusScalarWhereInput | SyllabusScalarWhereInput[]
  }

  export type CategoryUpdateOneRequiredWithoutEducationNestedInput = {
    create?: XOR<CategoryCreateWithoutEducationInput, CategoryUncheckedCreateWithoutEducationInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutEducationInput
    upsert?: CategoryUpsertWithoutEducationInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutEducationInput, CategoryUpdateWithoutEducationInput>, CategoryUncheckedUpdateWithoutEducationInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type SyllabusUncheckedUpdateManyWithoutEducationNestedInput = {
    create?: XOR<SyllabusCreateWithoutEducationInput, SyllabusUncheckedCreateWithoutEducationInput> | SyllabusCreateWithoutEducationInput[] | SyllabusUncheckedCreateWithoutEducationInput[]
    connectOrCreate?: SyllabusCreateOrConnectWithoutEducationInput | SyllabusCreateOrConnectWithoutEducationInput[]
    upsert?: SyllabusUpsertWithWhereUniqueWithoutEducationInput | SyllabusUpsertWithWhereUniqueWithoutEducationInput[]
    createMany?: SyllabusCreateManyEducationInputEnvelope
    set?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    disconnect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    delete?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    connect?: SyllabusWhereUniqueInput | SyllabusWhereUniqueInput[]
    update?: SyllabusUpdateWithWhereUniqueWithoutEducationInput | SyllabusUpdateWithWhereUniqueWithoutEducationInput[]
    updateMany?: SyllabusUpdateManyWithWhereWithoutEducationInput | SyllabusUpdateManyWithWhereWithoutEducationInput[]
    deleteMany?: SyllabusScalarWhereInput | SyllabusScalarWhereInput[]
  }

  export type EducationCreateNestedOneWithoutSyllabusInput = {
    create?: XOR<EducationCreateWithoutSyllabusInput, EducationUncheckedCreateWithoutSyllabusInput>
    connectOrCreate?: EducationCreateOrConnectWithoutSyllabusInput
    connect?: EducationWhereUniqueInput
  }

  export type SyllabusSubjectCreateNestedManyWithoutSyllabusInput = {
    create?: XOR<SyllabusSubjectCreateWithoutSyllabusInput, SyllabusSubjectUncheckedCreateWithoutSyllabusInput> | SyllabusSubjectCreateWithoutSyllabusInput[] | SyllabusSubjectUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusSubjectCreateOrConnectWithoutSyllabusInput | SyllabusSubjectCreateOrConnectWithoutSyllabusInput[]
    createMany?: SyllabusSubjectCreateManySyllabusInputEnvelope
    connect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
  }

  export type SyllabusSubjectUncheckedCreateNestedManyWithoutSyllabusInput = {
    create?: XOR<SyllabusSubjectCreateWithoutSyllabusInput, SyllabusSubjectUncheckedCreateWithoutSyllabusInput> | SyllabusSubjectCreateWithoutSyllabusInput[] | SyllabusSubjectUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusSubjectCreateOrConnectWithoutSyllabusInput | SyllabusSubjectCreateOrConnectWithoutSyllabusInput[]
    createMany?: SyllabusSubjectCreateManySyllabusInputEnvelope
    connect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
  }

  export type EducationUpdateOneRequiredWithoutSyllabusNestedInput = {
    create?: XOR<EducationCreateWithoutSyllabusInput, EducationUncheckedCreateWithoutSyllabusInput>
    connectOrCreate?: EducationCreateOrConnectWithoutSyllabusInput
    upsert?: EducationUpsertWithoutSyllabusInput
    connect?: EducationWhereUniqueInput
    update?: XOR<XOR<EducationUpdateToOneWithWhereWithoutSyllabusInput, EducationUpdateWithoutSyllabusInput>, EducationUncheckedUpdateWithoutSyllabusInput>
  }

  export type SyllabusSubjectUpdateManyWithoutSyllabusNestedInput = {
    create?: XOR<SyllabusSubjectCreateWithoutSyllabusInput, SyllabusSubjectUncheckedCreateWithoutSyllabusInput> | SyllabusSubjectCreateWithoutSyllabusInput[] | SyllabusSubjectUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusSubjectCreateOrConnectWithoutSyllabusInput | SyllabusSubjectCreateOrConnectWithoutSyllabusInput[]
    upsert?: SyllabusSubjectUpsertWithWhereUniqueWithoutSyllabusInput | SyllabusSubjectUpsertWithWhereUniqueWithoutSyllabusInput[]
    createMany?: SyllabusSubjectCreateManySyllabusInputEnvelope
    set?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    disconnect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    delete?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    connect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    update?: SyllabusSubjectUpdateWithWhereUniqueWithoutSyllabusInput | SyllabusSubjectUpdateWithWhereUniqueWithoutSyllabusInput[]
    updateMany?: SyllabusSubjectUpdateManyWithWhereWithoutSyllabusInput | SyllabusSubjectUpdateManyWithWhereWithoutSyllabusInput[]
    deleteMany?: SyllabusSubjectScalarWhereInput | SyllabusSubjectScalarWhereInput[]
  }

  export type SyllabusSubjectUncheckedUpdateManyWithoutSyllabusNestedInput = {
    create?: XOR<SyllabusSubjectCreateWithoutSyllabusInput, SyllabusSubjectUncheckedCreateWithoutSyllabusInput> | SyllabusSubjectCreateWithoutSyllabusInput[] | SyllabusSubjectUncheckedCreateWithoutSyllabusInput[]
    connectOrCreate?: SyllabusSubjectCreateOrConnectWithoutSyllabusInput | SyllabusSubjectCreateOrConnectWithoutSyllabusInput[]
    upsert?: SyllabusSubjectUpsertWithWhereUniqueWithoutSyllabusInput | SyllabusSubjectUpsertWithWhereUniqueWithoutSyllabusInput[]
    createMany?: SyllabusSubjectCreateManySyllabusInputEnvelope
    set?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    disconnect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    delete?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    connect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    update?: SyllabusSubjectUpdateWithWhereUniqueWithoutSyllabusInput | SyllabusSubjectUpdateWithWhereUniqueWithoutSyllabusInput[]
    updateMany?: SyllabusSubjectUpdateManyWithWhereWithoutSyllabusInput | SyllabusSubjectUpdateManyWithWhereWithoutSyllabusInput[]
    deleteMany?: SyllabusSubjectScalarWhereInput | SyllabusSubjectScalarWhereInput[]
  }

  export type SyllabusSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<SyllabusSubjectCreateWithoutSubjectInput, SyllabusSubjectUncheckedCreateWithoutSubjectInput> | SyllabusSubjectCreateWithoutSubjectInput[] | SyllabusSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SyllabusSubjectCreateOrConnectWithoutSubjectInput | SyllabusSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: SyllabusSubjectCreateManySubjectInputEnvelope
    connect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
  }

  export type SyllabusSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<SyllabusSubjectCreateWithoutSubjectInput, SyllabusSubjectUncheckedCreateWithoutSubjectInput> | SyllabusSubjectCreateWithoutSubjectInput[] | SyllabusSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SyllabusSubjectCreateOrConnectWithoutSubjectInput | SyllabusSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: SyllabusSubjectCreateManySubjectInputEnvelope
    connect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
  }

  export type SyllabusSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<SyllabusSubjectCreateWithoutSubjectInput, SyllabusSubjectUncheckedCreateWithoutSubjectInput> | SyllabusSubjectCreateWithoutSubjectInput[] | SyllabusSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SyllabusSubjectCreateOrConnectWithoutSubjectInput | SyllabusSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: SyllabusSubjectUpsertWithWhereUniqueWithoutSubjectInput | SyllabusSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: SyllabusSubjectCreateManySubjectInputEnvelope
    set?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    disconnect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    delete?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    connect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    update?: SyllabusSubjectUpdateWithWhereUniqueWithoutSubjectInput | SyllabusSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: SyllabusSubjectUpdateManyWithWhereWithoutSubjectInput | SyllabusSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: SyllabusSubjectScalarWhereInput | SyllabusSubjectScalarWhereInput[]
  }

  export type SyllabusSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<SyllabusSubjectCreateWithoutSubjectInput, SyllabusSubjectUncheckedCreateWithoutSubjectInput> | SyllabusSubjectCreateWithoutSubjectInput[] | SyllabusSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: SyllabusSubjectCreateOrConnectWithoutSubjectInput | SyllabusSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: SyllabusSubjectUpsertWithWhereUniqueWithoutSubjectInput | SyllabusSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: SyllabusSubjectCreateManySubjectInputEnvelope
    set?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    disconnect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    delete?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    connect?: SyllabusSubjectWhereUniqueInput | SyllabusSubjectWhereUniqueInput[]
    update?: SyllabusSubjectUpdateWithWhereUniqueWithoutSubjectInput | SyllabusSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: SyllabusSubjectUpdateManyWithWhereWithoutSubjectInput | SyllabusSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: SyllabusSubjectScalarWhereInput | SyllabusSubjectScalarWhereInput[]
  }

  export type SyllabusCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<SyllabusCreateWithoutSubjectsInput, SyllabusUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: SyllabusCreateOrConnectWithoutSubjectsInput
    connect?: SyllabusWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutSyllabusesInput = {
    create?: XOR<SubjectCreateWithoutSyllabusesInput, SubjectUncheckedCreateWithoutSyllabusesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutSyllabusesInput
    connect?: SubjectWhereUniqueInput
  }

  export type SyllabusUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<SyllabusCreateWithoutSubjectsInput, SyllabusUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: SyllabusCreateOrConnectWithoutSubjectsInput
    upsert?: SyllabusUpsertWithoutSubjectsInput
    connect?: SyllabusWhereUniqueInput
    update?: XOR<XOR<SyllabusUpdateToOneWithWhereWithoutSubjectsInput, SyllabusUpdateWithoutSubjectsInput>, SyllabusUncheckedUpdateWithoutSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutSyllabusesNestedInput = {
    create?: XOR<SubjectCreateWithoutSyllabusesInput, SubjectUncheckedCreateWithoutSyllabusesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutSyllabusesInput
    upsert?: SubjectUpsertWithoutSyllabusesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutSyllabusesInput, SubjectUpdateWithoutSyllabusesInput>, SubjectUncheckedUpdateWithoutSyllabusesInput>
  }

  export type CustomerCreateNestedOneWithoutComplainsInput = {
    create?: XOR<CustomerCreateWithoutComplainsInput, CustomerUncheckedCreateWithoutComplainsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutComplainsInput
    connect?: CustomerWhereUniqueInput
  }

  export type EnumcomplianStatusFieldUpdateOperationsInput = {
    set?: $Enums.complianStatus
  }

  export type CustomerUpdateOneRequiredWithoutComplainsNestedInput = {
    create?: XOR<CustomerCreateWithoutComplainsInput, CustomerUncheckedCreateWithoutComplainsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutComplainsInput
    upsert?: CustomerUpsertWithoutComplainsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutComplainsInput, CustomerUpdateWithoutComplainsInput>, CustomerUncheckedUpdateWithoutComplainsInput>
  }

  export type CategoryCreateNestedOneWithoutServiceInput = {
    create?: XOR<CategoryCreateWithoutServiceInput, CategoryUncheckedCreateWithoutServiceInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutServiceInput
    connect?: CategoryWhereUniqueInput
  }

  export type ServiceProviderCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceProviderCreateWithoutServiceInput, ServiceProviderUncheckedCreateWithoutServiceInput> | ServiceProviderCreateWithoutServiceInput[] | ServiceProviderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutServiceInput | ServiceProviderCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceProviderCreateManyServiceInputEnvelope
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
  }

  export type ServiceProviderUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceProviderCreateWithoutServiceInput, ServiceProviderUncheckedCreateWithoutServiceInput> | ServiceProviderCreateWithoutServiceInput[] | ServiceProviderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutServiceInput | ServiceProviderCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceProviderCreateManyServiceInputEnvelope
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUpdateOneRequiredWithoutServiceNestedInput = {
    create?: XOR<CategoryCreateWithoutServiceInput, CategoryUncheckedCreateWithoutServiceInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutServiceInput
    upsert?: CategoryUpsertWithoutServiceInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutServiceInput, CategoryUpdateWithoutServiceInput>, CategoryUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceProviderUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutServiceInput, ServiceProviderUncheckedCreateWithoutServiceInput> | ServiceProviderCreateWithoutServiceInput[] | ServiceProviderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutServiceInput | ServiceProviderCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceProviderUpsertWithWhereUniqueWithoutServiceInput | ServiceProviderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceProviderCreateManyServiceInputEnvelope
    set?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    disconnect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    delete?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    update?: ServiceProviderUpdateWithWhereUniqueWithoutServiceInput | ServiceProviderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceProviderUpdateManyWithWhereWithoutServiceInput | ServiceProviderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
  }

  export type ServiceProviderUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutServiceInput, ServiceProviderUncheckedCreateWithoutServiceInput> | ServiceProviderCreateWithoutServiceInput[] | ServiceProviderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutServiceInput | ServiceProviderCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceProviderUpsertWithWhereUniqueWithoutServiceInput | ServiceProviderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceProviderCreateManyServiceInputEnvelope
    set?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    disconnect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    delete?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    connect?: ServiceProviderWhereUniqueInput | ServiceProviderWhereUniqueInput[]
    update?: ServiceProviderUpdateWithWhereUniqueWithoutServiceInput | ServiceProviderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceProviderUpdateManyWithWhereWithoutServiceInput | ServiceProviderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
  }

  export type BookingCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput> | BookingCreateWithoutServiceProviderInput[] | BookingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceProviderInput | BookingCreateOrConnectWithoutServiceProviderInput[]
    createMany?: BookingCreateManyServiceProviderInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ServiceProvider_ReportsCreateNestedOneWithoutServiceProviderInput = {
    create?: XOR<ServiceProvider_ReportsCreateWithoutServiceProviderInput, ServiceProvider_ReportsUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ServiceProvider_ReportsCreateOrConnectWithoutServiceProviderInput
    connect?: ServiceProvider_ReportsWhereUniqueInput
  }

  export type ScheduleCreateNestedOneWithoutServiceProviderInput = {
    create?: XOR<ScheduleCreateWithoutServiceProviderInput, ScheduleUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutServiceProviderInput
    connect?: ScheduleWhereUniqueInput
  }

  export type Customer_ProviderCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<Customer_ProviderCreateWithoutServiceProviderInput, Customer_ProviderUncheckedCreateWithoutServiceProviderInput> | Customer_ProviderCreateWithoutServiceProviderInput[] | Customer_ProviderUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: Customer_ProviderCreateOrConnectWithoutServiceProviderInput | Customer_ProviderCreateOrConnectWithoutServiceProviderInput[]
    createMany?: Customer_ProviderCreateManyServiceProviderInputEnvelope
    connect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
  }

  export type ProviderSalaryCreateNestedOneWithoutServiceProviderInput = {
    create?: XOR<ProviderSalaryCreateWithoutServiceProviderInput, ProviderSalaryUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ProviderSalaryCreateOrConnectWithoutServiceProviderInput
    connect?: ProviderSalaryWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutServiceProviderInput = {
    create?: XOR<ServiceCreateWithoutServiceProviderInput, ServiceUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceProviderInput
    connect?: ServiceWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput> | BookingCreateWithoutServiceProviderInput[] | BookingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceProviderInput | BookingCreateOrConnectWithoutServiceProviderInput[]
    createMany?: BookingCreateManyServiceProviderInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ServiceProvider_ReportsUncheckedCreateNestedOneWithoutServiceProviderInput = {
    create?: XOR<ServiceProvider_ReportsCreateWithoutServiceProviderInput, ServiceProvider_ReportsUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ServiceProvider_ReportsCreateOrConnectWithoutServiceProviderInput
    connect?: ServiceProvider_ReportsWhereUniqueInput
  }

  export type ScheduleUncheckedCreateNestedOneWithoutServiceProviderInput = {
    create?: XOR<ScheduleCreateWithoutServiceProviderInput, ScheduleUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutServiceProviderInput
    connect?: ScheduleWhereUniqueInput
  }

  export type Customer_ProviderUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<Customer_ProviderCreateWithoutServiceProviderInput, Customer_ProviderUncheckedCreateWithoutServiceProviderInput> | Customer_ProviderCreateWithoutServiceProviderInput[] | Customer_ProviderUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: Customer_ProviderCreateOrConnectWithoutServiceProviderInput | Customer_ProviderCreateOrConnectWithoutServiceProviderInput[]
    createMany?: Customer_ProviderCreateManyServiceProviderInputEnvelope
    connect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
  }

  export type ProviderSalaryUncheckedCreateNestedOneWithoutServiceProviderInput = {
    create?: XOR<ProviderSalaryCreateWithoutServiceProviderInput, ProviderSalaryUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ProviderSalaryCreateOrConnectWithoutServiceProviderInput
    connect?: ProviderSalaryWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BookingUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput> | BookingCreateWithoutServiceProviderInput[] | BookingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceProviderInput | BookingCreateOrConnectWithoutServiceProviderInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceProviderInput | BookingUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: BookingCreateManyServiceProviderInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceProviderInput | BookingUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceProviderInput | BookingUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ServiceProvider_ReportsUpdateOneWithoutServiceProviderNestedInput = {
    create?: XOR<ServiceProvider_ReportsCreateWithoutServiceProviderInput, ServiceProvider_ReportsUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ServiceProvider_ReportsCreateOrConnectWithoutServiceProviderInput
    upsert?: ServiceProvider_ReportsUpsertWithoutServiceProviderInput
    disconnect?: ServiceProvider_ReportsWhereInput | boolean
    delete?: ServiceProvider_ReportsWhereInput | boolean
    connect?: ServiceProvider_ReportsWhereUniqueInput
    update?: XOR<XOR<ServiceProvider_ReportsUpdateToOneWithWhereWithoutServiceProviderInput, ServiceProvider_ReportsUpdateWithoutServiceProviderInput>, ServiceProvider_ReportsUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ScheduleUpdateOneWithoutServiceProviderNestedInput = {
    create?: XOR<ScheduleCreateWithoutServiceProviderInput, ScheduleUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutServiceProviderInput
    upsert?: ScheduleUpsertWithoutServiceProviderInput
    disconnect?: ScheduleWhereInput | boolean
    delete?: ScheduleWhereInput | boolean
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutServiceProviderInput, ScheduleUpdateWithoutServiceProviderInput>, ScheduleUncheckedUpdateWithoutServiceProviderInput>
  }

  export type Customer_ProviderUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<Customer_ProviderCreateWithoutServiceProviderInput, Customer_ProviderUncheckedCreateWithoutServiceProviderInput> | Customer_ProviderCreateWithoutServiceProviderInput[] | Customer_ProviderUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: Customer_ProviderCreateOrConnectWithoutServiceProviderInput | Customer_ProviderCreateOrConnectWithoutServiceProviderInput[]
    upsert?: Customer_ProviderUpsertWithWhereUniqueWithoutServiceProviderInput | Customer_ProviderUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: Customer_ProviderCreateManyServiceProviderInputEnvelope
    set?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    disconnect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    delete?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    connect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    update?: Customer_ProviderUpdateWithWhereUniqueWithoutServiceProviderInput | Customer_ProviderUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: Customer_ProviderUpdateManyWithWhereWithoutServiceProviderInput | Customer_ProviderUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: Customer_ProviderScalarWhereInput | Customer_ProviderScalarWhereInput[]
  }

  export type ProviderSalaryUpdateOneWithoutServiceProviderNestedInput = {
    create?: XOR<ProviderSalaryCreateWithoutServiceProviderInput, ProviderSalaryUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ProviderSalaryCreateOrConnectWithoutServiceProviderInput
    upsert?: ProviderSalaryUpsertWithoutServiceProviderInput
    disconnect?: ProviderSalaryWhereInput | boolean
    delete?: ProviderSalaryWhereInput | boolean
    connect?: ProviderSalaryWhereUniqueInput
    update?: XOR<XOR<ProviderSalaryUpdateToOneWithWhereWithoutServiceProviderInput, ProviderSalaryUpdateWithoutServiceProviderInput>, ProviderSalaryUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ServiceUpdateOneRequiredWithoutServiceProviderNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceProviderInput, ServiceUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceProviderInput
    upsert?: ServiceUpsertWithoutServiceProviderInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServiceProviderInput, ServiceUpdateWithoutServiceProviderInput>, ServiceUncheckedUpdateWithoutServiceProviderInput>
  }

  export type BookingUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput> | BookingCreateWithoutServiceProviderInput[] | BookingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceProviderInput | BookingCreateOrConnectWithoutServiceProviderInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceProviderInput | BookingUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: BookingCreateManyServiceProviderInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceProviderInput | BookingUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceProviderInput | BookingUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ServiceProvider_ReportsUncheckedUpdateOneWithoutServiceProviderNestedInput = {
    create?: XOR<ServiceProvider_ReportsCreateWithoutServiceProviderInput, ServiceProvider_ReportsUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ServiceProvider_ReportsCreateOrConnectWithoutServiceProviderInput
    upsert?: ServiceProvider_ReportsUpsertWithoutServiceProviderInput
    disconnect?: ServiceProvider_ReportsWhereInput | boolean
    delete?: ServiceProvider_ReportsWhereInput | boolean
    connect?: ServiceProvider_ReportsWhereUniqueInput
    update?: XOR<XOR<ServiceProvider_ReportsUpdateToOneWithWhereWithoutServiceProviderInput, ServiceProvider_ReportsUpdateWithoutServiceProviderInput>, ServiceProvider_ReportsUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ScheduleUncheckedUpdateOneWithoutServiceProviderNestedInput = {
    create?: XOR<ScheduleCreateWithoutServiceProviderInput, ScheduleUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutServiceProviderInput
    upsert?: ScheduleUpsertWithoutServiceProviderInput
    disconnect?: ScheduleWhereInput | boolean
    delete?: ScheduleWhereInput | boolean
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutServiceProviderInput, ScheduleUpdateWithoutServiceProviderInput>, ScheduleUncheckedUpdateWithoutServiceProviderInput>
  }

  export type Customer_ProviderUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<Customer_ProviderCreateWithoutServiceProviderInput, Customer_ProviderUncheckedCreateWithoutServiceProviderInput> | Customer_ProviderCreateWithoutServiceProviderInput[] | Customer_ProviderUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: Customer_ProviderCreateOrConnectWithoutServiceProviderInput | Customer_ProviderCreateOrConnectWithoutServiceProviderInput[]
    upsert?: Customer_ProviderUpsertWithWhereUniqueWithoutServiceProviderInput | Customer_ProviderUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: Customer_ProviderCreateManyServiceProviderInputEnvelope
    set?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    disconnect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    delete?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    connect?: Customer_ProviderWhereUniqueInput | Customer_ProviderWhereUniqueInput[]
    update?: Customer_ProviderUpdateWithWhereUniqueWithoutServiceProviderInput | Customer_ProviderUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: Customer_ProviderUpdateManyWithWhereWithoutServiceProviderInput | Customer_ProviderUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: Customer_ProviderScalarWhereInput | Customer_ProviderScalarWhereInput[]
  }

  export type ProviderSalaryUncheckedUpdateOneWithoutServiceProviderNestedInput = {
    create?: XOR<ProviderSalaryCreateWithoutServiceProviderInput, ProviderSalaryUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: ProviderSalaryCreateOrConnectWithoutServiceProviderInput
    upsert?: ProviderSalaryUpsertWithoutServiceProviderInput
    disconnect?: ProviderSalaryWhereInput | boolean
    delete?: ProviderSalaryWhereInput | boolean
    connect?: ProviderSalaryWhereUniqueInput
    update?: XOR<XOR<ProviderSalaryUpdateToOneWithWhereWithoutServiceProviderInput, ProviderSalaryUpdateWithoutServiceProviderInput>, ProviderSalaryUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ServiceProviderCreateNestedOneWithoutCustomerInput = {
    create?: XOR<ServiceProviderCreateWithoutCustomerInput, ServiceProviderUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutCustomerInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutServiceProviderInput = {
    create?: XOR<CustomerCreateWithoutServiceProviderInput, CustomerUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutServiceProviderInput
    connect?: CustomerWhereUniqueInput
  }

  export type ServiceProviderUpdateOneRequiredWithoutCustomerNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutCustomerInput, ServiceProviderUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutCustomerInput
    upsert?: ServiceProviderUpsertWithoutCustomerInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutCustomerInput, ServiceProviderUpdateWithoutCustomerInput>, ServiceProviderUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerUpdateOneRequiredWithoutServiceProviderNestedInput = {
    create?: XOR<CustomerCreateWithoutServiceProviderInput, CustomerUncheckedCreateWithoutServiceProviderInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutServiceProviderInput
    upsert?: CustomerUpsertWithoutServiceProviderInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutServiceProviderInput, CustomerUpdateWithoutServiceProviderInput>, CustomerUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ServiceProviderCreateNestedOneWithoutServiceProvider_ReportsInput = {
    create?: XOR<ServiceProviderCreateWithoutServiceProvider_ReportsInput, ServiceProviderUncheckedCreateWithoutServiceProvider_ReportsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutServiceProvider_ReportsInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type ServiceProviderUpdateOneRequiredWithoutServiceProvider_ReportsNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutServiceProvider_ReportsInput, ServiceProviderUncheckedCreateWithoutServiceProvider_ReportsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutServiceProvider_ReportsInput
    upsert?: ServiceProviderUpsertWithoutServiceProvider_ReportsInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutServiceProvider_ReportsInput, ServiceProviderUpdateWithoutServiceProvider_ReportsInput>, ServiceProviderUncheckedUpdateWithoutServiceProvider_ReportsInput>
  }

  export type CustomerCreateNestedOneWithoutBookingIDInput = {
    create?: XOR<CustomerCreateWithoutBookingIDInput, CustomerUncheckedCreateWithoutBookingIDInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutBookingIDInput
    connect?: CustomerWhereUniqueInput
  }

  export type ServiceProviderCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ServiceProviderCreateWithoutBookingsInput, ServiceProviderUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutBookingsInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type CustomerUpdateOneRequiredWithoutBookingIDNestedInput = {
    create?: XOR<CustomerCreateWithoutBookingIDInput, CustomerUncheckedCreateWithoutBookingIDInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutBookingIDInput
    upsert?: CustomerUpsertWithoutBookingIDInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutBookingIDInput, CustomerUpdateWithoutBookingIDInput>, CustomerUncheckedUpdateWithoutBookingIDInput>
  }

  export type ServiceProviderUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutBookingsInput, ServiceProviderUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutBookingsInput
    upsert?: ServiceProviderUpsertWithoutBookingsInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutBookingsInput, ServiceProviderUpdateWithoutBookingsInput>, ServiceProviderUncheckedUpdateWithoutBookingsInput>
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPaymentMethodInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaymentMethodInput | PaymentUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentMethodNestedInput = {
    create?: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput> | PaymentCreateWithoutPaymentMethodInput[] | PaymentUncheckedCreateWithoutPaymentMethodInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPaymentMethodInput | PaymentCreateOrConnectWithoutPaymentMethodInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput | PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput[]
    createMany?: PaymentCreateManyPaymentMethodInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput | PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPaymentMethodInput | PaymentUpdateManyWithWhereWithoutPaymentMethodInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentMethodCreateNestedOneWithoutPaymentInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentInput, PaymentMethodUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentInput
    connect?: PaymentMethodWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutPaymentInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    connect?: BookingWhereUniqueInput
  }

  export type RefundRequestsCreateNestedOneWithoutPaymentInput = {
    create?: XOR<RefundRequestsCreateWithoutPaymentInput, RefundRequestsUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: RefundRequestsCreateOrConnectWithoutPaymentInput
    connect?: RefundRequestsWhereUniqueInput
  }

  export type RefundRequestsUncheckedCreateNestedOneWithoutPaymentInput = {
    create?: XOR<RefundRequestsCreateWithoutPaymentInput, RefundRequestsUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: RefundRequestsCreateOrConnectWithoutPaymentInput
    connect?: RefundRequestsWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type PaymentMethodUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<PaymentMethodCreateWithoutPaymentInput, PaymentMethodUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: PaymentMethodCreateOrConnectWithoutPaymentInput
    upsert?: PaymentMethodUpsertWithoutPaymentInput
    connect?: PaymentMethodWhereUniqueInput
    update?: XOR<XOR<PaymentMethodUpdateToOneWithWhereWithoutPaymentInput, PaymentMethodUpdateWithoutPaymentInput>, PaymentMethodUncheckedUpdateWithoutPaymentInput>
  }

  export type BookingUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    upsert?: BookingUpsertWithoutPaymentInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentInput, BookingUpdateWithoutPaymentInput>, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type RefundRequestsUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<RefundRequestsCreateWithoutPaymentInput, RefundRequestsUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: RefundRequestsCreateOrConnectWithoutPaymentInput
    upsert?: RefundRequestsUpsertWithoutPaymentInput
    disconnect?: RefundRequestsWhereInput | boolean
    delete?: RefundRequestsWhereInput | boolean
    connect?: RefundRequestsWhereUniqueInput
    update?: XOR<XOR<RefundRequestsUpdateToOneWithWhereWithoutPaymentInput, RefundRequestsUpdateWithoutPaymentInput>, RefundRequestsUncheckedUpdateWithoutPaymentInput>
  }

  export type RefundRequestsUncheckedUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<RefundRequestsCreateWithoutPaymentInput, RefundRequestsUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: RefundRequestsCreateOrConnectWithoutPaymentInput
    upsert?: RefundRequestsUpsertWithoutPaymentInput
    disconnect?: RefundRequestsWhereInput | boolean
    delete?: RefundRequestsWhereInput | boolean
    connect?: RefundRequestsWhereUniqueInput
    update?: XOR<XOR<RefundRequestsUpdateToOneWithWhereWithoutPaymentInput, RefundRequestsUpdateWithoutPaymentInput>, RefundRequestsUncheckedUpdateWithoutPaymentInput>
  }

  export type ServiceProviderCreateNestedOneWithoutScheduleInput = {
    create?: XOR<ServiceProviderCreateWithoutScheduleInput, ServiceProviderUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutScheduleInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type ServiceProviderUpdateOneRequiredWithoutScheduleNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutScheduleInput, ServiceProviderUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutScheduleInput
    upsert?: ServiceProviderUpsertWithoutScheduleInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutScheduleInput, ServiceProviderUpdateWithoutScheduleInput>, ServiceProviderUncheckedUpdateWithoutScheduleInput>
  }

  export type CustomerCreateNestedOneWithoutFeedbackRatingInput = {
    create?: XOR<CustomerCreateWithoutFeedbackRatingInput, CustomerUncheckedCreateWithoutFeedbackRatingInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutFeedbackRatingInput
    connect?: CustomerWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type CustomerUpdateOneRequiredWithoutFeedbackRatingNestedInput = {
    create?: XOR<CustomerCreateWithoutFeedbackRatingInput, CustomerUncheckedCreateWithoutFeedbackRatingInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutFeedbackRatingInput
    upsert?: CustomerUpsertWithoutFeedbackRatingInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutFeedbackRatingInput, CustomerUpdateWithoutFeedbackRatingInput>, CustomerUncheckedUpdateWithoutFeedbackRatingInput>
  }

  export type ServiceProviderCreateNestedOneWithoutProviderSalaryInput = {
    create?: XOR<ServiceProviderCreateWithoutProviderSalaryInput, ServiceProviderUncheckedCreateWithoutProviderSalaryInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutProviderSalaryInput
    connect?: ServiceProviderWhereUniqueInput
  }

  export type ServiceProviderUpdateOneRequiredWithoutProviderSalaryNestedInput = {
    create?: XOR<ServiceProviderCreateWithoutProviderSalaryInput, ServiceProviderUncheckedCreateWithoutProviderSalaryInput>
    connectOrCreate?: ServiceProviderCreateOrConnectWithoutProviderSalaryInput
    upsert?: ServiceProviderUpsertWithoutProviderSalaryInput
    connect?: ServiceProviderWhereUniqueInput
    update?: XOR<XOR<ServiceProviderUpdateToOneWithWhereWithoutProviderSalaryInput, ServiceProviderUpdateWithoutProviderSalaryInput>, ServiceProviderUncheckedUpdateWithoutProviderSalaryInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type CustomerCreateNestedOneWithoutRefundRequestsInput = {
    create?: XOR<CustomerCreateWithoutRefundRequestsInput, CustomerUncheckedCreateWithoutRefundRequestsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRefundRequestsInput
    connect?: CustomerWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutRefundRequestsInput = {
    create?: XOR<PaymentCreateWithoutRefundRequestsInput, PaymentUncheckedCreateWithoutRefundRequestsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundRequestsInput
    connect?: PaymentWhereUniqueInput
  }

  export type EnumrefundStatusFieldUpdateOperationsInput = {
    set?: $Enums.refundStatus
  }

  export type CustomerUpdateOneRequiredWithoutRefundRequestsNestedInput = {
    create?: XOR<CustomerCreateWithoutRefundRequestsInput, CustomerUncheckedCreateWithoutRefundRequestsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutRefundRequestsInput
    upsert?: CustomerUpsertWithoutRefundRequestsInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutRefundRequestsInput, CustomerUpdateWithoutRefundRequestsInput>, CustomerUncheckedUpdateWithoutRefundRequestsInput>
  }

  export type PaymentUpdateOneRequiredWithoutRefundRequestsNestedInput = {
    create?: XOR<PaymentCreateWithoutRefundRequestsInput, PaymentUncheckedCreateWithoutRefundRequestsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundRequestsInput
    upsert?: PaymentUpsertWithoutRefundRequestsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutRefundRequestsInput, PaymentUpdateWithoutRefundRequestsInput>, PaymentUncheckedUpdateWithoutRefundRequestsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumcomplianStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.complianStatus | EnumcomplianStatusFieldRefInput<$PrismaModel>
    in?: $Enums.complianStatus[] | ListEnumcomplianStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.complianStatus[] | ListEnumcomplianStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumcomplianStatusFilter<$PrismaModel> | $Enums.complianStatus
  }

  export type NestedEnumcomplianStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.complianStatus | EnumcomplianStatusFieldRefInput<$PrismaModel>
    in?: $Enums.complianStatus[] | ListEnumcomplianStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.complianStatus[] | ListEnumcomplianStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumcomplianStatusWithAggregatesFilter<$PrismaModel> | $Enums.complianStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcomplianStatusFilter<$PrismaModel>
    _max?: NestedEnumcomplianStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumrefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.refundStatus | EnumrefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.refundStatus[] | ListEnumrefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.refundStatus[] | ListEnumrefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumrefundStatusFilter<$PrismaModel> | $Enums.refundStatus
  }

  export type NestedEnumrefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.refundStatus | EnumrefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.refundStatus[] | ListEnumrefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.refundStatus[] | ListEnumrefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumrefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.refundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrefundStatusFilter<$PrismaModel>
    _max?: NestedEnumrefundStatusFilter<$PrismaModel>
  }

  export type BookingCreateWithoutCustomerInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
    serviceProvider: ServiceProviderCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCustomerInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    Provider: string
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
    payment?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput>
  }

  export type BookingCreateManyCustomerInputEnvelope = {
    data: BookingCreateManyCustomerInput | BookingCreateManyCustomerInput[]
  }

  export type ComplainCreateWithoutCustomersInput = {
    complainId?: string
    Reason?: string | null
    Status?: $Enums.complianStatus
  }

  export type ComplainUncheckedCreateWithoutCustomersInput = {
    complainId?: string
    Reason?: string | null
    Status?: $Enums.complianStatus
  }

  export type ComplainCreateOrConnectWithoutCustomersInput = {
    where: ComplainWhereUniqueInput
    create: XOR<ComplainCreateWithoutCustomersInput, ComplainUncheckedCreateWithoutCustomersInput>
  }

  export type ComplainCreateManyCustomersInputEnvelope = {
    data: ComplainCreateManyCustomersInput | ComplainCreateManyCustomersInput[]
  }

  export type Customer_ProviderCreateWithoutCustomersInput = {
    id?: string
    serviceProvider: ServiceProviderCreateNestedOneWithoutCustomerInput
  }

  export type Customer_ProviderUncheckedCreateWithoutCustomersInput = {
    id?: string
    provider: string
  }

  export type Customer_ProviderCreateOrConnectWithoutCustomersInput = {
    where: Customer_ProviderWhereUniqueInput
    create: XOR<Customer_ProviderCreateWithoutCustomersInput, Customer_ProviderUncheckedCreateWithoutCustomersInput>
  }

  export type Customer_ProviderCreateManyCustomersInputEnvelope = {
    data: Customer_ProviderCreateManyCustomersInput | Customer_ProviderCreateManyCustomersInput[]
  }

  export type FeedbackRatingCreateWithoutCustomerInput = {
    feedbackID?: string
    feedback?: string | null
    Rating?: number | null
  }

  export type FeedbackRatingUncheckedCreateWithoutCustomerInput = {
    feedbackID?: string
    feedback?: string | null
    Rating?: number | null
  }

  export type FeedbackRatingCreateOrConnectWithoutCustomerInput = {
    where: FeedbackRatingWhereUniqueInput
    create: XOR<FeedbackRatingCreateWithoutCustomerInput, FeedbackRatingUncheckedCreateWithoutCustomerInput>
  }

  export type FeedbackRatingCreateManyCustomerInputEnvelope = {
    data: FeedbackRatingCreateManyCustomerInput | FeedbackRatingCreateManyCustomerInput[]
  }

  export type RefundRequestsCreateWithoutCustomerInput = {
    refundId?: string
    amount?: number | null
    reason?: string | null
    requestAt?: Date | string
    status?: $Enums.refundStatus
    payment: PaymentCreateNestedOneWithoutRefundRequestsInput
  }

  export type RefundRequestsUncheckedCreateWithoutCustomerInput = {
    refundId?: string
    paymentId: string
    amount?: number | null
    reason?: string | null
    requestAt?: Date | string
    status?: $Enums.refundStatus
  }

  export type RefundRequestsCreateOrConnectWithoutCustomerInput = {
    where: RefundRequestsWhereUniqueInput
    create: XOR<RefundRequestsCreateWithoutCustomerInput, RefundRequestsUncheckedCreateWithoutCustomerInput>
  }

  export type RefundRequestsCreateManyCustomerInputEnvelope = {
    data: RefundRequestsCreateManyCustomerInput | RefundRequestsCreateManyCustomerInput[]
  }

  export type BookingUpsertWithWhereUniqueWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutCustomerInput, BookingUncheckedUpdateWithoutCustomerInput>
    create: XOR<BookingCreateWithoutCustomerInput, BookingUncheckedCreateWithoutCustomerInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutCustomerInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutCustomerInput, BookingUncheckedUpdateWithoutCustomerInput>
  }

  export type BookingUpdateManyWithWhereWithoutCustomerInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutCustomerInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    BookingID?: StringFilter<"Booking"> | string
    AgreementDuration?: StringNullableFilter<"Booking"> | string | null
    Booking_Service?: StringNullableFilter<"Booking"> | string | null
    Provider?: StringFilter<"Booking"> | string
    MonthlyPayment?: FloatNullableFilter<"Booking"> | number | null
    BookingDate?: DateTimeFilter<"Booking"> | Date | string
    Status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    CustomerID?: StringFilter<"Booking"> | string
  }

  export type ComplainUpsertWithWhereUniqueWithoutCustomersInput = {
    where: ComplainWhereUniqueInput
    update: XOR<ComplainUpdateWithoutCustomersInput, ComplainUncheckedUpdateWithoutCustomersInput>
    create: XOR<ComplainCreateWithoutCustomersInput, ComplainUncheckedCreateWithoutCustomersInput>
  }

  export type ComplainUpdateWithWhereUniqueWithoutCustomersInput = {
    where: ComplainWhereUniqueInput
    data: XOR<ComplainUpdateWithoutCustomersInput, ComplainUncheckedUpdateWithoutCustomersInput>
  }

  export type ComplainUpdateManyWithWhereWithoutCustomersInput = {
    where: ComplainScalarWhereInput
    data: XOR<ComplainUpdateManyMutationInput, ComplainUncheckedUpdateManyWithoutCustomersInput>
  }

  export type ComplainScalarWhereInput = {
    AND?: ComplainScalarWhereInput | ComplainScalarWhereInput[]
    OR?: ComplainScalarWhereInput[]
    NOT?: ComplainScalarWhereInput | ComplainScalarWhereInput[]
    complainId?: StringFilter<"Complain"> | string
    Reason?: StringNullableFilter<"Complain"> | string | null
    Status?: EnumcomplianStatusFilter<"Complain"> | $Enums.complianStatus
    CustomerId?: StringFilter<"Complain"> | string
  }

  export type Customer_ProviderUpsertWithWhereUniqueWithoutCustomersInput = {
    where: Customer_ProviderWhereUniqueInput
    update: XOR<Customer_ProviderUpdateWithoutCustomersInput, Customer_ProviderUncheckedUpdateWithoutCustomersInput>
    create: XOR<Customer_ProviderCreateWithoutCustomersInput, Customer_ProviderUncheckedCreateWithoutCustomersInput>
  }

  export type Customer_ProviderUpdateWithWhereUniqueWithoutCustomersInput = {
    where: Customer_ProviderWhereUniqueInput
    data: XOR<Customer_ProviderUpdateWithoutCustomersInput, Customer_ProviderUncheckedUpdateWithoutCustomersInput>
  }

  export type Customer_ProviderUpdateManyWithWhereWithoutCustomersInput = {
    where: Customer_ProviderScalarWhereInput
    data: XOR<Customer_ProviderUpdateManyMutationInput, Customer_ProviderUncheckedUpdateManyWithoutCustomersInput>
  }

  export type Customer_ProviderScalarWhereInput = {
    AND?: Customer_ProviderScalarWhereInput | Customer_ProviderScalarWhereInput[]
    OR?: Customer_ProviderScalarWhereInput[]
    NOT?: Customer_ProviderScalarWhereInput | Customer_ProviderScalarWhereInput[]
    id?: StringFilter<"Customer_Provider"> | string
    customer?: StringFilter<"Customer_Provider"> | string
    provider?: StringFilter<"Customer_Provider"> | string
  }

  export type FeedbackRatingUpsertWithWhereUniqueWithoutCustomerInput = {
    where: FeedbackRatingWhereUniqueInput
    update: XOR<FeedbackRatingUpdateWithoutCustomerInput, FeedbackRatingUncheckedUpdateWithoutCustomerInput>
    create: XOR<FeedbackRatingCreateWithoutCustomerInput, FeedbackRatingUncheckedCreateWithoutCustomerInput>
  }

  export type FeedbackRatingUpdateWithWhereUniqueWithoutCustomerInput = {
    where: FeedbackRatingWhereUniqueInput
    data: XOR<FeedbackRatingUpdateWithoutCustomerInput, FeedbackRatingUncheckedUpdateWithoutCustomerInput>
  }

  export type FeedbackRatingUpdateManyWithWhereWithoutCustomerInput = {
    where: FeedbackRatingScalarWhereInput
    data: XOR<FeedbackRatingUpdateManyMutationInput, FeedbackRatingUncheckedUpdateManyWithoutCustomerInput>
  }

  export type FeedbackRatingScalarWhereInput = {
    AND?: FeedbackRatingScalarWhereInput | FeedbackRatingScalarWhereInput[]
    OR?: FeedbackRatingScalarWhereInput[]
    NOT?: FeedbackRatingScalarWhereInput | FeedbackRatingScalarWhereInput[]
    feedbackID?: StringFilter<"FeedbackRating"> | string
    feedback?: StringNullableFilter<"FeedbackRating"> | string | null
    Rating?: IntNullableFilter<"FeedbackRating"> | number | null
    RatingCustomer?: StringFilter<"FeedbackRating"> | string
  }

  export type RefundRequestsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: RefundRequestsWhereUniqueInput
    update: XOR<RefundRequestsUpdateWithoutCustomerInput, RefundRequestsUncheckedUpdateWithoutCustomerInput>
    create: XOR<RefundRequestsCreateWithoutCustomerInput, RefundRequestsUncheckedCreateWithoutCustomerInput>
  }

  export type RefundRequestsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: RefundRequestsWhereUniqueInput
    data: XOR<RefundRequestsUpdateWithoutCustomerInput, RefundRequestsUncheckedUpdateWithoutCustomerInput>
  }

  export type RefundRequestsUpdateManyWithWhereWithoutCustomerInput = {
    where: RefundRequestsScalarWhereInput
    data: XOR<RefundRequestsUpdateManyMutationInput, RefundRequestsUncheckedUpdateManyWithoutCustomerInput>
  }

  export type RefundRequestsScalarWhereInput = {
    AND?: RefundRequestsScalarWhereInput | RefundRequestsScalarWhereInput[]
    OR?: RefundRequestsScalarWhereInput[]
    NOT?: RefundRequestsScalarWhereInput | RefundRequestsScalarWhereInput[]
    refundId?: StringFilter<"RefundRequests"> | string
    customerID?: StringFilter<"RefundRequests"> | string
    paymentId?: StringFilter<"RefundRequests"> | string
    amount?: FloatNullableFilter<"RefundRequests"> | number | null
    reason?: StringNullableFilter<"RefundRequests"> | string | null
    requestAt?: DateTimeFilter<"RefundRequests"> | Date | string
    status?: EnumrefundStatusFilter<"RefundRequests"> | $Enums.refundStatus
  }

  export type ServiceCreateWithoutCategoryInput = {
    ServiceID?: string
    ServiceName: string
    CommisionRate: number
    Description: string
    serviceProvider?: ServiceProviderCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCategoryInput = {
    ServiceID?: string
    ServiceName: string
    CommisionRate: number
    Description: string
    serviceProvider?: ServiceProviderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceCreateManyCategoryInputEnvelope = {
    data: ServiceCreateManyCategoryInput | ServiceCreateManyCategoryInput[]
  }

  export type EducationCreateWithoutCategoryInput = {
    EducationId?: string
    deliveryMode?: string | null
    syllabus?: SyllabusCreateNestedManyWithoutEducationInput
  }

  export type EducationUncheckedCreateWithoutCategoryInput = {
    EducationId?: string
    deliveryMode?: string | null
    syllabus?: SyllabusUncheckedCreateNestedManyWithoutEducationInput
  }

  export type EducationCreateOrConnectWithoutCategoryInput = {
    where: EducationWhereUniqueInput
    create: XOR<EducationCreateWithoutCategoryInput, EducationUncheckedCreateWithoutCategoryInput>
  }

  export type EducationCreateManyCategoryInputEnvelope = {
    data: EducationCreateManyCategoryInput | EducationCreateManyCategoryInput[]
  }

  export type ServiceUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
    create: XOR<ServiceCreateWithoutCategoryInput, ServiceUncheckedCreateWithoutCategoryInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutCategoryInput, ServiceUncheckedUpdateWithoutCategoryInput>
  }

  export type ServiceUpdateManyWithWhereWithoutCategoryInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    ServiceID?: StringFilter<"Service"> | string
    ServiceName?: StringFilter<"Service"> | string
    Category?: StringFilter<"Service"> | string
    CommisionRate?: IntFilter<"Service"> | number
    Description?: StringFilter<"Service"> | string
  }

  export type EducationUpsertWithWhereUniqueWithoutCategoryInput = {
    where: EducationWhereUniqueInput
    update: XOR<EducationUpdateWithoutCategoryInput, EducationUncheckedUpdateWithoutCategoryInput>
    create: XOR<EducationCreateWithoutCategoryInput, EducationUncheckedCreateWithoutCategoryInput>
  }

  export type EducationUpdateWithWhereUniqueWithoutCategoryInput = {
    where: EducationWhereUniqueInput
    data: XOR<EducationUpdateWithoutCategoryInput, EducationUncheckedUpdateWithoutCategoryInput>
  }

  export type EducationUpdateManyWithWhereWithoutCategoryInput = {
    where: EducationScalarWhereInput
    data: XOR<EducationUpdateManyMutationInput, EducationUncheckedUpdateManyWithoutCategoryInput>
  }

  export type EducationScalarWhereInput = {
    AND?: EducationScalarWhereInput | EducationScalarWhereInput[]
    OR?: EducationScalarWhereInput[]
    NOT?: EducationScalarWhereInput | EducationScalarWhereInput[]
    EducationId?: StringFilter<"Education"> | string
    deliveryMode?: StringNullableFilter<"Education"> | string | null
    categoryID?: StringFilter<"Education"> | string
  }

  export type SyllabusCreateWithoutEducationInput = {
    SyllabusID?: string
    Title?: string | null
    Description?: string | null
    subjects?: SyllabusSubjectCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusUncheckedCreateWithoutEducationInput = {
    SyllabusID?: string
    Title?: string | null
    Description?: string | null
    subjects?: SyllabusSubjectUncheckedCreateNestedManyWithoutSyllabusInput
  }

  export type SyllabusCreateOrConnectWithoutEducationInput = {
    where: SyllabusWhereUniqueInput
    create: XOR<SyllabusCreateWithoutEducationInput, SyllabusUncheckedCreateWithoutEducationInput>
  }

  export type SyllabusCreateManyEducationInputEnvelope = {
    data: SyllabusCreateManyEducationInput | SyllabusCreateManyEducationInput[]
  }

  export type CategoryCreateWithoutEducationInput = {
    CategoryID?: string
    Type?: string | null
    service?: ServiceCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutEducationInput = {
    CategoryID?: string
    Type?: string | null
    service?: ServiceUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutEducationInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutEducationInput, CategoryUncheckedCreateWithoutEducationInput>
  }

  export type SyllabusUpsertWithWhereUniqueWithoutEducationInput = {
    where: SyllabusWhereUniqueInput
    update: XOR<SyllabusUpdateWithoutEducationInput, SyllabusUncheckedUpdateWithoutEducationInput>
    create: XOR<SyllabusCreateWithoutEducationInput, SyllabusUncheckedCreateWithoutEducationInput>
  }

  export type SyllabusUpdateWithWhereUniqueWithoutEducationInput = {
    where: SyllabusWhereUniqueInput
    data: XOR<SyllabusUpdateWithoutEducationInput, SyllabusUncheckedUpdateWithoutEducationInput>
  }

  export type SyllabusUpdateManyWithWhereWithoutEducationInput = {
    where: SyllabusScalarWhereInput
    data: XOR<SyllabusUpdateManyMutationInput, SyllabusUncheckedUpdateManyWithoutEducationInput>
  }

  export type SyllabusScalarWhereInput = {
    AND?: SyllabusScalarWhereInput | SyllabusScalarWhereInput[]
    OR?: SyllabusScalarWhereInput[]
    NOT?: SyllabusScalarWhereInput | SyllabusScalarWhereInput[]
    SyllabusID?: StringFilter<"Syllabus"> | string
    Title?: StringNullableFilter<"Syllabus"> | string | null
    Description?: StringNullableFilter<"Syllabus"> | string | null
    educationID?: StringFilter<"Syllabus"> | string
  }

  export type CategoryUpsertWithoutEducationInput = {
    update: XOR<CategoryUpdateWithoutEducationInput, CategoryUncheckedUpdateWithoutEducationInput>
    create: XOR<CategoryCreateWithoutEducationInput, CategoryUncheckedCreateWithoutEducationInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutEducationInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutEducationInput, CategoryUncheckedUpdateWithoutEducationInput>
  }

  export type CategoryUpdateWithoutEducationInput = {
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutEducationInput = {
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EducationCreateWithoutSyllabusInput = {
    EducationId?: string
    deliveryMode?: string | null
    category: CategoryCreateNestedOneWithoutEducationInput
  }

  export type EducationUncheckedCreateWithoutSyllabusInput = {
    EducationId?: string
    deliveryMode?: string | null
    categoryID: string
  }

  export type EducationCreateOrConnectWithoutSyllabusInput = {
    where: EducationWhereUniqueInput
    create: XOR<EducationCreateWithoutSyllabusInput, EducationUncheckedCreateWithoutSyllabusInput>
  }

  export type SyllabusSubjectCreateWithoutSyllabusInput = {
    id?: string
    subject: SubjectCreateNestedOneWithoutSyllabusesInput
  }

  export type SyllabusSubjectUncheckedCreateWithoutSyllabusInput = {
    id?: string
    subjectID: string
  }

  export type SyllabusSubjectCreateOrConnectWithoutSyllabusInput = {
    where: SyllabusSubjectWhereUniqueInput
    create: XOR<SyllabusSubjectCreateWithoutSyllabusInput, SyllabusSubjectUncheckedCreateWithoutSyllabusInput>
  }

  export type SyllabusSubjectCreateManySyllabusInputEnvelope = {
    data: SyllabusSubjectCreateManySyllabusInput | SyllabusSubjectCreateManySyllabusInput[]
  }

  export type EducationUpsertWithoutSyllabusInput = {
    update: XOR<EducationUpdateWithoutSyllabusInput, EducationUncheckedUpdateWithoutSyllabusInput>
    create: XOR<EducationCreateWithoutSyllabusInput, EducationUncheckedCreateWithoutSyllabusInput>
    where?: EducationWhereInput
  }

  export type EducationUpdateToOneWithWhereWithoutSyllabusInput = {
    where?: EducationWhereInput
    data: XOR<EducationUpdateWithoutSyllabusInput, EducationUncheckedUpdateWithoutSyllabusInput>
  }

  export type EducationUpdateWithoutSyllabusInput = {
    deliveryMode?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneRequiredWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateWithoutSyllabusInput = {
    deliveryMode?: NullableStringFieldUpdateOperationsInput | string | null
    categoryID?: StringFieldUpdateOperationsInput | string
  }

  export type SyllabusSubjectUpsertWithWhereUniqueWithoutSyllabusInput = {
    where: SyllabusSubjectWhereUniqueInput
    update: XOR<SyllabusSubjectUpdateWithoutSyllabusInput, SyllabusSubjectUncheckedUpdateWithoutSyllabusInput>
    create: XOR<SyllabusSubjectCreateWithoutSyllabusInput, SyllabusSubjectUncheckedCreateWithoutSyllabusInput>
  }

  export type SyllabusSubjectUpdateWithWhereUniqueWithoutSyllabusInput = {
    where: SyllabusSubjectWhereUniqueInput
    data: XOR<SyllabusSubjectUpdateWithoutSyllabusInput, SyllabusSubjectUncheckedUpdateWithoutSyllabusInput>
  }

  export type SyllabusSubjectUpdateManyWithWhereWithoutSyllabusInput = {
    where: SyllabusSubjectScalarWhereInput
    data: XOR<SyllabusSubjectUpdateManyMutationInput, SyllabusSubjectUncheckedUpdateManyWithoutSyllabusInput>
  }

  export type SyllabusSubjectScalarWhereInput = {
    AND?: SyllabusSubjectScalarWhereInput | SyllabusSubjectScalarWhereInput[]
    OR?: SyllabusSubjectScalarWhereInput[]
    NOT?: SyllabusSubjectScalarWhereInput | SyllabusSubjectScalarWhereInput[]
    id?: StringFilter<"SyllabusSubject"> | string
    syllabusID?: StringFilter<"SyllabusSubject"> | string
    subjectID?: StringFilter<"SyllabusSubject"> | string
  }

  export type SyllabusSubjectCreateWithoutSubjectInput = {
    id?: string
    syllabus: SyllabusCreateNestedOneWithoutSubjectsInput
  }

  export type SyllabusSubjectUncheckedCreateWithoutSubjectInput = {
    id?: string
    syllabusID: string
  }

  export type SyllabusSubjectCreateOrConnectWithoutSubjectInput = {
    where: SyllabusSubjectWhereUniqueInput
    create: XOR<SyllabusSubjectCreateWithoutSubjectInput, SyllabusSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type SyllabusSubjectCreateManySubjectInputEnvelope = {
    data: SyllabusSubjectCreateManySubjectInput | SyllabusSubjectCreateManySubjectInput[]
  }

  export type SyllabusSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: SyllabusSubjectWhereUniqueInput
    update: XOR<SyllabusSubjectUpdateWithoutSubjectInput, SyllabusSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<SyllabusSubjectCreateWithoutSubjectInput, SyllabusSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type SyllabusSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: SyllabusSubjectWhereUniqueInput
    data: XOR<SyllabusSubjectUpdateWithoutSubjectInput, SyllabusSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type SyllabusSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: SyllabusSubjectScalarWhereInput
    data: XOR<SyllabusSubjectUpdateManyMutationInput, SyllabusSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type SyllabusCreateWithoutSubjectsInput = {
    SyllabusID?: string
    Title?: string | null
    Description?: string | null
    education: EducationCreateNestedOneWithoutSyllabusInput
  }

  export type SyllabusUncheckedCreateWithoutSubjectsInput = {
    SyllabusID?: string
    Title?: string | null
    Description?: string | null
    educationID: string
  }

  export type SyllabusCreateOrConnectWithoutSubjectsInput = {
    where: SyllabusWhereUniqueInput
    create: XOR<SyllabusCreateWithoutSubjectsInput, SyllabusUncheckedCreateWithoutSubjectsInput>
  }

  export type SubjectCreateWithoutSyllabusesInput = {
    SubjectID?: string
    Name: string
  }

  export type SubjectUncheckedCreateWithoutSyllabusesInput = {
    SubjectID?: string
    Name: string
  }

  export type SubjectCreateOrConnectWithoutSyllabusesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutSyllabusesInput, SubjectUncheckedCreateWithoutSyllabusesInput>
  }

  export type SyllabusUpsertWithoutSubjectsInput = {
    update: XOR<SyllabusUpdateWithoutSubjectsInput, SyllabusUncheckedUpdateWithoutSubjectsInput>
    create: XOR<SyllabusCreateWithoutSubjectsInput, SyllabusUncheckedCreateWithoutSubjectsInput>
    where?: SyllabusWhereInput
  }

  export type SyllabusUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: SyllabusWhereInput
    data: XOR<SyllabusUpdateWithoutSubjectsInput, SyllabusUncheckedUpdateWithoutSubjectsInput>
  }

  export type SyllabusUpdateWithoutSubjectsInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    education?: EducationUpdateOneRequiredWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateWithoutSubjectsInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    educationID?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectUpsertWithoutSyllabusesInput = {
    update: XOR<SubjectUpdateWithoutSyllabusesInput, SubjectUncheckedUpdateWithoutSyllabusesInput>
    create: XOR<SubjectCreateWithoutSyllabusesInput, SubjectUncheckedCreateWithoutSyllabusesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutSyllabusesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutSyllabusesInput, SubjectUncheckedUpdateWithoutSyllabusesInput>
  }

  export type SubjectUpdateWithoutSyllabusesInput = {
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type SubjectUncheckedUpdateWithoutSyllabusesInput = {
    Name?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerCreateWithoutComplainsInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    BookingID?: BookingCreateNestedManyWithoutCustomerInput
    ServiceProvider?: Customer_ProviderCreateNestedManyWithoutCustomersInput
    feedbackRating?: FeedbackRatingCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutComplainsInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    BookingID?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    ServiceProvider?: Customer_ProviderUncheckedCreateNestedManyWithoutCustomersInput
    feedbackRating?: FeedbackRatingUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutComplainsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutComplainsInput, CustomerUncheckedCreateWithoutComplainsInput>
  }

  export type CustomerUpsertWithoutComplainsInput = {
    update: XOR<CustomerUpdateWithoutComplainsInput, CustomerUncheckedUpdateWithoutComplainsInput>
    create: XOR<CustomerCreateWithoutComplainsInput, CustomerUncheckedCreateWithoutComplainsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutComplainsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutComplainsInput, CustomerUncheckedUpdateWithoutComplainsInput>
  }

  export type CustomerUpdateWithoutComplainsInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    BookingID?: BookingUpdateManyWithoutCustomerNestedInput
    ServiceProvider?: Customer_ProviderUpdateManyWithoutCustomersNestedInput
    feedbackRating?: FeedbackRatingUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutComplainsInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    BookingID?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    ServiceProvider?: Customer_ProviderUncheckedUpdateManyWithoutCustomersNestedInput
    feedbackRating?: FeedbackRatingUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CategoryCreateWithoutServiceInput = {
    CategoryID?: string
    Type?: string | null
    education?: EducationCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutServiceInput = {
    CategoryID?: string
    Type?: string | null
    education?: EducationUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutServiceInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutServiceInput, CategoryUncheckedCreateWithoutServiceInput>
  }

  export type ServiceProviderCreateWithoutServiceInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    bookings?: BookingCreateNestedManyWithoutServiceProviderInput
    serviceProvider_Reports?: ServiceProvider_ReportsCreateNestedOneWithoutServiceProviderInput
    schedule?: ScheduleCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderCreateNestedManyWithoutServiceProviderInput
    providerSalary?: ProviderSalaryCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutServiceInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedCreateNestedOneWithoutServiceProviderInput
    schedule?: ScheduleUncheckedCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderUncheckedCreateNestedManyWithoutServiceProviderInput
    providerSalary?: ProviderSalaryUncheckedCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderCreateOrConnectWithoutServiceInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutServiceInput, ServiceProviderUncheckedCreateWithoutServiceInput>
  }

  export type ServiceProviderCreateManyServiceInputEnvelope = {
    data: ServiceProviderCreateManyServiceInput | ServiceProviderCreateManyServiceInput[]
  }

  export type CategoryUpsertWithoutServiceInput = {
    update: XOR<CategoryUpdateWithoutServiceInput, CategoryUncheckedUpdateWithoutServiceInput>
    create: XOR<CategoryCreateWithoutServiceInput, CategoryUncheckedCreateWithoutServiceInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutServiceInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutServiceInput, CategoryUncheckedUpdateWithoutServiceInput>
  }

  export type CategoryUpdateWithoutServiceInput = {
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    education?: EducationUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutServiceInput = {
    Type?: NullableStringFieldUpdateOperationsInput | string | null
    education?: EducationUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ServiceProviderUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceProviderWhereUniqueInput
    update: XOR<ServiceProviderUpdateWithoutServiceInput, ServiceProviderUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceProviderCreateWithoutServiceInput, ServiceProviderUncheckedCreateWithoutServiceInput>
  }

  export type ServiceProviderUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceProviderWhereUniqueInput
    data: XOR<ServiceProviderUpdateWithoutServiceInput, ServiceProviderUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceProviderUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceProviderScalarWhereInput
    data: XOR<ServiceProviderUpdateManyMutationInput, ServiceProviderUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceProviderScalarWhereInput = {
    AND?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
    OR?: ServiceProviderScalarWhereInput[]
    NOT?: ServiceProviderScalarWhereInput | ServiceProviderScalarWhereInput[]
    ProviderID?: StringFilter<"ServiceProvider"> | string
    FirstName?: StringNullableFilter<"ServiceProvider"> | string | null
    LastName?: StringNullableFilter<"ServiceProvider"> | string | null
    MobileNumber?: StringNullableFilter<"ServiceProvider"> | string | null
    NIC?: StringNullableFilter<"ServiceProvider"> | string | null
    Address?: StringNullableFilter<"ServiceProvider"> | string | null
    email?: StringNullableFilter<"ServiceProvider"> | string | null
    password?: StringFilter<"ServiceProvider"> | string
    Availability?: BoolFilter<"ServiceProvider"> | boolean
    ServiceType?: StringFilter<"ServiceProvider"> | string
  }

  export type BookingCreateWithoutServiceProviderInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
    customer: CustomerCreateNestedOneWithoutBookingIDInput
    payment?: PaymentCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutServiceProviderInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
    CustomerID: string
    payment?: PaymentUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutServiceProviderInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput>
  }

  export type BookingCreateManyServiceProviderInputEnvelope = {
    data: BookingCreateManyServiceProviderInput | BookingCreateManyServiceProviderInput[]
  }

  export type ServiceProvider_ReportsCreateWithoutServiceProviderInput = {
    ReportID?: string
    BirthCertificate?: string | null
    PoliceReport?: string | null
    NIC_Copy?: string | null
  }

  export type ServiceProvider_ReportsUncheckedCreateWithoutServiceProviderInput = {
    ReportID?: string
    BirthCertificate?: string | null
    PoliceReport?: string | null
    NIC_Copy?: string | null
  }

  export type ServiceProvider_ReportsCreateOrConnectWithoutServiceProviderInput = {
    where: ServiceProvider_ReportsWhereUniqueInput
    create: XOR<ServiceProvider_ReportsCreateWithoutServiceProviderInput, ServiceProvider_ReportsUncheckedCreateWithoutServiceProviderInput>
  }

  export type ScheduleCreateWithoutServiceProviderInput = {
    scheduleId?: string
    scheduleDate?: Date | string
    AgreementTime?: string | null
    startDate?: string | null
  }

  export type ScheduleUncheckedCreateWithoutServiceProviderInput = {
    scheduleId?: string
    scheduleDate?: Date | string
    AgreementTime?: string | null
    startDate?: string | null
  }

  export type ScheduleCreateOrConnectWithoutServiceProviderInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutServiceProviderInput, ScheduleUncheckedCreateWithoutServiceProviderInput>
  }

  export type Customer_ProviderCreateWithoutServiceProviderInput = {
    id?: string
    customers: CustomerCreateNestedOneWithoutServiceProviderInput
  }

  export type Customer_ProviderUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    customer: string
  }

  export type Customer_ProviderCreateOrConnectWithoutServiceProviderInput = {
    where: Customer_ProviderWhereUniqueInput
    create: XOR<Customer_ProviderCreateWithoutServiceProviderInput, Customer_ProviderUncheckedCreateWithoutServiceProviderInput>
  }

  export type Customer_ProviderCreateManyServiceProviderInputEnvelope = {
    data: Customer_ProviderCreateManyServiceProviderInput | Customer_ProviderCreateManyServiceProviderInput[]
  }

  export type ProviderSalaryCreateWithoutServiceProviderInput = {
    id?: string
    EPF?: number | null
    ETF?: number | null
    totSalary?: number | null
  }

  export type ProviderSalaryUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    EPF?: number | null
    ETF?: number | null
    totSalary?: number | null
  }

  export type ProviderSalaryCreateOrConnectWithoutServiceProviderInput = {
    where: ProviderSalaryWhereUniqueInput
    create: XOR<ProviderSalaryCreateWithoutServiceProviderInput, ProviderSalaryUncheckedCreateWithoutServiceProviderInput>
  }

  export type ServiceCreateWithoutServiceProviderInput = {
    ServiceID?: string
    ServiceName: string
    CommisionRate: number
    Description: string
    category: CategoryCreateNestedOneWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceProviderInput = {
    ServiceID?: string
    ServiceName: string
    Category: string
    CommisionRate: number
    Description: string
  }

  export type ServiceCreateOrConnectWithoutServiceProviderInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceProviderInput, ServiceUncheckedCreateWithoutServiceProviderInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutServiceProviderInput, BookingUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutServiceProviderInput, BookingUncheckedUpdateWithoutServiceProviderInput>
  }

  export type BookingUpdateManyWithWhereWithoutServiceProviderInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type ServiceProvider_ReportsUpsertWithoutServiceProviderInput = {
    update: XOR<ServiceProvider_ReportsUpdateWithoutServiceProviderInput, ServiceProvider_ReportsUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<ServiceProvider_ReportsCreateWithoutServiceProviderInput, ServiceProvider_ReportsUncheckedCreateWithoutServiceProviderInput>
    where?: ServiceProvider_ReportsWhereInput
  }

  export type ServiceProvider_ReportsUpdateToOneWithWhereWithoutServiceProviderInput = {
    where?: ServiceProvider_ReportsWhereInput
    data: XOR<ServiceProvider_ReportsUpdateWithoutServiceProviderInput, ServiceProvider_ReportsUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ServiceProvider_ReportsUpdateWithoutServiceProviderInput = {
    BirthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    PoliceReport?: NullableStringFieldUpdateOperationsInput | string | null
    NIC_Copy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceProvider_ReportsUncheckedUpdateWithoutServiceProviderInput = {
    BirthCertificate?: NullableStringFieldUpdateOperationsInput | string | null
    PoliceReport?: NullableStringFieldUpdateOperationsInput | string | null
    NIC_Copy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleUpsertWithoutServiceProviderInput = {
    update: XOR<ScheduleUpdateWithoutServiceProviderInput, ScheduleUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<ScheduleCreateWithoutServiceProviderInput, ScheduleUncheckedCreateWithoutServiceProviderInput>
    where?: ScheduleWhereInput
  }

  export type ScheduleUpdateToOneWithWhereWithoutServiceProviderInput = {
    where?: ScheduleWhereInput
    data: XOR<ScheduleUpdateWithoutServiceProviderInput, ScheduleUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ScheduleUpdateWithoutServiceProviderInput = {
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    AgreementTime?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleUncheckedUpdateWithoutServiceProviderInput = {
    scheduleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    AgreementTime?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Customer_ProviderUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: Customer_ProviderWhereUniqueInput
    update: XOR<Customer_ProviderUpdateWithoutServiceProviderInput, Customer_ProviderUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<Customer_ProviderCreateWithoutServiceProviderInput, Customer_ProviderUncheckedCreateWithoutServiceProviderInput>
  }

  export type Customer_ProviderUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: Customer_ProviderWhereUniqueInput
    data: XOR<Customer_ProviderUpdateWithoutServiceProviderInput, Customer_ProviderUncheckedUpdateWithoutServiceProviderInput>
  }

  export type Customer_ProviderUpdateManyWithWhereWithoutServiceProviderInput = {
    where: Customer_ProviderScalarWhereInput
    data: XOR<Customer_ProviderUpdateManyMutationInput, Customer_ProviderUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type ProviderSalaryUpsertWithoutServiceProviderInput = {
    update: XOR<ProviderSalaryUpdateWithoutServiceProviderInput, ProviderSalaryUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<ProviderSalaryCreateWithoutServiceProviderInput, ProviderSalaryUncheckedCreateWithoutServiceProviderInput>
    where?: ProviderSalaryWhereInput
  }

  export type ProviderSalaryUpdateToOneWithWhereWithoutServiceProviderInput = {
    where?: ProviderSalaryWhereInput
    data: XOR<ProviderSalaryUpdateWithoutServiceProviderInput, ProviderSalaryUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ProviderSalaryUpdateWithoutServiceProviderInput = {
    EPF?: NullableFloatFieldUpdateOperationsInput | number | null
    ETF?: NullableFloatFieldUpdateOperationsInput | number | null
    totSalary?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ProviderSalaryUncheckedUpdateWithoutServiceProviderInput = {
    EPF?: NullableFloatFieldUpdateOperationsInput | number | null
    ETF?: NullableFloatFieldUpdateOperationsInput | number | null
    totSalary?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type ServiceUpsertWithoutServiceProviderInput = {
    update: XOR<ServiceUpdateWithoutServiceProviderInput, ServiceUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<ServiceCreateWithoutServiceProviderInput, ServiceUncheckedCreateWithoutServiceProviderInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServiceProviderInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServiceProviderInput, ServiceUncheckedUpdateWithoutServiceProviderInput>
  }

  export type ServiceUpdateWithoutServiceProviderInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    CommisionRate?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceProviderInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    Category?: StringFieldUpdateOperationsInput | string
    CommisionRate?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceProviderCreateWithoutCustomerInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    bookings?: BookingCreateNestedManyWithoutServiceProviderInput
    serviceProvider_Reports?: ServiceProvider_ReportsCreateNestedOneWithoutServiceProviderInput
    schedule?: ScheduleCreateNestedOneWithoutServiceProviderInput
    providerSalary?: ProviderSalaryCreateNestedOneWithoutServiceProviderInput
    service: ServiceCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutCustomerInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    ServiceType: string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedCreateNestedOneWithoutServiceProviderInput
    schedule?: ScheduleUncheckedCreateNestedOneWithoutServiceProviderInput
    providerSalary?: ProviderSalaryUncheckedCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderCreateOrConnectWithoutCustomerInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutCustomerInput, ServiceProviderUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerCreateWithoutServiceProviderInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    BookingID?: BookingCreateNestedManyWithoutCustomerInput
    Complains?: ComplainCreateNestedManyWithoutCustomersInput
    feedbackRating?: FeedbackRatingCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    BookingID?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    Complains?: ComplainUncheckedCreateNestedManyWithoutCustomersInput
    feedbackRating?: FeedbackRatingUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutServiceProviderInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutServiceProviderInput, CustomerUncheckedCreateWithoutServiceProviderInput>
  }

  export type ServiceProviderUpsertWithoutCustomerInput = {
    update: XOR<ServiceProviderUpdateWithoutCustomerInput, ServiceProviderUncheckedUpdateWithoutCustomerInput>
    create: XOR<ServiceProviderCreateWithoutCustomerInput, ServiceProviderUncheckedCreateWithoutCustomerInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutCustomerInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutCustomerInput, ServiceProviderUncheckedUpdateWithoutCustomerInput>
  }

  export type ServiceProviderUpdateWithoutCustomerInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUpdateManyWithoutServiceProviderNestedInput
    serviceProvider_Reports?: ServiceProvider_ReportsUpdateOneWithoutServiceProviderNestedInput
    schedule?: ScheduleUpdateOneWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUpdateOneWithoutServiceProviderNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutCustomerInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    ServiceType?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedUpdateOneWithoutServiceProviderNestedInput
    schedule?: ScheduleUncheckedUpdateOneWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUncheckedUpdateOneWithoutServiceProviderNestedInput
  }

  export type CustomerUpsertWithoutServiceProviderInput = {
    update: XOR<CustomerUpdateWithoutServiceProviderInput, CustomerUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<CustomerCreateWithoutServiceProviderInput, CustomerUncheckedCreateWithoutServiceProviderInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutServiceProviderInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutServiceProviderInput, CustomerUncheckedUpdateWithoutServiceProviderInput>
  }

  export type CustomerUpdateWithoutServiceProviderInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    BookingID?: BookingUpdateManyWithoutCustomerNestedInput
    Complains?: ComplainUpdateManyWithoutCustomersNestedInput
    feedbackRating?: FeedbackRatingUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutServiceProviderInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    BookingID?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    Complains?: ComplainUncheckedUpdateManyWithoutCustomersNestedInput
    feedbackRating?: FeedbackRatingUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ServiceProviderCreateWithoutServiceProvider_ReportsInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    bookings?: BookingCreateNestedManyWithoutServiceProviderInput
    schedule?: ScheduleCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderCreateNestedManyWithoutServiceProviderInput
    providerSalary?: ProviderSalaryCreateNestedOneWithoutServiceProviderInput
    service: ServiceCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutServiceProvider_ReportsInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    ServiceType: string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    schedule?: ScheduleUncheckedCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderUncheckedCreateNestedManyWithoutServiceProviderInput
    providerSalary?: ProviderSalaryUncheckedCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderCreateOrConnectWithoutServiceProvider_ReportsInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutServiceProvider_ReportsInput, ServiceProviderUncheckedCreateWithoutServiceProvider_ReportsInput>
  }

  export type ServiceProviderUpsertWithoutServiceProvider_ReportsInput = {
    update: XOR<ServiceProviderUpdateWithoutServiceProvider_ReportsInput, ServiceProviderUncheckedUpdateWithoutServiceProvider_ReportsInput>
    create: XOR<ServiceProviderCreateWithoutServiceProvider_ReportsInput, ServiceProviderUncheckedCreateWithoutServiceProvider_ReportsInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutServiceProvider_ReportsInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutServiceProvider_ReportsInput, ServiceProviderUncheckedUpdateWithoutServiceProvider_ReportsInput>
  }

  export type ServiceProviderUpdateWithoutServiceProvider_ReportsInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUpdateManyWithoutServiceProviderNestedInput
    schedule?: ScheduleUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUpdateManyWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUpdateOneWithoutServiceProviderNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutServiceProvider_ReportsInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    ServiceType?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    schedule?: ScheduleUncheckedUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUncheckedUpdateManyWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUncheckedUpdateOneWithoutServiceProviderNestedInput
  }

  export type CustomerCreateWithoutBookingIDInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    Complains?: ComplainCreateNestedManyWithoutCustomersInput
    ServiceProvider?: Customer_ProviderCreateNestedManyWithoutCustomersInput
    feedbackRating?: FeedbackRatingCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutBookingIDInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    Complains?: ComplainUncheckedCreateNestedManyWithoutCustomersInput
    ServiceProvider?: Customer_ProviderUncheckedCreateNestedManyWithoutCustomersInput
    feedbackRating?: FeedbackRatingUncheckedCreateNestedManyWithoutCustomerInput
    refundRequests?: RefundRequestsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutBookingIDInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutBookingIDInput, CustomerUncheckedCreateWithoutBookingIDInput>
  }

  export type ServiceProviderCreateWithoutBookingsInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    serviceProvider_Reports?: ServiceProvider_ReportsCreateNestedOneWithoutServiceProviderInput
    schedule?: ScheduleCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderCreateNestedManyWithoutServiceProviderInput
    providerSalary?: ProviderSalaryCreateNestedOneWithoutServiceProviderInput
    service: ServiceCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutBookingsInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    ServiceType: string
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedCreateNestedOneWithoutServiceProviderInput
    schedule?: ScheduleUncheckedCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderUncheckedCreateNestedManyWithoutServiceProviderInput
    providerSalary?: ProviderSalaryUncheckedCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderCreateOrConnectWithoutBookingsInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutBookingsInput, ServiceProviderUncheckedCreateWithoutBookingsInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    Status?: $Enums.PaymentStatus
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentInput
    refundRequests?: RefundRequestsCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    PaymentMethod: string
    Status?: $Enums.PaymentStatus
    refundRequests?: RefundRequestsUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
  }

  export type CustomerUpsertWithoutBookingIDInput = {
    update: XOR<CustomerUpdateWithoutBookingIDInput, CustomerUncheckedUpdateWithoutBookingIDInput>
    create: XOR<CustomerCreateWithoutBookingIDInput, CustomerUncheckedCreateWithoutBookingIDInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutBookingIDInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutBookingIDInput, CustomerUncheckedUpdateWithoutBookingIDInput>
  }

  export type CustomerUpdateWithoutBookingIDInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Complains?: ComplainUpdateManyWithoutCustomersNestedInput
    ServiceProvider?: Customer_ProviderUpdateManyWithoutCustomersNestedInput
    feedbackRating?: FeedbackRatingUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutBookingIDInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Complains?: ComplainUncheckedUpdateManyWithoutCustomersNestedInput
    ServiceProvider?: Customer_ProviderUncheckedUpdateManyWithoutCustomersNestedInput
    feedbackRating?: FeedbackRatingUncheckedUpdateManyWithoutCustomerNestedInput
    refundRequests?: RefundRequestsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ServiceProviderUpsertWithoutBookingsInput = {
    update: XOR<ServiceProviderUpdateWithoutBookingsInput, ServiceProviderUncheckedUpdateWithoutBookingsInput>
    create: XOR<ServiceProviderCreateWithoutBookingsInput, ServiceProviderUncheckedCreateWithoutBookingsInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutBookingsInput, ServiceProviderUncheckedUpdateWithoutBookingsInput>
  }

  export type ServiceProviderUpdateWithoutBookingsInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    serviceProvider_Reports?: ServiceProvider_ReportsUpdateOneWithoutServiceProviderNestedInput
    schedule?: ScheduleUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUpdateManyWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUpdateOneWithoutServiceProviderNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutBookingsInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    ServiceType?: StringFieldUpdateOperationsInput | string
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedUpdateOneWithoutServiceProviderNestedInput
    schedule?: ScheduleUncheckedUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUncheckedUpdateManyWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUncheckedUpdateOneWithoutServiceProviderNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    paymentID?: StringFilter<"Payment"> | string
    PaymentDate?: DateTimeFilter<"Payment"> | Date | string
    Amount?: FloatNullableFilter<"Payment"> | number | null
    PaymentMethod?: StringFilter<"Payment"> | string
    BookingId?: StringFilter<"Payment"> | string
    Status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
  }

  export type PaymentCreateWithoutPaymentMethodInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    Status?: $Enums.PaymentStatus
    booking: BookingCreateNestedOneWithoutPaymentInput
    refundRequests?: RefundRequestsCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutPaymentMethodInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    BookingId: string
    Status?: $Enums.PaymentStatus
    refundRequests?: RefundRequestsUncheckedCreateNestedOneWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentCreateManyPaymentMethodInputEnvelope = {
    data: PaymentCreateManyPaymentMethodInput | PaymentCreateManyPaymentMethodInput[]
  }

  export type PaymentUpsertWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPaymentMethodInput, PaymentUncheckedUpdateWithoutPaymentMethodInput>
    create: XOR<PaymentCreateWithoutPaymentMethodInput, PaymentUncheckedCreateWithoutPaymentMethodInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPaymentMethodInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPaymentMethodInput, PaymentUncheckedUpdateWithoutPaymentMethodInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPaymentMethodInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPaymentMethodInput>
  }

  export type PaymentMethodCreateWithoutPaymentInput = {
    MethodId?: string
    PaymentType?: string | null
    Description?: string | null
  }

  export type PaymentMethodUncheckedCreateWithoutPaymentInput = {
    MethodId?: string
    PaymentType?: string | null
    Description?: string | null
  }

  export type PaymentMethodCreateOrConnectWithoutPaymentInput = {
    where: PaymentMethodWhereUniqueInput
    create: XOR<PaymentMethodCreateWithoutPaymentInput, PaymentMethodUncheckedCreateWithoutPaymentInput>
  }

  export type BookingCreateWithoutPaymentInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
    customer: CustomerCreateNestedOneWithoutBookingIDInput
    serviceProvider: ServiceProviderCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutPaymentInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    Provider: string
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
    CustomerID: string
  }

  export type BookingCreateOrConnectWithoutPaymentInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
  }

  export type RefundRequestsCreateWithoutPaymentInput = {
    refundId?: string
    amount?: number | null
    reason?: string | null
    requestAt?: Date | string
    status?: $Enums.refundStatus
    customer: CustomerCreateNestedOneWithoutRefundRequestsInput
  }

  export type RefundRequestsUncheckedCreateWithoutPaymentInput = {
    refundId?: string
    customerID: string
    amount?: number | null
    reason?: string | null
    requestAt?: Date | string
    status?: $Enums.refundStatus
  }

  export type RefundRequestsCreateOrConnectWithoutPaymentInput = {
    where: RefundRequestsWhereUniqueInput
    create: XOR<RefundRequestsCreateWithoutPaymentInput, RefundRequestsUncheckedCreateWithoutPaymentInput>
  }

  export type PaymentMethodUpsertWithoutPaymentInput = {
    update: XOR<PaymentMethodUpdateWithoutPaymentInput, PaymentMethodUncheckedUpdateWithoutPaymentInput>
    create: XOR<PaymentMethodCreateWithoutPaymentInput, PaymentMethodUncheckedCreateWithoutPaymentInput>
    where?: PaymentMethodWhereInput
  }

  export type PaymentMethodUpdateToOneWithWhereWithoutPaymentInput = {
    where?: PaymentMethodWhereInput
    data: XOR<PaymentMethodUpdateWithoutPaymentInput, PaymentMethodUncheckedUpdateWithoutPaymentInput>
  }

  export type PaymentMethodUpdateWithoutPaymentInput = {
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentMethodUncheckedUpdateWithoutPaymentInput = {
    PaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookingUpsertWithoutPaymentInput = {
    update: XOR<BookingUpdateWithoutPaymentInput, BookingUncheckedUpdateWithoutPaymentInput>
    create: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentInput, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type BookingUpdateWithoutPaymentInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    customer?: CustomerUpdateOneRequiredWithoutBookingIDNestedInput
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: StringFieldUpdateOperationsInput | string
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    CustomerID?: StringFieldUpdateOperationsInput | string
  }

  export type RefundRequestsUpsertWithoutPaymentInput = {
    update: XOR<RefundRequestsUpdateWithoutPaymentInput, RefundRequestsUncheckedUpdateWithoutPaymentInput>
    create: XOR<RefundRequestsCreateWithoutPaymentInput, RefundRequestsUncheckedCreateWithoutPaymentInput>
    where?: RefundRequestsWhereInput
  }

  export type RefundRequestsUpdateToOneWithWhereWithoutPaymentInput = {
    where?: RefundRequestsWhereInput
    data: XOR<RefundRequestsUpdateWithoutPaymentInput, RefundRequestsUncheckedUpdateWithoutPaymentInput>
  }

  export type RefundRequestsUpdateWithoutPaymentInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumrefundStatusFieldUpdateOperationsInput | $Enums.refundStatus
    customer?: CustomerUpdateOneRequiredWithoutRefundRequestsNestedInput
  }

  export type RefundRequestsUncheckedUpdateWithoutPaymentInput = {
    customerID?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumrefundStatusFieldUpdateOperationsInput | $Enums.refundStatus
  }

  export type ServiceProviderCreateWithoutScheduleInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    bookings?: BookingCreateNestedManyWithoutServiceProviderInput
    serviceProvider_Reports?: ServiceProvider_ReportsCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderCreateNestedManyWithoutServiceProviderInput
    providerSalary?: ProviderSalaryCreateNestedOneWithoutServiceProviderInput
    service: ServiceCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutScheduleInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    ServiceType: string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderUncheckedCreateNestedManyWithoutServiceProviderInput
    providerSalary?: ProviderSalaryUncheckedCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderCreateOrConnectWithoutScheduleInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutScheduleInput, ServiceProviderUncheckedCreateWithoutScheduleInput>
  }

  export type ServiceProviderUpsertWithoutScheduleInput = {
    update: XOR<ServiceProviderUpdateWithoutScheduleInput, ServiceProviderUncheckedUpdateWithoutScheduleInput>
    create: XOR<ServiceProviderCreateWithoutScheduleInput, ServiceProviderUncheckedCreateWithoutScheduleInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutScheduleInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutScheduleInput, ServiceProviderUncheckedUpdateWithoutScheduleInput>
  }

  export type ServiceProviderUpdateWithoutScheduleInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUpdateManyWithoutServiceProviderNestedInput
    serviceProvider_Reports?: ServiceProvider_ReportsUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUpdateManyWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUpdateOneWithoutServiceProviderNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutScheduleInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    ServiceType?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUncheckedUpdateManyWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUncheckedUpdateOneWithoutServiceProviderNestedInput
  }

  export type CustomerCreateWithoutFeedbackRatingInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    BookingID?: BookingCreateNestedManyWithoutCustomerInput
    Complains?: ComplainCreateNestedManyWithoutCustomersInput
    ServiceProvider?: Customer_ProviderCreateNestedManyWithoutCustomersInput
    refundRequests?: RefundRequestsCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutFeedbackRatingInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    BookingID?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    Complains?: ComplainUncheckedCreateNestedManyWithoutCustomersInput
    ServiceProvider?: Customer_ProviderUncheckedCreateNestedManyWithoutCustomersInput
    refundRequests?: RefundRequestsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutFeedbackRatingInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutFeedbackRatingInput, CustomerUncheckedCreateWithoutFeedbackRatingInput>
  }

  export type CustomerUpsertWithoutFeedbackRatingInput = {
    update: XOR<CustomerUpdateWithoutFeedbackRatingInput, CustomerUncheckedUpdateWithoutFeedbackRatingInput>
    create: XOR<CustomerCreateWithoutFeedbackRatingInput, CustomerUncheckedCreateWithoutFeedbackRatingInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutFeedbackRatingInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutFeedbackRatingInput, CustomerUncheckedUpdateWithoutFeedbackRatingInput>
  }

  export type CustomerUpdateWithoutFeedbackRatingInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    BookingID?: BookingUpdateManyWithoutCustomerNestedInput
    Complains?: ComplainUpdateManyWithoutCustomersNestedInput
    ServiceProvider?: Customer_ProviderUpdateManyWithoutCustomersNestedInput
    refundRequests?: RefundRequestsUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutFeedbackRatingInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    BookingID?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    Complains?: ComplainUncheckedUpdateManyWithoutCustomersNestedInput
    ServiceProvider?: Customer_ProviderUncheckedUpdateManyWithoutCustomersNestedInput
    refundRequests?: RefundRequestsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ServiceProviderCreateWithoutProviderSalaryInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    bookings?: BookingCreateNestedManyWithoutServiceProviderInput
    serviceProvider_Reports?: ServiceProvider_ReportsCreateNestedOneWithoutServiceProviderInput
    schedule?: ScheduleCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderCreateNestedManyWithoutServiceProviderInput
    service: ServiceCreateNestedOneWithoutServiceProviderInput
  }

  export type ServiceProviderUncheckedCreateWithoutProviderSalaryInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
    ServiceType: string
    bookings?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedCreateNestedOneWithoutServiceProviderInput
    schedule?: ScheduleUncheckedCreateNestedOneWithoutServiceProviderInput
    customer?: Customer_ProviderUncheckedCreateNestedManyWithoutServiceProviderInput
  }

  export type ServiceProviderCreateOrConnectWithoutProviderSalaryInput = {
    where: ServiceProviderWhereUniqueInput
    create: XOR<ServiceProviderCreateWithoutProviderSalaryInput, ServiceProviderUncheckedCreateWithoutProviderSalaryInput>
  }

  export type ServiceProviderUpsertWithoutProviderSalaryInput = {
    update: XOR<ServiceProviderUpdateWithoutProviderSalaryInput, ServiceProviderUncheckedUpdateWithoutProviderSalaryInput>
    create: XOR<ServiceProviderCreateWithoutProviderSalaryInput, ServiceProviderUncheckedCreateWithoutProviderSalaryInput>
    where?: ServiceProviderWhereInput
  }

  export type ServiceProviderUpdateToOneWithWhereWithoutProviderSalaryInput = {
    where?: ServiceProviderWhereInput
    data: XOR<ServiceProviderUpdateWithoutProviderSalaryInput, ServiceProviderUncheckedUpdateWithoutProviderSalaryInput>
  }

  export type ServiceProviderUpdateWithoutProviderSalaryInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUpdateManyWithoutServiceProviderNestedInput
    serviceProvider_Reports?: ServiceProvider_ReportsUpdateOneWithoutServiceProviderNestedInput
    schedule?: ScheduleUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUpdateManyWithoutServiceProviderNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutProviderSalaryInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    ServiceType?: StringFieldUpdateOperationsInput | string
    bookings?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedUpdateOneWithoutServiceProviderNestedInput
    schedule?: ScheduleUncheckedUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUncheckedUpdateManyWithoutServiceProviderNestedInput
  }

  export type CustomerCreateWithoutRefundRequestsInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    BookingID?: BookingCreateNestedManyWithoutCustomerInput
    Complains?: ComplainCreateNestedManyWithoutCustomersInput
    ServiceProvider?: Customer_ProviderCreateNestedManyWithoutCustomersInput
    feedbackRating?: FeedbackRatingCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutRefundRequestsInput = {
    id?: string
    FirstName?: string | null
    LastName?: string | null
    Gender?: string | null
    Email?: string | null
    Password?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    BookingID?: BookingUncheckedCreateNestedManyWithoutCustomerInput
    Complains?: ComplainUncheckedCreateNestedManyWithoutCustomersInput
    ServiceProvider?: Customer_ProviderUncheckedCreateNestedManyWithoutCustomersInput
    feedbackRating?: FeedbackRatingUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutRefundRequestsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutRefundRequestsInput, CustomerUncheckedCreateWithoutRefundRequestsInput>
  }

  export type PaymentCreateWithoutRefundRequestsInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    Status?: $Enums.PaymentStatus
    paymentMethod: PaymentMethodCreateNestedOneWithoutPaymentInput
    booking: BookingCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutRefundRequestsInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    PaymentMethod: string
    BookingId: string
    Status?: $Enums.PaymentStatus
  }

  export type PaymentCreateOrConnectWithoutRefundRequestsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutRefundRequestsInput, PaymentUncheckedCreateWithoutRefundRequestsInput>
  }

  export type CustomerUpsertWithoutRefundRequestsInput = {
    update: XOR<CustomerUpdateWithoutRefundRequestsInput, CustomerUncheckedUpdateWithoutRefundRequestsInput>
    create: XOR<CustomerCreateWithoutRefundRequestsInput, CustomerUncheckedCreateWithoutRefundRequestsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutRefundRequestsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutRefundRequestsInput, CustomerUncheckedUpdateWithoutRefundRequestsInput>
  }

  export type CustomerUpdateWithoutRefundRequestsInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    BookingID?: BookingUpdateManyWithoutCustomerNestedInput
    Complains?: ComplainUpdateManyWithoutCustomersNestedInput
    ServiceProvider?: Customer_ProviderUpdateManyWithoutCustomersNestedInput
    feedbackRating?: FeedbackRatingUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutRefundRequestsInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    BookingID?: BookingUncheckedUpdateManyWithoutCustomerNestedInput
    Complains?: ComplainUncheckedUpdateManyWithoutCustomersNestedInput
    ServiceProvider?: Customer_ProviderUncheckedUpdateManyWithoutCustomersNestedInput
    feedbackRating?: FeedbackRatingUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PaymentUpsertWithoutRefundRequestsInput = {
    update: XOR<PaymentUpdateWithoutRefundRequestsInput, PaymentUncheckedUpdateWithoutRefundRequestsInput>
    create: XOR<PaymentCreateWithoutRefundRequestsInput, PaymentUncheckedCreateWithoutRefundRequestsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutRefundRequestsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutRefundRequestsInput, PaymentUncheckedUpdateWithoutRefundRequestsInput>
  }

  export type PaymentUpdateWithoutRefundRequestsInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentNestedInput
    booking?: BookingUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutRefundRequestsInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentMethod?: StringFieldUpdateOperationsInput | string
    BookingId?: StringFieldUpdateOperationsInput | string
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
  }

  export type BookingCreateManyCustomerInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    Provider: string
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
  }

  export type ComplainCreateManyCustomersInput = {
    complainId?: string
    Reason?: string | null
    Status?: $Enums.complianStatus
  }

  export type Customer_ProviderCreateManyCustomersInput = {
    id?: string
    provider: string
  }

  export type FeedbackRatingCreateManyCustomerInput = {
    feedbackID?: string
    feedback?: string | null
    Rating?: number | null
  }

  export type RefundRequestsCreateManyCustomerInput = {
    refundId?: string
    paymentId: string
    amount?: number | null
    reason?: string | null
    requestAt?: Date | string
    status?: $Enums.refundStatus
  }

  export type BookingUpdateWithoutCustomerInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCustomerInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: StringFieldUpdateOperationsInput | string
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    payment?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutCustomerInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    Provider?: StringFieldUpdateOperationsInput | string
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
  }

  export type ComplainUpdateWithoutCustomersInput = {
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: EnumcomplianStatusFieldUpdateOperationsInput | $Enums.complianStatus
  }

  export type ComplainUncheckedUpdateWithoutCustomersInput = {
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: EnumcomplianStatusFieldUpdateOperationsInput | $Enums.complianStatus
  }

  export type ComplainUncheckedUpdateManyWithoutCustomersInput = {
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
    Status?: EnumcomplianStatusFieldUpdateOperationsInput | $Enums.complianStatus
  }

  export type Customer_ProviderUpdateWithoutCustomersInput = {
    serviceProvider?: ServiceProviderUpdateOneRequiredWithoutCustomerNestedInput
  }

  export type Customer_ProviderUncheckedUpdateWithoutCustomersInput = {
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type Customer_ProviderUncheckedUpdateManyWithoutCustomersInput = {
    provider?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackRatingUpdateWithoutCustomerInput = {
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    Rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FeedbackRatingUncheckedUpdateWithoutCustomerInput = {
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    Rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FeedbackRatingUncheckedUpdateManyWithoutCustomerInput = {
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    Rating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RefundRequestsUpdateWithoutCustomerInput = {
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumrefundStatusFieldUpdateOperationsInput | $Enums.refundStatus
    payment?: PaymentUpdateOneRequiredWithoutRefundRequestsNestedInput
  }

  export type RefundRequestsUncheckedUpdateWithoutCustomerInput = {
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumrefundStatusFieldUpdateOperationsInput | $Enums.refundStatus
  }

  export type RefundRequestsUncheckedUpdateManyWithoutCustomerInput = {
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumrefundStatusFieldUpdateOperationsInput | $Enums.refundStatus
  }

  export type ServiceCreateManyCategoryInput = {
    ServiceID?: string
    ServiceName: string
    CommisionRate: number
    Description: string
  }

  export type EducationCreateManyCategoryInput = {
    EducationId?: string
    deliveryMode?: string | null
  }

  export type ServiceUpdateWithoutCategoryInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    CommisionRate?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    serviceProvider?: ServiceProviderUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCategoryInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    CommisionRate?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
    serviceProvider?: ServiceProviderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutCategoryInput = {
    ServiceName?: StringFieldUpdateOperationsInput | string
    CommisionRate?: IntFieldUpdateOperationsInput | number
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type EducationUpdateWithoutCategoryInput = {
    deliveryMode?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus?: SyllabusUpdateManyWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateWithoutCategoryInput = {
    deliveryMode?: NullableStringFieldUpdateOperationsInput | string | null
    syllabus?: SyllabusUncheckedUpdateManyWithoutEducationNestedInput
  }

  export type EducationUncheckedUpdateManyWithoutCategoryInput = {
    deliveryMode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyllabusCreateManyEducationInput = {
    SyllabusID?: string
    Title?: string | null
    Description?: string | null
  }

  export type SyllabusUpdateWithoutEducationInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SyllabusSubjectUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateWithoutEducationInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
    subjects?: SyllabusSubjectUncheckedUpdateManyWithoutSyllabusNestedInput
  }

  export type SyllabusUncheckedUpdateManyWithoutEducationInput = {
    Title?: NullableStringFieldUpdateOperationsInput | string | null
    Description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyllabusSubjectCreateManySyllabusInput = {
    id?: string
    subjectID: string
  }

  export type SyllabusSubjectUpdateWithoutSyllabusInput = {
    subject?: SubjectUpdateOneRequiredWithoutSyllabusesNestedInput
  }

  export type SyllabusSubjectUncheckedUpdateWithoutSyllabusInput = {
    subjectID?: StringFieldUpdateOperationsInput | string
  }

  export type SyllabusSubjectUncheckedUpdateManyWithoutSyllabusInput = {
    subjectID?: StringFieldUpdateOperationsInput | string
  }

  export type SyllabusSubjectCreateManySubjectInput = {
    id?: string
    syllabusID: string
  }

  export type SyllabusSubjectUpdateWithoutSubjectInput = {
    syllabus?: SyllabusUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type SyllabusSubjectUncheckedUpdateWithoutSubjectInput = {
    syllabusID?: StringFieldUpdateOperationsInput | string
  }

  export type SyllabusSubjectUncheckedUpdateManyWithoutSubjectInput = {
    syllabusID?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceProviderCreateManyServiceInput = {
    ProviderID?: string
    FirstName?: string | null
    LastName?: string | null
    MobileNumber?: string | null
    NIC?: string | null
    Address?: string | null
    email?: string | null
    password: string
    Availability?: boolean
  }

  export type ServiceProviderUpdateWithoutServiceInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUpdateManyWithoutServiceProviderNestedInput
    serviceProvider_Reports?: ServiceProvider_ReportsUpdateOneWithoutServiceProviderNestedInput
    schedule?: ScheduleUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUpdateManyWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUpdateOneWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateWithoutServiceInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
    bookings?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    serviceProvider_Reports?: ServiceProvider_ReportsUncheckedUpdateOneWithoutServiceProviderNestedInput
    schedule?: ScheduleUncheckedUpdateOneWithoutServiceProviderNestedInput
    customer?: Customer_ProviderUncheckedUpdateManyWithoutServiceProviderNestedInput
    providerSalary?: ProviderSalaryUncheckedUpdateOneWithoutServiceProviderNestedInput
  }

  export type ServiceProviderUncheckedUpdateManyWithoutServiceInput = {
    FirstName?: NullableStringFieldUpdateOperationsInput | string | null
    LastName?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    NIC?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    Availability?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BookingCreateManyServiceProviderInput = {
    BookingID?: string
    AgreementDuration?: string | null
    Booking_Service?: string | null
    MonthlyPayment?: number | null
    BookingDate?: Date | string
    Status?: $Enums.BookingStatus
    CustomerID: string
  }

  export type Customer_ProviderCreateManyServiceProviderInput = {
    id?: string
    customer: string
  }

  export type BookingUpdateWithoutServiceProviderInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    customer?: CustomerUpdateOneRequiredWithoutBookingIDNestedInput
    payment?: PaymentUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutServiceProviderInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    CustomerID?: StringFieldUpdateOperationsInput | string
    payment?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutServiceProviderInput = {
    AgreementDuration?: NullableStringFieldUpdateOperationsInput | string | null
    Booking_Service?: NullableStringFieldUpdateOperationsInput | string | null
    MonthlyPayment?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    CustomerID?: StringFieldUpdateOperationsInput | string
  }

  export type Customer_ProviderUpdateWithoutServiceProviderInput = {
    customers?: CustomerUpdateOneRequiredWithoutServiceProviderNestedInput
  }

  export type Customer_ProviderUncheckedUpdateWithoutServiceProviderInput = {
    customer?: StringFieldUpdateOperationsInput | string
  }

  export type Customer_ProviderUncheckedUpdateManyWithoutServiceProviderInput = {
    customer?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateManyBookingInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    PaymentMethod: string
    Status?: $Enums.PaymentStatus
  }

  export type PaymentUpdateWithoutBookingInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: PaymentMethodUpdateOneRequiredWithoutPaymentNestedInput
    refundRequests?: RefundRequestsUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentMethod?: StringFieldUpdateOperationsInput | string
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    refundRequests?: RefundRequestsUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentMethod?: StringFieldUpdateOperationsInput | string
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
  }

  export type PaymentCreateManyPaymentMethodInput = {
    paymentID?: string
    PaymentDate?: Date | string
    Amount?: number | null
    BookingId: string
    Status?: $Enums.PaymentStatus
  }

  export type PaymentUpdateWithoutPaymentMethodInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    booking?: BookingUpdateOneRequiredWithoutPaymentNestedInput
    refundRequests?: RefundRequestsUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPaymentMethodInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingId?: StringFieldUpdateOperationsInput | string
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    refundRequests?: RefundRequestsUncheckedUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutPaymentMethodInput = {
    PaymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    BookingId?: StringFieldUpdateOperationsInput | string
    Status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}